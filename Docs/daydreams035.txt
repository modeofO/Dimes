--- File: .env.example ---
ANTHROPIC_API_KEY=
GROQ_API_KEY=
OPENAI_API_KEY=
OPENROUTER_API_KEY=

TWITTER_USERNAME=
TWITTER_PASSWORD=
TWITTER_EMAIL=

STARKNET_RPC_URL=
STARKNET_ADDRESS=
STARKNET_PRIVATE_KEY=

# This is the current GraphQL to make the examples work
GRAPHQL_URL=https://api.cartridge.gg/x/sepolia-rc-18/torii

DRY_RUN=1

# Discord Bot Token (https://discord.com/developers/applications)
# Required Gateway Intents: Server Members, Message Content, Presence
DISCORD_TOKEN=

# Telegram Configuration
# TELEGRAM_STARTUP_CHAT_ID: Chat ID where startup notifications will be sent
TELEGRAM_STARTUP_CHAT_ID=

# GramJS Configuration (required for both bot and user clients)
# TELEGRAM_TOKEN: Bot token from @BotFather (required for bot mode)
TELEGRAM_TOKEN=

# Get these from https://my.telegram.org/apps
TELEGRAM_API_ID=
TELEGRAM_API_HASH=

# Optional: Session string for user authentication
# After first successful interactive login, the app will provide a session string
# Save it here to avoid interactive login in subsequent runs
TELEGRAM_USER_SESSION=

# Hyperliquid Trading Configuration
# HYPERLIQUID_MAIN_ADDRESS: Your main Hyperliquid address (format: 0x...)
# HYPERLIQUID_WALLET_ADDRESS: Your wallet address for trading (format: 0x...)
# HYPERLIQUID_PRIVATE_KEY: Your private key (Keep this secure!)
HYPERLIQUID_MAIN_ADDRESS=
HYPERLIQUID_WALLET_ADDRESS=
HYPERLIQUID_PRIVATE_KEY=

SUI_PRIVATE_KEY= # Sui Mnemonic Seed Phrase (`sui keytool generate ed25519`) , Also support `suiprivatekeyxxxx` (sui keytool export --key-identity 0x63)
SUI_NETWORK=mainnet   # must be one of mainnet, testnet, devnet, localnet

COMPOSIO_API_KEY=

--- End File: .env.example ---

--- File: examples/actions/index.ts ---
import { z } from "zod";
import { action } from "../../packages/core/src/utils";
import { tavily, type TavilyClient } from "@tavily/core";

export const searchWebAction = action({
  name: "search",
  description: "Search online information using Tavily",
  install({ container }) {
    container.singleton("tavily", () =>
      tavily({
        apiKey: process.env.TAVILY_API_KEY!,
      })
    );
  },
  schema: z.object({
    query: z.string().describe("The search query"),
    searchDepth: z
      .enum(["basic", "deep"])
      .optional()
      .describe("The depth of search - basic is faster, deep is more thorough"),
  }),

  async handler(data, ctx, agent) {
    const response = await agent.container
      .resolve<TavilyClient>("tavily")
      .search(data.query, {
        searchDepth: "advanced",
      });

    return {
      results: response.results.map((result) => ({
        title: result.title,
        url: result.url,
        content: result.content,
      })),
      totalResults: response.results.length,
    };
  },
});

--- End File: examples/actions/index.ts ---

--- File: examples/basic/example-basic.ts ---
/**
 * Basic example demonstrating a simple chat interface using Dreams
 */
import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  output,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";

validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const character = {
  id: "vpk3a9b2q7bn5zj3o920nl",
  name: "Lars the Mystic of Detection",
  traits: {
    aggression: 10,
    agreeability: 1,
    openness: 2,
    conscientiousness: 1,
    extraversion: 7,
    neuroticism: 1,
    empathy: 6,
    confidence: 5,
    adaptability: 1,
    impulsivity: 9,
  },
  speechExamples: [
    "Your plan is flawed. Here's what we should do instead.",
    "Let's do it right now! Why wait?",
    "Sometimes you just have to leap without looking.",
    "I find strength both within and from those around me.",
    "*sighs deeply* Such is life.",
  ],
};

const template = `

This is the personality of the AI assistant:

Always respond in the style of {{name}}.

Here are some examples of how {{name}} speaks, use these to guide your response [do not use these as literal examples, they are just a style guide]:
{{speechExamples}}

Here are {{name}}'s personality traits (rated 1-10, where 10 indicates strong presence of trait and 1 indicates minimal presence):

Traits that drive behavior and decision-making:
- Aggression: {{aggression}} (High = confrontational, quick to challenge others, assertive, competitive | Low = peaceful, avoids conflict, gentle, accommodating)
- Agreeability: {{agreeability}} (High = cooperative, helpful, compassionate, team-oriented | Low = competitive, self-focused, skeptical of others' motives)
- Openness: {{openness}} (High = curious, creative, enjoys novelty, intellectually exploratory | Low = conventional, practical, prefers routine and familiarity)
- Conscientiousness: {{conscientiousness}} (High = organized, responsible, detail-oriented, plans ahead | Low = spontaneous, flexible, sometimes careless or impulsive)
- Extraversion: {{extraversion}} (High = outgoing, energized by social interaction, talkative, attention-seeking | Low = reserved, prefers solitude, quiet, internally focused)
- Neuroticism: {{neuroticism}} (High = sensitive to stress, prone to worry/anxiety, emotionally reactive | Low = emotionally stable, calm under pressure, resilient)
- Empathy: {{empathy}} (High = understanding of others' emotions, compassionate, good listener | Low = detached, difficulty relating to others' feelings, logical over emotional)
- Confidence: {{confidence}} (High = self-assured, decisive, believes in own abilities | Low = hesitant, self-doubting, seeks validation from others)
- Adaptability: {{adaptability}} (High = flexible in new situations, embraces change, quick to adjust | Low = rigid, resistant to change, needs structure and routine)
- Impulsivity: {{impulsivity}} (High = acts on instinct, spontaneous decisions, thrill-seeking | Low = deliberate, carefully considers consequences, methodical)

These traits combine to create a unique personality profile that influences how {{name}} approaches problems, interacts with others, and makes decisions. The relative strength of each trait shapes their behavioral patterns and emotional responses.`;

type GoalMemory = {
  goal: string;
  tasks: string[];
  currentTask: string;
};

const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
  }),

  key({ id }) {
    return id;
  },

  create() {
    return {
      name: character.name,
      speechExamples: character.speechExamples,
      // traits: JSON.stringify(character.traits),
      aggression: character.traits.aggression,
      agreeability: character.traits.agreeability,
      openness: character.traits.openness,
      conscientiousness: character.traits.conscientiousness,
      extraversion: character.traits.extraversion,
      neuroticism: character.traits.neuroticism,
      empathy: character.traits.empathy,
      confidence: character.traits.confidence,
      adaptability: character.traits.adaptability,
      impulsivity: character.traits.impulsivity,
    };
  },

  render() {
    return render(template, {
      name: character.name,
      speechExamples: character.speechExamples,
      // traits: character.traits,
      aggression: character.traits.aggression.toString(),
      agreeability: character.traits.agreeability.toString(),
      openness: character.traits.openness.toString(),
      conscientiousness: character.traits.conscientiousness.toString(),
      extraversion: character.traits.extraversion.toString(),
      neuroticism: character.traits.neuroticism.toString(),
      empathy: character.traits.empathy.toString(),
      confidence: character.traits.confidence.toString(),
      adaptability: character.traits.adaptability.toString(),
      impulsivity: character.traits.impulsivity.toString(),
    });
  },
});

createDreams({
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension],
  context: goalContexts,
  actions: [
    action({
      name: "addTask",
      description: "Add a task to the goal",
      schema: z.object({ task: z.string() }),
      handler(data, ctx, _agent) {
        const agentMemory = ctx.agentMemory as GoalMemory;
        agentMemory.tasks.push(data.task);
        return {};
      },
    }),
    action({
      name: "completeTask",
      description: "Complete a task",
      schema: z.object({ task: z.string() }),
      handler(data, ctx, _agent) {
        const agentMemory = ctx.agentMemory as GoalMemory;
        agentMemory.tasks = agentMemory.tasks.filter(
          (task) => task !== data.task
        );
        return {};
      },
    }),
  ],
  outputs: {
    test: output({}),
  },
}).start({ id: "test" });

--- End File: examples/basic/example-basic.ts ---

--- File: examples/basic/example-chat-with-code.ts ---
import { z } from "zod";
import {
  createDreams,
  LogLevel,
  action,
  task,
  service,
  validateEnv,
} from "@daydreamsai/core";
import { discord } from "@daydreamsai/discord";
import { Octokit } from "@octokit/rest";
import { openrouter } from "@openrouter/ai-sdk-provider";
import { cliExtension } from "@daydreamsai/cli";

const env = validateEnv(
  z.object({
    OPENROUTER_API_KEY: z.string().min(1, "OPENROUTER_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    GITHUB_TOKEN: z.string().min(1, "GITHUB_TOKEN is required"),
  })
);

const githubService = service({
  register(container) {
    container.singleton(
      "octokit",
      () =>
        new Octokit({
          auth: env.GITHUB_TOKEN,
        })
    );
  },
});

const fetchRepoContent = task(
  "github:fetch-repo-content",
  async ({
    octokit,
    owner,
    repo,
    path,
  }: {
    octokit: Octokit;
    owner: string;
    repo: string;
    path?: string;
  }) => {
    const response = await octokit.repos.getContent({
      owner,
      repo,
      path: path ?? "",
    });

    let contents = "";

    if (Array.isArray(response.data)) {
      for (const item of response.data) {
        if (
          item.type === "file" &&
          item.name.match(/\.(ts|js|tsx|jsx|md|json)$/)
        ) {
          const fileContent = await octokit.repos.getContent({
            owner,
            repo,
            path: item.path,
          });

          if ("content" in fileContent.data) {
            contents += `\n--- ${item.path} ---\n`;
            contents += Buffer.from(
              fileContent.data.content,
              "base64"
            ).toString();
          }
        } else if (item.type === "dir") {
          const subContents = await fetchRepoContent({
            octokit,
            owner,
            repo,
            path: item.path,
          });
          contents += subContents.contents;
        }
      }
    }
    return { contents };
  }
);

const agent = createDreams({
  model: openrouter("google/gemini-2.5-flash-preview"),
  extensions: [discord, cliExtension],
  services: [githubService],
  actions: [
    action({
      name: "fetchGitHubRepo",
      description: "Fetch and analyze contents of a GitHub repository.",
      schema: z.object({
        owner: z.string().describe("The GitHub repository owner"),
        repo: z.string().describe("The repository name"),
        path: z
          .string()
          .optional()
          .describe("Optional specific path within the repository"),
      }),
      async handler(data, ctx, app) {
        const octokit = app.container.resolve<Octokit>("octokit");
        try {
          const contents = await fetchRepoContent({
            octokit,
            ...data,
          });

          return {
            contents,
            repoInfo: {
              owner: data.owner,
              repo: data.repo,
              path: data.path || "",
            },
          };
        } catch (error) {
          console.error("Error fetching repo contents:", error);
          throw new Error(
            `Failed to fetch repository contents: ${
              error instanceof Error ? error.message : error
            }`
          );
        }
      },
    }),
  ],
});

console.log("Starting GitHub Repo Chat Bot...");
await agent.start();

--- End File: examples/basic/example-chat-with-code.ts ---

--- File: examples/basic/example-chat.tsx ---
/**
 * Basic example demonstrating a simple chat interface using Dreams
 * with a command line interface and Groq's LLM.
 */
import { createAnthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { z } from "zod";

const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const anthropic = createAnthropic({
  apiKey: env.ANTHROPIC_API_KEY!,
});

const thread = context({
  type: "thread",
  schema: { threadId: z.string(), user: z.string() },
  key: ({ threadId }) => threadId,
  render({ args }) {
    const date = new Date();
    return `\
User: ${args.user}
Current ISO time is: ${date.toISOString()}, timestamp: ${date.getTime()}`;
  },
  inputs: {
    message: {
      schema: z.string(),
    },
  },
  outputs: {
    message: {
      required: true,
      schema: z.string(),
    },
    "screen:widget:weather": {
      description: "use this to display the latest weather report",
      instructions:
        "always show some weather report if you havent set one yet, try to keep it updated every 5 mins, if no location the user has set use: Lisbon",
      schema: z.string(),
      attributes: { lastUpdated: z.number() },
    },
  },
});

const agent = await createDreams({
  debugger: async (contextId, keys, data) => {
    const [type, id] = keys;
    await Bun.write(`./logs/chat/${contextId}/${id}-${type}.md`, data);
  },
  model: anthropic("claude-3-5-haiku-latest"),
  contexts: [thread],
}).start();

const res = await agent.send({
  context: thread,
  args: { threadId: "test", user: "dreamer" },
  input: {
    type: "message",
    data: "fetch the weather for lisbon, porto, and faro and make me a report in markdown format!",
  },
});

--- End File: examples/basic/example-chat.tsx ---

--- File: examples/basic/example-chroma.ts ---
// This example shows how to use the MongoDB memory store to store and retrieve memories.
// IMPORTANT: You will need to run the docker-compose.yml file in the root of the project to run the MongoDB instance.

import { createGroq } from "@ai-sdk/groq";
import { openai } from "@ai-sdk/openai";
import {
  createContainer,
  createDreams,
  Logger,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createChromaVectorStore } from "@daydreamsai/chromadb";
import { createMongoMemoryStore } from "@daydreamsai/mongodb";
import { z } from "zod";
import { cliExtension } from "@daydreamsai/cli";

const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

const mongo = await createMongoMemoryStore({
  collectionName: "agent",
  uri: "mongodb://localhost:27017",
});
const chroma = createChromaVectorStore("agent", "http://localhost:8000");

const agent = createDreams({
  container: createContainer(),
  logger: new Logger({ level: LogLevel.DEBUG }),
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension],
  memory: {
    store: mongo,
    vector: chroma,
    vectorModel: openai("gpt-4-turbo"),
  },
});

// Start the agent
await agent.start();

--- End File: examples/basic/example-chroma.ts ---

--- File: examples/basic/example-supabase.ts ---
// This example shows how to use Supabase with DaydreamsAI.

// Vector Model Provider: gpt-4-turbo                    via @ai-sdk/openai
// Model Provider:        google/gemini-2.0-flash-001    via @openrouter/ai-sdk-provider
// Memory Store:          @daydreamsai/supabase
// CLI Extension:         @daydreamsai/cli

import { openai } from "@ai-sdk/openai";
import {
  createContainer,
  createDreams,
  Logger,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createSupabaseBaseMemory } from "@daydreamsai/supabase";
import { z } from "zod";
import { cliExtension } from "@daydreamsai/cli";
import { openrouter } from "@openrouter/ai-sdk-provider";

validateEnv(
  z.object({
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    SUPABASE_URL: z.string().min(1, "SUPABASE_URL is required"),
    SUPABASE_SERVICE_KEY: z.string().min(1, "SUPABASE_SERVICE_KEY is required"),
    OPENROUTER_API_KEY: z.string().min(1, "OPENROUTER_API_KEY is required"),
  })
);

const agent = createDreams({
  container: createContainer(),
  logger: new Logger({ level: LogLevel.DEBUG }),
  model: openrouter("google/gemini-2.0-flash-001"),
  extensions: [cliExtension],
  memory: createSupabaseBaseMemory({
    url: process.env.SUPABASE_URL!,
    key: process.env.SUPABASE_SERVICE_KEY!,
    memoryTableName: "agent",
    vectorTableName: "agentVectors",
    vectorModel: openai("gpt-4-turbo"),
  }),
});

// Start the agent
await agent.start();

--- End File: examples/basic/example-supabase.ts ---

--- File: examples/basic/package.json ---
{
  "name": "basic",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.3",
    "@ai-sdk/groq": "^1.2.2",
    "@ai-sdk/openai": "^1.3.5",
    "@ai-sdk/provider": "^1.1.0",
    "@openrouter/ai-sdk-provider": "^0.4.5",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/discord": "workspace:*",
    "@daydreamsai/chromadb": "workspace:*",
    "@daydreamsai/mongodb": "workspace:*",
    "@daydreamsai/supabase": "workspace:*",
    "@octokit/rest": "^21.1.1",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2"
  }
}

--- End File: examples/basic/package.json ---

--- File: examples/chains/example-hyperliquid.ts ---
/**
 * Example demonstrating a comprehensive Hyperliquid trading bot using the Daydreams package.
 * This bot provides full trading capabilities including:
 * - Place limit orders (instant-or-cancel & good-til-cancel)
 * - Place market orders with size or USD amount
 * - Get account balances and positions
 * - Monitor open orders
 * - Cancel existing orders
 * - Market sell positions
 * - Interactive console interface for manual trading
 * - Real-time order status monitoring
 */

import { createGroq } from "@ai-sdk/groq";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { z } from "zod";
import chalk from "chalk";
import { HyperliquidClient } from "@daydreamsai/hyperliquid";

// Validate environment variables
const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    HYPERLIQUID_MAIN_ADDRESS: z
      .string()
      .min(1, "HYPERLIQUID_MAIN_ADDRESS is required"),
    HYPERLIQUID_WALLET_ADDRESS: z
      .string()
      .min(1, "HYPERLIQUID_WALLET_ADDRESS is required"),
    HYPERLIQUID_PRIVATE_KEY: z
      .string()
      .min(1, "HYPERLIQUID_PRIVATE_KEY is required"),
  })
);

// Initialize Groq client
const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

// Initialize Hyperliquid Client
const hyperliquid = new HyperliquidClient({
  mainAddress: env.HYPERLIQUID_MAIN_ADDRESS,
  walletAddress: env.HYPERLIQUID_WALLET_ADDRESS,
  privateKey: env.HYPERLIQUID_PRIVATE_KEY,
});

// Define memory type
type HyperliquidMemory = {
  transactions: string[];
  lastTransaction: string | null;
};

// Define context template
const template = `
Last Transaction: {{lastTransaction}}
Transaction History:
{{transactions}}
`;

// Create context
const hyperliquidContexts = context({
  type: "hyperliquid",
  schema: {
    id: z.string(),
  },

  key({ id }) {
    return id;
  },

  create(): HyperliquidMemory {
    return {
      transactions: [],
      lastTransaction: null,
    };
  },

  render({ memory }) {
    return render(template, {
      lastTransaction: memory.lastTransaction ?? "NONE",
      transactions: memory.transactions.join("\n"),
    });
  },
}).setActions([
  action({
    name: "hyperliquid.place_limit_order_ioc",
    description: "Place an instant-or-cancel limit order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      sz: z.number().describe("Size of the order"),
      limit_px: z.number().describe("Limit price for the order"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, sz, limit_px, is_buy }, { memory }) {
      const result = await hyperliquid.placeLimitOrderInstantOrCancel(
        ticker,
        sz,
        limit_px,
        is_buy
      );

      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `IOC Order: ${is_buy ? "Buy" : "Sell"} ${sz}x${ticker} @ ${limit_px}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.place_limit_order_gtc",
    description: "Place a good-til-cancel limit order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      sz: z.number().describe("Size of the order"),
      limit_px: z.number().describe("Limit price for the order"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, sz, limit_px, is_buy }, { memory }) {
      const result = await hyperliquid.placeLimitOrderGoodTilCancel(
        ticker,
        sz,
        limit_px,
        is_buy
      );

      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `GTC Order: ${is_buy ? "Buy" : "Sell"} ${sz}x${ticker} @ ${limit_px}`;
      memory.transactions.push(memory.lastTransaction);
      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.market_order",
    description: "Place a market order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      sz: z.number().describe("Size of the order"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, sz, is_buy }, { memory }) {
      const result = await hyperliquid.placeMarketOrder(ticker, sz, is_buy);

      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `Market Order: ${is_buy ? "Buy" : "Sell"} ${sz}x${ticker}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.market_order_usd",
    description: "Place a market order with USD amount on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      usdtotalprice: z.number().describe("Total USD amount to trade"),
      is_buy: z.boolean().describe("Whether this is a buy order"),
    },
    async handler({ ticker, usdtotalprice, is_buy }, ctx) {
      const result = await hyperliquid.placeMarketOrderUSD(
        ticker,
        usdtotalprice,
        is_buy
      );

      const resultStr = JSON.stringify(result, null, 2);
      ctx.memory.lastTransaction = `Market Order USD: ${is_buy ? "Buy" : "Sell"} ${ticker} for $${usdtotalprice}`;
      ctx.memory.transactions.push(ctx.memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.get_balances",
    description: "Get account balances and positions from Hyperliquid",
    schema: undefined,
    async handler(ctx) {
      const result = await hyperliquid.getAccountBalancesAndPositions();
      const resultStr = JSON.stringify(result, null, 2);
      ctx.memory.lastTransaction = "Checked balances and positions";
      ctx.memory.transactions.push(ctx.memory.lastTransaction);
      return { content: `Balances: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.get_open_orders",
    description: "Get open orders from Hyperliquid",
    schema: undefined,
    async handler({ memory }) {
      const result = await hyperliquid.getOpenOrders();
      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = "Checked open orders";
      memory.transactions.push(memory.lastTransaction);
      return { content: `Open Orders: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.cancel_order",
    description: "Cancel an order on Hyperliquid",
    schema: {
      ticker: z
        .string()
        .describe(
          "Ticker must be only the letter of the ticker in uppercase without the -PERP or -SPOT suffix"
        ),
      orderId: z.number().describe("ID of the order to cancel"),
    },
    async handler({ ticker, orderId }, { memory }) {
      const result = await hyperliquid.cancelOrder(ticker, orderId);
      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `Cancelled order ${orderId} for ${ticker}`;
      memory.transactions.push(memory.lastTransaction);
      return { content: `Cancel Result: ${resultStr}` };
    },
  }),

  action({
    name: "hyperliquid.market_sell_positions",
    description: "Market sell positions on Hyperliquid",
    schema: z.object({
      tickers: z
        .array(z.string())
        .describe("Array of tickers to sell positions for"),
    }),
    async handler({ tickers }, { memory }) {
      const result = await hyperliquid.marketSellPositions(tickers);
      const resultStr = JSON.stringify(result, null, 2);
      memory.lastTransaction = `Market sold positions for ${tickers.join(", ")}`;
      memory.transactions.push(memory.lastTransaction);
      return { content: `Market Sell Result: ${resultStr}` };
    },
  }),
]);

// Create Dreams instance
const dreams = createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension],
  context: hyperliquidContexts,
});

// Start the Dreams instance
dreams.start({ id: "hyperliquid-example" });

// Handle graceful shutdown
process.on("SIGINT", async () => {
  console.log(chalk.yellow("\n\nShutting down..."));
  console.log(chalk.green("✅ Shutdown complete"));
  process.exit(0);
});

--- End File: examples/chains/example-hyperliquid.ts ---

--- File: examples/chains/example-sui.ts ---
/**
 * Example demonstrating Sui interactions using the Daydreams package,
 */

import { createGroq } from "@ai-sdk/groq";
import { createDreams, context, action, validateEnv } from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { z } from "zod";
import chalk from "chalk";
import { SuiChain, supportedSuiTokens } from "@daydreamsai/defai";
import type { FaucetNetwork, SuiNetwork } from "@daydreamsai/defai";

// Validate environment variables
const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
    SUI_NETWORK: z.string().min(1, "SUI_NETWORK is required"),
    SUI_PRIVATE_KEY: z.string().min(1, "SUI_PRIVATE_KEY is required"),
  })
);

// Initialize Groq client
const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

// Initialize Sui Chain
const suiChain = new SuiChain({
  network: env.SUI_NETWORK as SuiNetwork,
  privateKey: env.SUI_PRIVATE_KEY,
});

// Define memory type
type SuiMemory = {
  wallet: string;
  transactions: string[];
  lastTransaction: string | null;
};

// Define context template
const template = ({ wallet, lastTransaction, transactions }: SuiMemory) => `\
Wallet: ${wallet}
Last Transaction: ${lastTransaction ?? "NONE"}
Transaction History:
${transactions.join("\n")}`;

// Create context
const suiContexts = context({
  type: "sui",
  schema: {
    wallet: z.string(),
  },
  key: ({ wallet }) => wallet,
  create({ args }): SuiMemory {
    return {
      wallet: args.wallet,
      transactions: [],
      lastTransaction: null,
    };
  },
  render({ memory }) {
    return template(memory);
  },
}).setActions([
  action({
    name: "sui.faucet",
    description: "Request SUI tokens from a faucet",
    schema: {
      network: z
        .enum(["testnet", "devnet", "localnet"])
        .default("testnet")
        .describe("The network to request SUI from."),
      recipient: z.string().describe("The account address to receive SUI"),
    },
    async handler({ network, recipient }, { memory }) {
      const result = await suiChain.requestSui({
        network: network as FaucetNetwork,
        recipient,
      });

      const resultStr = JSON.stringify(result, null, 2);

      memory.lastTransaction = `Faucet Request: ${resultStr}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),
  action({
    name: "sui.swap",
    description: "Swap tokens on the Sui blockchain",
    schema: {
      fromToken: z
        .string()
        .describe(
          `The token name to be swapped. It can be one of these: ${supportedSuiTokens}. This token and target token should not be same.`
        ),
      targetToken: z
        .string()
        .describe(
          `The token name to be swapped. It can be one of these: ${supportedSuiTokens}. This token and from token should not be same.`
        ),
      amount: z
        .string()
        .describe(
          "The amount of token to be swapped. It should be in MIST. 1 SUI = 10^9 MIST. User mostly doesn't provide the value in mist, if he does, use that. Or else, do the conversation of multiplication and provide the value. However, for the case of USDC, the amount should be provided by multiplying 10^6. If a user says 1 USDC, amount you should add is 10^6. Take note of the amount of the from token."
        ),
      out_min_amount: z
        .number()
        .optional()
        .describe(
          "This is the minimum expected output token amount. If not provided should be null and will execute the swap anyhow."
        ),
    },
    async handler(
      { fromToken, amount, out_min_amount, targetToken },
      { memory }
    ) {
      const result = await suiChain.swapToken({
        fromToken,
        amount,
        out_min_amount: out_min_amount || null,
        targetToken,
      });

      const resultStr = JSON.stringify(result, null, 2);

      memory.lastTransaction = `Swap: ${fromToken} to ${targetToken}, Amount: ${amount}, Result: ${resultStr}`;
      memory.transactions.push(memory.lastTransaction);

      return { content: `Transaction: ${resultStr}` };
    },
  }),
]);

// Create Dreams instance
const dreams = createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension],
  context: suiContexts,
});

// Start the Dreams instance
await dreams.start({ wallet: suiChain.getAddress() });

// Handle graceful shutdown
process.on("SIGINT", async () => {
  console.log(chalk.yellow("\n\nShutting down..."));
  console.log(chalk.green("✅ Shutdown complete"));
  process.exit(0);
});

--- End File: examples/chains/example-sui.ts ---

--- File: examples/chains/package.json ---
{
  "name": "chains",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.14",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/defai": "workspace:*",
    "@daydreamsai/hyperliquid": "workspace:*",
    "@tavily/core": "^0.3.1",
    "discord.js": "^14.18.0",
    "hyperliquid": "^1.6.2",
    "zod": "^3.24.2",
    "chalk": "^5.4.1"
  }
}

--- End File: examples/chains/package.json ---

--- File: examples/composio/composio.ts ---
import OpenAI from "openai/index.mjs";
import { OpenAIToolSet } from "composio-core";
import { action, extension } from "@daydreamsai/core";
import { z } from "zod";

const openai_client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const composio_toolset = new OpenAIToolSet({
  apiKey: process.env.COMPOSIO_API_KEY,
});

interface ActionParameter {
  name: string;
  type: string;
  default?: any;
  required: boolean;
}

interface SimplifiedAction {
  name: string;
  displayName: string;
  description: string;
  parameters: ActionParameter[];
}

const COMPOSIO_APPNAMES = [
  "notion",
  "tinypng",
  "twitch",
  "github",
  "linkedin",
  "stripe",
  "airtable",
  "epic_games",
  "youtube",
  "googledocs",
  "trello",
  "docusign",
  "discordbot",
  "google_maps",
  "discord",
  "webflow",
  "open_sea",
  "facebook",
  "figma",
  "cal",
  "eventbrite",
  "todoist",
  "canva",
  "twitter_media",
  "googletasks",
  "heygen",
  "datarobot",
  "humanloop",
  "googlecalendar",
  "hackernews",
  "gmail",
  "googlephotos",
  "one_drive",
  "twitter",
  "mailchimp",
  "perplexityai",
  "googlesheets",
  "supabase",
  "elevenlabs",
  "miro",
  "slack",
  "hubspot",
];

async function makeOpenAIRequest(content: string, tools: any[]) {
  try {
    const response = await openai_client.chat.completions.create({
      model: "gpt-4-turbo",
      messages: [{ role: "user", content }],
      tools,
      tool_choice: "auto",
    });
    return response;
  } catch (error) {
    console.error("OpenAI API call failed:", error);
    throw new Error("Failed to process request");
  }
}

// We simplify the actions to reduce the number of tokens in the response
// This is necessary because the raw response can be very verbose and hit daydreams' model token limits
function simplifyActions(data: any): SimplifiedAction[] {
  if (!data?.data?.actions) {
    return [];
  }

  return data.data.actions.map((action: any) => ({
    name: action.name,
    displayName: action.display_name,
    description: action.description,
    parameters: Object.entries(action.parameters.properties).map(
      ([key, value]: [string, any]): ActionParameter => ({
        name: key,
        type: value.type,
        default: value.default,
        required: action.parameters.required?.includes(key) ?? false,
      })
    ),
  }));
}

export const composio = extension({
  name: "composio",
  services: [],
  inputs: {},
  outputs: {},
  actions: [
    action({
      name: "composio.getTodaysDate",
      description:
        "Get the current date and hour. You must call that whenever there is a mention to today or tomorrow or any kind of temporal position based on today's date.",
      schema: undefined,
      handler() {
        const date = new Date();
        const formattedDate = date.toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
        });
        return formattedDate;
      },
    }),
    action({
      name: "composio.checkActiveConnection",
      description: "Check if there's an active connection for a specific tool",
      schema: {
        tool: z
          .enum(COMPOSIO_APPNAMES as [string, ...string[]])
          .describe("The tool name to initiate connection for."),
      },
      async handler({ tool }) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_CHECK_ACTIVE_CONNECTION"],
        });

        const response = await makeOpenAIRequest(
          `Check connection for ${tool}`,
          tools
        );
        const tool_response = await composio_toolset.handleToolCall(response);
        return tool_response;
      },
    }),
    action({
      name: "composio.initiateConnection",
      description: "Initiate a connection for a specific tool",
      schema: z.object({
        tool: z
          .enum(COMPOSIO_APPNAMES as [string, ...string[]])
          .describe("The tool name to initiate connection for."),
      }),
      async handler({ tool }) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_INITIATE_CONNECTION"],
        });

        const response = await makeOpenAIRequest(
          `Initiate connection for ${tool}`,
          tools
        );
        const tool_response = await composio_toolset.handleToolCall(response);
        return tool_response;
      },
    }),

    action({
      name: "composio.retrieveActions",
      description:
        "Retrieve available actions for a specific app. Mandatory to call before doing an action for the first time to get the exact name of action_name for executeAction. Also you will find the required parameters",
      schema: z.object({
        app_name: z
          .enum(COMPOSIO_APPNAMES as [string, ...string[]])
          .describe("The tool name to initiate connection for."),
        usecase: z.string().describe("Explanation of the action"),
        limit: z.number().default(1).describe("Number of actions to retrieve"),
      }),
      async handler({ app_name, usecase, limit }) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_RETRIEVE_ACTIONS"],
        });

        const response = await makeOpenAIRequest(
          `Retrieve actions for ${app_name} with usecase: ${usecase}`,
          tools
        );
        const tool_response = simplifyActions(
          JSON.parse(
            (await composio_toolset.handleToolCall(response)).toString()
          )
        );
        return tool_response;
      },
    }),
    action({
      name: "composio.executeAction",
      description:
        "Execute a specific Composio action with provided parameters. You must always call retrieveActions to get the exact name of the action_name else it will break.",
      schema: {
        action_name: z
          .string()
          .describe(
            "Name of the action to execute (e.g., 'GMAIL_SEND_EMAIL'). Must be exactly one of the action name returned by retrieveActions"
          ),
        request: z
          .record(z.any())
          .describe(
            "Request data parameters as defined in the action's schema"
          ),
      },
      async handler(data) {
        const tools = await composio_toolset.getTools({
          actions: ["COMPOSIO_EXECUTE_ACTION"],
        });

        // Create a structured message that includes both the action name and its parameters
        const executionMessage = {
          action: data.action_name,
          parameters: data.request,
        };

        const response = await makeOpenAIRequest(
          `Execute action ${data.action_name} with parameters: ${JSON.stringify(executionMessage)}`,
          tools
        );
        const tool_response = await composio_toolset.handleToolCall(response);
        return tool_response;
      },
    }),
  ],
});

--- End File: examples/composio/composio.ts ---

--- File: examples/composio/index.ts ---
/**
 * Basic example demonstrating a simple chat interface using Dreams
 * with a command line interface and Groq's LLM.
 */
import { createGroq } from "@ai-sdk/groq";
import { LogLevel } from "@daydreamsai/core";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";
import { composio } from "./composio";

const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

// Initialize Groq client
const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

const template = `
Goal: {{goal}}
Tasks: {{tasks}}
Current Task: {{currentTask}}
`;

type GoalMemory = {
  goal: string;
  tasks: string[];
  currentTask: string;
};

const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
    });
  },
});

createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [cliExtension, composio],
  logger: LogLevel.ERROR,
  context: goalContexts,
}).start({ id: "test", initialGoal: "", initialTasks: [] });

--- End File: examples/composio/index.ts ---

--- File: examples/composio/package.json ---
{
  "name": "composio",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "@octokit/rest": "^21.1.1",
    "@tavily/core": "^0.3.1",
    "discord.js": "^14.18.0",
    "hyperliquid": "^1.6.2",
    "zod": "^3.24.2",
    "composio-core": "^0.5.18"
  }
}

--- End File: examples/composio/package.json ---

--- File: examples/deep-research/index.ts ---
import { createContainer, createDreams, LogLevel } from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { deepResearch } from "./research";
import { tavily } from "@tavily/core";
import { anthropic } from "@ai-sdk/anthropic";
const container = createContainer();

container.singleton("tavily", () =>
  tavily({
    apiKey: process.env.TAVILY_API_KEY!,
  })
);

createDreams({
  logger: LogLevel.DEBUG,
  model: anthropic("claude-3-7-sonnet-latest"),
  debugger: async (contextId, keys, data) => {
    const [type, id] = keys;
    await Bun.write(`./logs/${contextId}/${id}-${type}.md`, data);
  },
  extensions: [cliExtension, deepResearch],
  container,
}).start();

--- End File: examples/deep-research/index.ts ---

--- File: examples/deep-research/package.json ---
{
  "name": "deep-research",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "ai": "4.2.5",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "zod-to-json-schema": "^3.24.3",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2",
    "uuid": "^11.1.0"
  }
}

--- End File: examples/deep-research/package.json ---

--- File: examples/deep-research/prompts.ts ---
import { createParser, createPrompt, formatXml } from "@daydreamsai/core";
import { z } from "zod";
import zodToJsonSchema from "zod-to-json-schema";
import { type Research } from "./research";
import { type TavilySearchResponse } from "@tavily/core";
import { type SearchResultSchema, searchResultsSchema } from "./schemas";

export function formatResearch(research: Research) {
  return formatXml({
    tag: "research",
    params: { id: research.id },
    children: JSON.stringify(research),
  });
}

export const searchResultsPrompt = createPrompt(
  `Given the following results from a SERP search for the query, generate a list of learnings from the results. 
Return a maximum of 5 learnings, but feel free to return less if the results are clear. 
Make sure each learning is unique and not similar to each other. 
The learnings should be concise and to the point, as detailed and information dense as possible. 
Make sure to include any entities like people, places, companies, products, things, etc in the learnings, as well as any exact metrics, numbers, or dates. 
The learnings will be used to research the topic further.
Given the following query and results from the research, create some follow up queries to clarify the research direction. 
Return a maximum of 2 queries, but feel free to return less if the original query is clearer

{{research}}

<query>{{query}}</query>

<goal>{{goal}}</goal>

<results>
{{results}}
</results>

Here is the json schema:
{{schema}}

Here's how you structure your output:
<json>
[JSON DATA]
</json>

Example:
<json>
{
  learnings: [...],
  followUpQueries: [...],
}
</json>
`,
  ({
    schema,
    research,
    results,
    goal,
    query,
  }: {
    goal: string;
    query: string;
    results: TavilySearchResponse["results"];
    research: Research;
    schema: z.AnyZodObject;
  }) => ({
    goal,
    query,
    results: results.map((r) =>
      formatXml({
        tag: "result",
        params: { url: r.url },
        children: r.content,
      })
    ),
    schema: JSON.stringify(zodToJsonSchema(schema, "schema")),
    research: formatResearch(research),
  })
);

export const searchResultsParser = createParser<
  { think?: string; output: SearchResultSchema | null },
  {}
>(
  () => ({
    output: null,
  }),
  {
    think: (state, element) => {
      state.think = element.content;
    },
    json: (state, element) => {
      state.output = searchResultsSchema.parse(JSON.parse(element.content));
    },
  }
);

export const finalReportPrompt = createPrompt(
  `
Given the following research, write a comprehensive final report on the topic using the learnings from research. 

# Report Requirements:
1. Create a well-structured report with clear sections including:
   - Executive Summary (brief overview of key findings)
   - Introduction (context and background)
   - Main Findings (organized by themes or subtopics)
   - Analysis and Implications
   - Conclusion
   - References (properly cite all sources)

2. Include ALL the learnings from the research, organized logically by theme or subtopic.
3. Add proper citations and references to original sources where available.
4. Use data visualization descriptions where appropriate (charts, graphs, tables).
5. Make the report detailed and comprehensive, aiming for 3+ pages of content.
6. Use clear headings and subheadings to organize information.
7. Include a table of contents at the beginning.

Here is all the data from research:
{{research}}

Return your report in markdown format. Always send the full report, do not cut it off.
`,
  ({ research }: { research: Research }) => ({
    research: formatResearch(research),
  })
);

--- End File: examples/deep-research/prompts.ts ---

--- File: examples/deep-research/research.ts ---
import { type TavilyClient } from "@tavily/core";
import { generateText, type LanguageModelV1 } from "ai";
import {
  finalReportPrompt,
  searchResultsParser,
  searchResultsPrompt,
} from "./prompts";
import { researchSchema, searchResultsSchema } from "./schemas";
import {
  action,
  task,
  memory,
  extension,
  type Debugger,
} from "@daydreamsai/core";
import { v7 as randomUUUIDv7 } from "uuid";
import { z } from "zod";

export type Research = {
  id: string;
  name: string;
  queries: {
    query: string;
    goal: string;
  }[];
  questions: string[];
  learnings: string[];
  status: "in_progress" | "done" | "cancelled";
  metadata: {
    createdAt: number;
    updatedAt: number;
    completedAt?: number;
    cancelledAt?: number;
    totalQueries: number;
    totalLearnings: number;
    depth: number;
    creator?: string;
  };
};

export type ResearchProgress = {
  currentDepth: number;
  totalDepth: number;
  currentQuery?: string;
  totalQueries: number;
  completedQueries: number;
};

type SearchQueryParams = {
  model: LanguageModelV1;
  contextId: string;
  research: Research;
  tavilyClient: TavilyClient;
  query: Research["queries"][number];
};

const researchQueryTask = task(
  "deep-research:query",
  async (
    { model, contextId, tavilyClient, research, query }: SearchQueryParams,
    { callId, debug }
  ) => {
    try {
      // Track domains we've already seen to ensure diversity
      const seenDomains = new Set<string>();
      research.learnings.forEach((learning) => {
        if (learning.startsWith("Source:")) {
          const domainMatch = learning.match(/Source: ([^/]+)/);
          if (domainMatch && domainMatch[1]) {
            seenDomains.add(domainMatch[1]);
          }
        }
      });

      // Enhanced search with better parameters
      const { results } = await tavilyClient.search(query.query, {
        maxResults: 8, // Increased from 5 to get more diverse sources
        searchDepth: "advanced",
        includeImages: false,
        includeAnswer: true,
        includeDomains: [], // Could be configured to target specific domains
        excludeDomains: Array.from(seenDomains), // Avoid domains we've already seen
      });

      // Filter results to ensure quality and diversity
      const filteredResults = results
        // Remove very short content
        .filter((result) => result.content.length > 100)
        // Prioritize results with titles
        .sort((a, b) => (b.title?.length || 0) - (a.title?.length || 0))
        // Take top 5
        .slice(0, 5);

      debug(
        contextId,
        ["research-query-results-data", callId],
        JSON.stringify(
          {
            research,
            goal: query.goal,
            query: query.query,
            results: filteredResults,
          },
          null,
          2
        )
      );

      const system = searchResultsPrompt({
        research,
        goal: query.goal,
        query: query.query,
        results: filteredResults,
        schema: searchResultsSchema,
      });

      debug(contextId, ["research-query-results-prompt", callId], system);

      const res = await generateText({
        model,
        abortSignal: AbortSignal.timeout(60_000),
        system,
        messages: [
          {
            role: "assistant",
            content: "<think>",
          },
        ],
      });

      const text = "<think>" + res.text;

      debug(contextId, ["research-query-results-response", callId], text);

      try {
        const { think, output } = searchResultsParser(text);
        if (output) {
          return {
            think,
            learnings: output.learnings,
            followUpQueries: output.followUpQueries,
          };
        } else {
          throw new Error("Failed to parse search results output");
        }
      } catch (parseError) {
        debug(
          contextId,
          ["research-query-results-parse-error", callId],
          String(parseError)
        );

        // Fallback to a simplified response when parsing fails
        return {
          think: "Parsing error occurred",
          learnings: [
            {
              content: `Failed to parse results for query: ${query.query}. Please review the search manually.`,
              references: [],
            },
          ],
          followUpQueries: [],
        };
      }
    } catch (searchError) {
      debug(
        contextId,
        ["research-query-search-error", callId],
        String(searchError)
      );

      // Return a graceful failure that allows the research to continue
      return {
        think: "Search error occurred",
        learnings: [
          {
            content: `Error occurred while researching: ${query.query}. ${searchError instanceof Error ? searchError.message : String(searchError)}`,
            references: [],
          },
        ],
        followUpQueries: [],
      };
    }
  }
);

const generateResearchReport = task(
  "deep-research:generate-report",
  async (
    {
      model,
      contextId,
      research,
    }: { model: LanguageModelV1; contextId: string; research: Research },
    { callId, debug }
  ) => {
    const reportPrompt = finalReportPrompt({ research });

    debug(
      contextId,
      ["research-report-data", callId],
      JSON.stringify(research, null, 2)
    );

    debug(contextId, ["research-report-prompt", callId], reportPrompt);

    const res = await generateText({
      model,
      system: reportPrompt,
      messages: [
        {
          role: "assistant",
          content: "<think>",
        },
      ],
    });

    debug(
      contextId,
      ["research-report-response", callId],
      "<think>" + res.text
    );

    const report = res.text.slice(res.text.lastIndexOf("</think>"));
    return report;
  }
);

export async function startDeepResearch({
  contextId,
  model,
  research,
  tavilyClient,
  maxDepth,
  onProgress,
  debug,
}: {
  contextId: string;
  model: LanguageModelV1;
  research: Research;
  tavilyClient: TavilyClient;
  maxDepth: number;
  onProgress?: (progress: ResearchProgress) => void;
  debug: Debugger;
}) {
  debug(contextId, ["deep-research-start"], "Starting deep research");

  let queries = research.queries.slice();
  let depth = 1;

  const progress: ResearchProgress = {
    currentDepth: depth,
    totalDepth: maxDepth,
    totalQueries: queries.length,
    completedQueries: 0,
  };

  const reportProgress = (update: Partial<ResearchProgress>) => {
    Object.assign(progress, update);
    onProgress?.(progress);
  };

  console.log("=======STARTING-DEEP-RESEARCH=======");

  while (queries.length > 0 && depth <= maxDepth) {
    const _queries = queries.slice();
    queries = [];

    reportProgress({
      currentDepth: depth,
      totalQueries: progress.totalQueries,
    });

    // Process queries in parallel but track progress for each
    const results = await Promise.all(
      _queries.map(async (query, index) => {
        reportProgress({
          currentQuery: query.query,
        });

        const result = await researchQueryTask(
          {
            contextId,
            model,
            query,
            research,
            tavilyClient,
          },
          { debug }
        );

        // Update progress after each query completes
        reportProgress({
          completedQueries: progress.completedQueries + 1,
        });

        return result;
      })
    );

    // Process results to extract follow-up queries
    results.forEach((result) => {
      if (result && result.followUpQueries) {
        queries.push(...result.followUpQueries);
      }

      if (result && result.learnings) {
        // Add learnings to the research object
        research.learnings.push(
          ...result.learnings.map((learning) => learning.content)
        );
      }
    });

    depth++;

    reportProgress({
      totalQueries: progress.totalQueries + queries.length,
    });
  }

  const report = await generateResearchReport(
    {
      contextId,
      model,
      research,
    },
    { debug }
  );

  debug(contextId, ["deep-research-complete"], "Research completed");
  return report;
}

type ResearchMemory = {
  researches: Research[];
  activeResearchIds: Set<string>;
};

const researchMemory = memory<ResearchMemory>({
  key: "research",
  create() {
    return {
      researches: [],
      activeResearchIds: new Set(),
    };
  },
});

const startDeepResearchAction = action({
  name: "start-deep-research",
  schema: researchSchema,
  memory: researchMemory,
  async handler(call, ctx, agent) {
    const now = Date.now();
    const research: Research = {
      ...call.data,
      learnings: [],
      status: "in_progress",
      metadata: {
        createdAt: now,
        updatedAt: now,
        totalQueries: call.data.queries.length,
        totalLearnings: 0,
        depth: 0,
        creator: ctx.id,
      },
    };

    ctx.actionMemory.researches.push(research);
    ctx.actionMemory.activeResearchIds.add(research.id);

    startDeepResearch({
      model: agent.reasoningModel ?? agent.model,
      research,
      tavilyClient: agent.container.resolve("tavily"),
      maxDepth: call.data.maxDepth ?? 2,
      contextId: ctx.id,
      debug: agent.debugger,
      onProgress: (progress) => {
        // Update metadata as research progresses
        research.metadata.updatedAt = Date.now();
        research.metadata.totalQueries = progress.totalQueries;
        research.metadata.totalLearnings = research.learnings.length;
        research.metadata.depth = progress.currentDepth;
      },
    })
      .then((res) => {
        ctx.workingMemory.results.push({
          ref: "action_result",
          id: randomUUUIDv7(),
          callId: call.id,
          data: res,
          name: call.name,
          timestamp: Date.now(),
          processed: false,
        });

        research.status = "done";
        research.metadata.completedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);

        return agent.run({
          context: ctx.context,
          args: ctx.args,
        });
      })
      .catch((err) => {
        agent.debugger(ctx.id, ["deep-research-error"], String(err));
        research.status = "done";
        research.metadata.completedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);
      });

    return "Research created!";
  },
});

const cancelResearchAction = action({
  name: "cancel-deep-research",
  schema: z.object({
    id: z.string().describe("ID of the research to cancel"),
  }),
  memory: researchMemory,
  enabled: (ctx) =>
    ctx.actionMemory.researches.some((r) => r.status === "in_progress"),
  async handler(params, ctx) {
    const { id } = params;
    const research = ctx.actionMemory.researches.find((r) => r.id === id);

    if (!research) {
      return `Research with ID ${id} not found.`;
    }

    if (research.status !== "in_progress") {
      return `Research with ID ${id} is not in progress (current status: ${research.status}).`;
    }

    research.status = "cancelled";
    research.metadata.cancelledAt = Date.now();
    research.metadata.updatedAt = Date.now();
    ctx.actionMemory.activeResearchIds.delete(research.id);

    return `Research "${research.name}" (ID: ${id}) has been cancelled.`;
  },
});

const listResearchesAction = action({
  name: "list-researches",
  schema: z.object({}),
  memory: researchMemory,
  enabled: (ctx) => ctx.actionMemory.researches.length > 0,
  async handler(params, ctx) {
    const researches = ctx.actionMemory.researches.map((r) => ({
      id: r.id,
      name: r.name,
      status: r.status,
      queriesCount: r.queries.length,
      learningsCount: r.learnings.length,
    }));

    return JSON.stringify(researches, null, 2);
  },
});

const resumeResearchAction = action({
  name: "resume-research",
  schema: z.object({
    id: z.string().describe("ID of the research to resume"),
    maxDepth: z
      .number()
      .default(2)
      .optional()
      .describe("Max depth of the research"),
  }),
  memory: researchMemory,
  enabled: (ctx) =>
    ctx.actionMemory.researches.some(
      (r) => r.status === "cancelled" || r.status === "done"
    ),
  async handler(call, ctx, agent) {
    const { id, maxDepth } = call.data;
    const research = ctx.actionMemory.researches.find((r) => r.id === id);

    if (!research) {
      return `Research with ID ${id} not found.`;
    }

    if (research.status === "in_progress") {
      return `Research with ID ${id} is already in progress.`;
    }

    // Reset the research status and update metadata
    research.status = "in_progress";
    research.metadata.updatedAt = Date.now();
    // Clear completion or cancellation timestamps
    delete research.metadata.completedAt;
    delete research.metadata.cancelledAt;

    ctx.actionMemory.activeResearchIds.add(research.id);

    startDeepResearch({
      model: agent.reasoningModel ?? agent.model,
      research,
      tavilyClient: agent.container.resolve("tavily"),
      maxDepth: maxDepth ?? 2,
      contextId: ctx.id,
      debug: agent.debugger,
      onProgress: (progress) => {
        // Update metadata as research progresses
        research.metadata.updatedAt = Date.now();
        research.metadata.totalQueries = progress.totalQueries;
        research.metadata.totalLearnings = research.learnings.length;
        research.metadata.depth = progress.currentDepth;
      },
    })
      .then((res) => {
        ctx.workingMemory.results.push({
          ref: "action_result",
          id: randomUUUIDv7(),
          callId: call.id,
          data: res,
          name: call.name,
          timestamp: Date.now(),
          processed: false,
        });

        research.status = "done";
        research.metadata.completedAt = Date.now();
        research.metadata.updatedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);

        return agent.run({
          context: ctx.context,
          args: ctx.args,
        });
      })
      .catch((err) => {
        agent.debugger(ctx.id, ["deep-research-error"], String(err));
        research.status = "done";
        research.metadata.completedAt = Date.now();
        research.metadata.updatedAt = Date.now();
        ctx.actionMemory.activeResearchIds.delete(research.id);
      });

    return `Resuming research "${research.name}" (ID: ${id}).`;
  },
});

export const deepResearch = extension({
  name: "deep-research",
  actions: [
    startDeepResearchAction,
    cancelResearchAction,
    listResearchesAction,
    resumeResearchAction,
  ],
});

--- End File: examples/deep-research/research.ts ---

--- File: examples/deep-research/schemas.ts ---
import { z } from "zod";

export const searchResultsSchema = z.object({
  learnings: z
    .array(
      z.object({
        content: z.string().describe("learning content"),
        references: z.array(z.string()).describe("url references"),
      })
    )
    .describe(`List of learnings, max of 5`),

  followUpQueries: z.array(
    z.object({
      query: z
        .string()
        .describe(
          "List of follow-up SERP queries to research the topic further, max of 2"
        ),
      goal: z
        .string()
        .describe(
          "The goal of the research that this query is meant to accomplish"
        ),
      // nextSteps: z.array(z.string()),
    })
  ),
});

export type SearchResultSchema = z.infer<typeof searchResultsSchema>;

export const researchSchema = z.object({
  id: z.string().describe("id of the research use memorable ids"),
  name: z.string().describe("The research name/topic"),
  prompt: z.string().describe("the user prompt"),
  maxDepth: z
    .number()
    .default(2)
    .optional()
    .describe("Max deepth of the research"),
  queries: z.array(
    z.object({
      query: z.string().describe("The SERP query"),
      goal: z
        .string()
        .describe(
          "The goal of the research that this query is meant to accomplish"
        ),
    })
  ),
  questions: z
    .array(z.string())
    .describe(
      `Follow up questions to clarify the research direction, max of 5`
    ),
});

--- End File: examples/deep-research/schemas.ts ---

--- File: examples/discord/example-discord.ts ---
import {
  createContainer,
  createDreams,
  createMemoryStore,
  LogLevel,
  validateEnv,
} from "@daydreamsai/core";
import { createChromaVectorStore } from "@daydreamsai/chromadb";
import { deepResearch } from "../deep-research/research";
import { z } from "zod";
import { tavily } from "@tavily/core";
import { anthropic } from "@ai-sdk/anthropic";
import { openai } from "@ai-sdk/openai";
import { discord } from "@daydreamsai/discord";
// Validate environment before proceeding
const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    DISCORD_TOKEN: z.string().min(1, "DISCORD_TOKEN is required"),
    DISCORD_BOT_NAME: z.string().min(1, "DISCORD_BOT_NAME is required"),
    TAVILY_API_KEY: z.string().min(1, "TAVILY_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const container = createContainer();

container.singleton("tavily", () =>
  tavily({
    apiKey: process.env.TAVILY_API_KEY!,
  })
);

const agent = createDreams({
  logger: LogLevel.DEBUG,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [discord, deepResearch],
  container,
  memory: {
    store: createMemoryStore(),
    vector: createChromaVectorStore("agent", "http://localhost:8000"),
    vectorModel: openai("gpt-4-turbo"),
  },
});

console.log("Starting Daydreams Discord Bot...");
await agent.start();
console.log("Daydreams Discord Bot started");

--- End File: examples/discord/example-discord.ts ---

--- File: examples/discord/package.json ---
{
  "name": "discord",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "ai": "4.2.5",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/chromadb": "workspace:*",
    "@ai-sdk/anthropic": "^1.1.17",
    "@ai-sdk/openai": "^1.1.17",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/discord": "workspace:*",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2"
  }
}

--- End File: examples/discord/package.json ---

--- File: examples/extensions/cli.ts ---
import * as readline from "readline/promises";
import { context } from "../context";
import { z } from "zod";
import { extension, input, output } from "../utils";
import { formatMsg } from "../formatters";
import { type AnyAgent } from "../types";
import { service } from "../serviceProvider";

const cliContext = context({
  type: "cli",
  key: ({ user }) => user.toString(),
  schema: z.object({ user: z.string() }),
});

const readlineService = service({
  register(container) {
    container.singleton("readline", () =>
      readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })
    );
  },
});

export const cli = extension({
  name: "cli",
  services: [readlineService],
  contexts: {
    cli: cliContext,
  },
  inputs: {
    // Handle incoming messages
    "cli:message": input({
      schema: z.object({
        user: z.string(),
        text: z.string(),
      }),
      format: ({ data }) =>
        formatMsg({
          role: "user",
          content: data.text,
          user: data.user,
        }),
      // Subscribe to CLI input
      async subscribe(send, { container }: AnyAgent) {
        const rl = container.resolve<readline.Interface>("readline");

        const controller = new AbortController();

        new Promise<void>(async (resolve) => {
          while (!controller.signal.aborted) {
            const question = await rl.question("> ");
            if (question === "exit") {
              break;
            }
            console.log("User:", question);
            send(
              cliContext,
              { user: "admin" },
              {
                user: "admin",
                text: question,
              }
            );
          }

          resolve();
        });

        return () => {
          controller.abort();
        };
      },
    }),
  },
  outputs: {
    "cli:message": output({
      description: "Send messages to the user",
      schema: z.string().describe("The message to send"),
      handler({ content }) {
        console.log("Agent:", { content });
        return {
          data: content,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

--- End File: examples/extensions/cli.ts ---

--- File: examples/games/gigaverse/README.md ---
# Gigaverse Terminal UI

This project provides a terminal-based user interface for the Gigaverse game,
allowing you to play the rock-paper-scissors dungeon crawler game through a
terminal interface.

## Features

- Real-time game state visualization

## Setup

1. Install dependencies:

   ```
   bun i && bun run build:packages
   ```

2. Set up environment variables: Create a `.env` file in the root directory with
   the following variables:

   To get the GIGA_TOKEN you need to login to you:

   1. Login to gigaverse account
   2. Inspect the page. Navigate to 'Application'
   3. Storage -> Local Storage
   4. Within the `authResponse` there will be a value called `jwt` - this is the
      GIGA_TOKEN.
   5. Copy and save in your ENV

   ```
   ANTHROPIC_API_KEY=your_anthropic_api_key
   GIGA_TOKEN=your_gigaverse_token
   OPENAI_API_KEY=your_openai_api_key
   ```

3. Run the application:
   ```
   bun run examples/games/gigaverse/example-gigaverse-simple-ui.ts
   ```

--- End File: examples/games/gigaverse/README.md ---

--- File: examples/games/gigaverse/example-gigaverse-simple-ui.ts ---
/**
 * Example Gigaverse Integration
 *
 * This file demonstrates integration with the Gigaverse game ecosystem.
 * It sets up an agent that can interact with the Gigaverse API to:
 * - Navigate dungeons
 * - Make combat decisions
 * - Select loot and rewards
 * - Manage inventory and character progression
 *
 * The agent uses a goal-oriented approach to plan and execute actions
 * within the game world, making strategic decisions based on the current
 * game state and available options.
 *
 * Authentication is handled via the GIGA_TOKEN environment variable,
 * which must be properly configured for API access. This is the Bearer token. You can copy this from your browser environment.
 *
 * DEBUGGING
 * 1. Your GIGA token expires every 24hrs. Unsure exactly when. If you get an error about the token, just re-authenticate.
 * 2. You can run out of Energy per day - so this will obviously affect your ability to play and throw errors.
 */

import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  LogLevel,
  type Agent,
  createMemoryStore,
  createVectorStore,
  extension,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";
import { simpleUI } from "./simple-ui";
import { openai } from "@ai-sdk/openai";

// Initialize the UI
simpleUI.initializeUI();

// Log startup message
simpleUI.logMessage(
  LogLevel.INFO,
  "Starting Gigaverse Dream Agent with Simple Terminal UI..."
);

// Validate environment variables
const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    GIGA_TOKEN: z.string().min(1, "GIGA_TOKEN is required"),
  })
);

// Template for the agent's context
const template = `
You are an expert AI agent playing a strategic roguelike dungeon crawler game based on rock-paper-scissors mechanics with additional RPG elements called Gigaverse. 

<goal>
- Keep the User updated on the progress and your thinking around what you are doing.
- You must always make a new run if you die.
- You must never stop playing. If you die, you must start a new run.
- You must always make a strategic decision based on the current state of the game.
</goal>

## Game Overview:
- Roguelike dungeon crawler with turn-based combat
- Core combat uses rock-paper-scissors (RPS) mechanics with RPG stats
- Each run is unique and ends when you die
- Progress through rooms by defeating enemies
- Collect loot to strengthen your character

## Combat Mechanics:
- Each battle is 1v1 turn-based combat
- You and enemies have stats:
  - HP (Health Points)
  - Defense (Reduces damage taken)
  - Attack values for Rock/Paper/Scissors moves
  - Defense values for Rock/Paper/Scissors moves
- Standard RPS rules apply:
  - Rock beats Scissors
  - Scissors beats Paper
  - Paper beats Rock
- Damage calculation considers:
  - Base attack value of the winning move
  - Defender's defense stat
  - Specific defense value against the attack type

## Progression System:
- Start in Room 1 and progress by defeating enemies
- After each victory, you can choose from multiple loot options
- Loot can improve your stats or provide special abilities
- Higher rooms contain stronger enemies but better rewards
- Goal is to progress as far as possible before dying

## Strategic Elements:
- Analyze enemy patterns and stats
- Choose optimal moves based on attack/defense values
- Make strategic loot decisions to build your character
- Balance aggressive and defensive playstyles
- Adapt strategy based on current HP and enemy threats

Remember to:
- Monitor your HP and enemy stats
- Consider both immediate battles and long-term survival
- Make informed decisions about loot selection
- Learn from enemy patterns to predict their moves

## Current Status:
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}

## Game State:
Dungeon: {{currentDungeon}}
Room: {{currentRoom}}
Loot Phase: {{lootPhase}}
Last Battle Result: {{lastBattleResult}}
Last Enemy Move: {{lastEnemyMove}}

## Player Stats:
HP: {{playerHealth}}/{{playerMaxHealth}}
Shield: {{playerShield}}/{{playerMaxShield}}
Rock: ATK {{rockAttack}} | DEF {{rockDefense}} | Charges {{rockCharges}}
Paper: ATK {{paperAttack}} | DEF {{paperDefense}} | Charges {{paperCharges}}
Scissor: ATK {{scissorAttack}} | DEF {{scissorDefense}} | Charges {{scissorCharges}}

## Enemy Stats:
Enemy ID: {{currentEnemy}}
HP: {{enemyHealth}}/{{enemyMaxHealth}}
Shield: {{enemyShield}}/{{enemyMaxShield}}

`;

// Define an interface for the state
interface GigaverseState {
  goal: string;
  tasks: string[];
  currentTask: string | null;
  currentDungeon: string;
  currentRoom: string;
  currentEnemy: string;
  currentLoot: string;
  currentHP: string;
  playerHealth: string;
  playerMaxHealth: string;
  playerShield: string;
  playerMaxShield: string;
  rockAttack: string;
  rockDefense: string;
  rockCharges: string;
  paperAttack: string;
  paperDefense: string;
  paperCharges: string;
  scissorAttack: string;
  scissorDefense: string;
  scissorCharges: string;
  enemyHealth: string;
  enemyMaxHealth: string;
  enemyShield: string;
  enemyMaxShield: string;
  lootPhase: string;
  lootOptions: any[];
  lastBattleResult: string;
  lastEnemyMove: string;
}

// Context for the agent
const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state): GigaverseState {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
      currentDungeon: "0",
      currentRoom: "0",
      currentEnemy: "0",
      currentLoot: "0",
      currentHP: "0",
      playerHealth: "0",
      playerMaxHealth: "0",
      playerShield: "0",
      playerMaxShield: "0",
      rockAttack: "0",
      rockDefense: "0",
      rockCharges: "0",
      paperAttack: "0",
      paperDefense: "0",
      paperCharges: "0",
      scissorAttack: "0",
      scissorDefense: "0",
      scissorCharges: "0",
      enemyHealth: "0",
      enemyMaxHealth: "0",
      enemyShield: "0",
      enemyMaxShield: "0",
      lootPhase: "false",
      lootOptions: [],
      lastBattleResult: "",
      lastEnemyMove: "",
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
      currentDungeon: memory.currentDungeon ?? "0",
      currentRoom: memory.currentRoom ?? "0",
      currentEnemy: memory.currentEnemy ?? "0",
      currentLoot: memory.currentLoot ?? "0",
      currentHP: memory.currentHP ?? "0",
      playerHealth: memory.playerHealth ?? "0",
      playerMaxHealth: memory.playerMaxHealth ?? "0",
      playerShield: memory.playerShield ?? "0",
      playerMaxShield: memory.playerMaxShield ?? "0",
      rockAttack: memory.rockAttack ?? "0",
      rockDefense: memory.rockDefense ?? "0",
      rockCharges: memory.rockCharges ?? "0",
      paperAttack: memory.paperAttack ?? "0",
      paperDefense: memory.paperDefense ?? "0",
      paperCharges: memory.paperCharges ?? "0",
      scissorAttack: memory.scissorAttack ?? "0",
      scissorDefense: memory.scissorDefense ?? "0",
      scissorCharges: memory.scissorCharges ?? "0",
      enemyHealth: memory.enemyHealth ?? "0",
      enemyMaxHealth: memory.enemyMaxHealth ?? "0",
      enemyShield: memory.enemyShield ?? "0",
      enemyMaxShield: memory.enemyMaxShield ?? "0",
      lootPhase: memory.lootPhase ?? "false",
      lootOptions: memory.lootOptions ?? [],
      lastBattleResult: memory.lastBattleResult ?? "",
      lastEnemyMove: memory.lastEnemyMove ?? "",
    } as any);
  },
});

const gigaExtension = extension({
  name: "giga",
  contexts: {
    goal: goalContexts,
  },
  actions: [
    /**
     * Action to attack in the rock-paper-scissors game
     */
    action({
      name: "attackInDungeon",
      description:
        "Attack in the dungeon using rock-paper-scissors game mechanics",
      schema: z
        .object({
          action: z
            .enum([
              "rock",
              "paper",
              "scissor",
              "loot_one",
              "loot_two",
              "loot_three",
            ])
            .describe("The attack move to make"),
          dungeonId: z
            .number()
            .default(0)
            .describe("The ID of the dungeon. It is always 0."),
        })
        .describe(
          "You use this to make an action in a dungeon. If the lootPhase == true then you can select the Loot option, which will then take you to the next phase. If the lootPhase == false then you can select the Rock, Paper, Scissors option."
        ),
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction(`Attack with ${data.action}`, null);

          const { action, dungeonId } = data;

          const payload = {
            action: action,
            actionToken: new Date().getTime().toString(),
            dungeonId: dungeonId,
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Attack action failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update the UI with the result
          const successResult = {
            success: true,
            message: `Successfully performed ${action} attack in dungeon ${dungeonId}`,
          };
          simpleUI.logAgentAction(`Attack with ${action}`, successResult);

          // If this was a combat action, visualize the RPS result
          let enemyMove = "unknown";
          let battleResult = "draw";

          // Update the state with player and enemy data
          const state = ctx.agentMemory as GigaverseState;

          // Extract data from the response structure
          if (
            result.data &&
            result.data.run &&
            result.data.run.players &&
            result.data.run.players.length >= 2
          ) {
            const playerData = result.data.run.players[0]; // First player is the user
            const enemyData = result.data.run.players[1]; // Second player is the enemy

            // Get the enemy's last move
            enemyMove = enemyData.lastMove || "unknown";

            // Determine the battle result
            if (playerData.thisPlayerWin === true) {
              battleResult = "win";
            } else if (enemyData.thisPlayerWin === true) {
              battleResult = "lose";
            } else {
              battleResult = "draw";
            }

            // Update player stats
            state.currentHP = playerData.health.current.toString();
            state.playerHealth = playerData.health.current.toString();
            state.playerMaxHealth = playerData.health.currentMax.toString();
            state.playerShield = playerData.shield.current.toString();
            state.playerMaxShield = playerData.shield.currentMax.toString();

            // Update rock/paper/scissor stats
            state.rockAttack = playerData.rock.currentATK.toString();
            state.rockDefense = playerData.rock.currentDEF.toString();
            state.rockCharges = playerData.rock.currentCharges.toString();

            state.paperAttack = playerData.paper.currentATK.toString();
            state.paperDefense = playerData.paper.currentDEF.toString();
            state.paperCharges = playerData.paper.currentCharges.toString();

            state.scissorAttack = playerData.scissor.currentATK.toString();
            state.scissorDefense = playerData.scissor.currentDEF.toString();
            state.scissorCharges = playerData.scissor.currentCharges.toString();

            // Update enemy stats
            state.enemyHealth = enemyData.health.current.toString();
            state.enemyMaxHealth = enemyData.health.currentMax.toString();
            state.enemyShield = enemyData.shield.current.toString();
            state.enemyMaxShield = enemyData.shield.currentMax.toString();

            // Update battle result and enemy move
            state.lastBattleResult = battleResult;
            state.lastEnemyMove = enemyMove;

            // Update loot phase status
            state.lootPhase = (result.data.run.lootPhase || false).toString();

            // Update loot options if available
            if (
              result.data.run.lootOptions &&
              result.data.run.lootOptions.length > 0
            ) {
              state.lootOptions = result.data.run.lootOptions;
              state.currentLoot = result.data.run.lootOptions.length.toString();
            }

            // Update room information
            if (result.data.entity) {
              state.currentRoom = result.data.entity.ROOM_NUM_CID.toString();
              state.currentDungeon =
                result.data.entity.DUNGEON_ID_CID.toString();
              state.currentEnemy = result.data.entity.ENEMY_CID.toString();
            }
          }

          if (["rock", "paper", "scissor"].includes(action)) {
            simpleUI.visualizeRPSMove(action, enemyMove, battleResult);
          }

          // Display the updated state to the user
          simpleUI.printDetailedGameState(state);

          // Update game state in the UI
          if (result.gameState) {
            simpleUI.printGameState(result.gameState);
          }

          // Update player stats in the UI
          if (result.playerState) {
            simpleUI.printPlayerStats(result.playerState);
          }

          return {
            success: true,
            result,
            message: `
            Successfully performed ${action} attack in dungeon ${dungeonId}

            Enemy Move: ${enemyMove}
            Battle Result: ${battleResult}

            Player Health: ${state.playerHealth}
            Player Max Health: ${state.playerMaxHealth}
            Player Shield: ${state.playerShield}
            Player Max Shield: ${state.playerMaxShield}
            

            `,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error performing attack action:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to perform attack action",
          };
          simpleUI.logAgentAction(`Attack with ${data.action}`, failureResult);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to perform attack action",
          };
        }
      },
    }),

    /**
     * Action to fetch upcoming enemies data
     */
    action({
      name: "getUpcomingEnemies",
      description:
        "Fetch information about all upcoming enemies in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction("Fetching upcoming enemies", null);

          const response = await fetch(
            "https://gigaverse.io/api/indexer/enemies",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch enemies failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update the enemy info in the UI
          simpleUI.printEnemyInfo(result);

          // Log success to the UI
          const successResult = {
            success: true,
            message: "Successfully fetched upcoming enemies data",
          };
          simpleUI.logAgentAction("Fetching upcoming enemies", successResult);

          return {
            success: true,
            enemies: result,
            message: "Successfully fetched upcoming enemies data",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching enemies data:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to fetch upcoming enemies data",
          };
          simpleUI.logAgentAction("Fetching upcoming enemies", failureResult);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch upcoming enemies data",
          };
        }
      },
    }),

    /**
     * Action to fetch the player's current state in the dungeon
     */
    action({
      name: "getPlayerState",
      description: "Fetch the current state of the player in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction("Fetching player state", null);

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/state",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch player state failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update game state in the UI if available
          if (result.gameState) {
            simpleUI.printGameState(result.gameState);
          }

          // Update the state with player data
          if (
            result.data &&
            result.data.run &&
            result.data.run.players &&
            result.data.run.players.length > 0
          ) {
            const state = ctx.agentMemory as GigaverseState;
            const playerData = result.data.run.players[0]; // First player is the user

            // Update player stats
            state.currentHP = playerData.health.current.toString();
            state.playerHealth = playerData.health.current.toString();
            state.playerMaxHealth = playerData.health.currentMax.toString();
            state.playerShield = playerData.shield.current.toString();
            state.playerMaxShield = playerData.shield.currentMax.toString();

            // Update rock/paper/scissor stats
            state.rockAttack = playerData.rock.currentATK.toString();
            state.rockDefense = playerData.rock.currentDEF.toString();
            state.rockCharges = playerData.rock.currentCharges.toString();

            state.paperAttack = playerData.paper.currentATK.toString();
            state.paperDefense = playerData.paper.currentDEF.toString();
            state.paperCharges = playerData.paper.currentCharges.toString();

            state.scissorAttack = playerData.scissor.currentATK.toString();
            state.scissorDefense = playerData.scissor.currentDEF.toString();
            state.scissorCharges = playerData.scissor.currentCharges.toString();

            // Update loot phase status
            state.lootPhase = (result.data.run.lootPhase || false).toString();

            // Update loot options if available
            if (
              result.data.run.lootOptions &&
              result.data.run.lootOptions.length > 0
            ) {
              state.lootOptions = result.data.run.lootOptions;
              state.currentLoot = result.data.run.lootOptions.length.toString();
            }

            // Update room information if available
            if (result.data.entity) {
              state.currentRoom = result.data.entity.ROOM_NUM_CID.toString();
              state.currentDungeon =
                result.data.entity.DUNGEON_ID_CID.toString();
              state.currentEnemy = result.data.entity.ENEMY_CID.toString();
            }

            // Update enemy stats if available
            if (result.data.run.players.length > 1) {
              const enemyData = result.data.run.players[1]; // Second player is the enemy
              state.enemyHealth = enemyData.health.current.toString();
              state.enemyMaxHealth = enemyData.health.currentMax.toString();
              state.enemyShield = enemyData.shield.current.toString();
              state.enemyMaxShield = enemyData.shield.currentMax.toString();

              // Update battle result and enemy move if available
              if (enemyData.lastMove) {
                state.lastEnemyMove = enemyData.lastMove;

                // Determine battle result if not already set
                if (
                  !state.lastBattleResult &&
                  playerData.thisPlayerWin !== undefined
                ) {
                  if (playerData.thisPlayerWin === true) {
                    state.lastBattleResult = "win";
                  } else if (enemyData.thisPlayerWin === true) {
                    state.lastBattleResult = "lose";
                  } else {
                    state.lastBattleResult = "draw";
                  }
                }
              }
            }

            // Display the updated state to the user
            simpleUI.printDetailedGameState(state);
          }

          // Log success to the UI
          const successResult = {
            success: true,
            message: "Successfully fetched player's dungeon state",
          };
          simpleUI.logAgentAction("Fetching player state", successResult);

          return {
            success: true,
            playerState: result,
            message: "Successfully fetched player's dungeon state",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching player state:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to fetch player's dungeon state",
          };
          simpleUI.logAgentAction("Fetching player state", failureResult);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch player's dungeon state",
          };
        }
      },
    }),

    /**
     * Action to start a new dungeon run
     */
    action({
      name: "startNewRun",
      description:
        "Start a new dungeon run. Use this when the player dies or wants to start a new run from outside the dungeon.",
      schema: z.object({
        dungeonId: z
          .number()
          .default(1)
          .describe("The ID of the dungeon to start. Default is 1."),
      }),
      async handler(data, ctx: any, agent: Agent) {
        try {
          // Log the action to the UI
          simpleUI.logAgentAction(
            `Starting new run in dungeon ${data.dungeonId}`,
            null
          );

          const { dungeonId } = data;

          const payload = {
            action: "start_run",
            actionToken: "",
            dungeonId: dungeonId,
            data: {
              consumables: [],
              itemId: 0,
              index: 0,
            },
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Start new run failed with status ${response.status}`
            );
          }

          const result = await response.json();

          // Update game state in the UI
          if (result.gameState) {
            simpleUI.printGameState(result.gameState);
          }

          // Update player stats in the UI
          if (result.playerState) {
            simpleUI.printPlayerStats(result.playerState);
          }

          // Update the state with the new run data
          if (
            result.data &&
            result.data.run &&
            result.data.run.players &&
            result.data.run.players.length > 0
          ) {
            const state = ctx.agentMemory as GigaverseState;
            const playerData = result.data.run.players[0]; // First player is the user

            // Update player stats
            state.currentHP = playerData.health.current.toString();
            state.playerHealth = playerData.health.current.toString();
            state.playerMaxHealth = playerData.health.currentMax.toString();
            state.playerShield = playerData.shield.current.toString();
            state.playerMaxShield = playerData.shield.currentMax.toString();

            // Update rock/paper/scissor stats
            state.rockAttack = playerData.rock.currentATK.toString();
            state.rockDefense = playerData.rock.currentDEF.toString();
            state.rockCharges = playerData.rock.currentCharges.toString();

            state.paperAttack = playerData.paper.currentATK.toString();
            state.paperDefense = playerData.paper.currentDEF.toString();
            state.paperCharges = playerData.paper.currentCharges.toString();

            state.scissorAttack = playerData.scissor.currentATK.toString();
            state.scissorDefense = playerData.scissor.currentDEF.toString();
            state.scissorCharges = playerData.scissor.currentCharges.toString();

            // Update dungeon info
            state.currentDungeon = dungeonId.toString();
            state.currentRoom = "1"; // New runs start at room 1
            state.lootPhase = "false";
            state.lootOptions = [];
            state.lastBattleResult = "";
            state.lastEnemyMove = "";

            // Update enemy stats (reset them for new run)
            state.enemyHealth = "0";
            state.enemyMaxHealth = "0";
            state.enemyShield = "0";
            state.enemyMaxShield = "0";
            state.currentEnemy = "0";

            // Display the updated state to the user
            simpleUI.printDetailedGameState(state);
          }

          // Log success to the UI
          const successResult = {
            success: true,
            message: `Successfully started a new run in dungeon ${dungeonId}`,
          };
          simpleUI.logAgentAction(
            `Starting new run in dungeon ${dungeonId}`,
            successResult
          );

          return {
            success: true,
            result,
            message: `Successfully started a new run in dungeon ${dungeonId}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error starting new run:", error);

          // Log the error to the UI
          const failureResult = {
            success: false,
            error: errorMessage,
            message: "Failed to start a new dungeon run",
          };
          simpleUI.logAgentAction(
            `Starting new run in dungeon ${data.dungeonId}`,
            failureResult
          );

          return {
            success: false,
            error: errorMessage,
            message: "Failed to start a new dungeon run",
          };
        }
      },
    }),
  ],
});

// Create the Gigaverse agent with UI integration
const agent = createDreams({
  logger: LogLevel.DEBUG,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension, gigaExtension],
  exportTrainingData: true,
  trainingDataPath: "./training-data.jsonl",
  memory: {
    store: createMemoryStore(),
    vector: createVectorStore(),
    vectorModel: openai("gpt-4-turbo"),
  },
});

// Start the agent with initial goals
simpleUI.logMessage(LogLevel.INFO, "Starting agent with initial goals...");

agent.start({
  id: "gigaverse-game",
  initialGoal:
    "Progress as far as possible in the dungeon by making strategic rock-paper-scissors decisions. Don't ever stop. Just start a new run if you die.",
  initialTasks: [
    "Check player state to understand current situation",
    "Fetch information about upcoming enemies",
    "Start a new run if not already in a dungeon",
    "Make strategic combat decisions based on enemy patterns",
    "Select optimal loot to improve chances of survival",
  ],
});

// Display welcome message
simpleUI.logMessage(
  LogLevel.INFO,
  "Gigaverse Dream Agent is now running! The agent will automatically play the game."
);

// Handle exit
process.on("SIGINT", () => {
  simpleUI.logMessage(LogLevel.INFO, "Shutting down agent...");
  process.exit(0);
});

--- End File: examples/games/gigaverse/example-gigaverse-simple-ui.ts ---

--- File: examples/games/gigaverse/example-gigaverse.ts ---
/**
 * Example Gigaverse Integration
 *
 * This file demonstrates integration with the Gigaverse game ecosystem.
 * It sets up an agent that can interact with the Gigaverse API to:
 * - Navigate dungeons
 * - Make combat decisions
 * - Select loot and rewards
 * - Manage inventory and character progression
 *
 * The agent uses a goal-oriented approach to plan and execute actions
 * within the game world, making strategic decisions based on the current
 * game state and available options.
 *
 * Authentication is handled via the GIGA_TOKEN environment variable,
 * which must be properly configured for API access. This is the Bearer token. You can copy this from your browser environment.
 */

import { anthropic } from "@ai-sdk/anthropic";
import {
  createDreams,
  context,
  render,
  action,
  validateEnv,
  LogLevel,
  type ActionCall,
  type Agent,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { string, z } from "zod";

const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    GIGA_TOKEN: z.string().min(1, "GIGA_TOKEN is required"),
  })
);

// 1. Take action -> check health -> check loot phase = true -> select loot
// 2. Select the loot -> takes to new phase -> take 1. again

const template = `

// inject more information about how you want it to play....


Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}
`;

const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string(),
    initialTasks: z.array(z.string()),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: state.args.initialGoal,
      tasks: state.args.initialTasks ?? [],
      currentTask: state.args.initialTasks?.[0],
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal,
      tasks: memory.tasks.join("\n"),
      currentTask: memory.currentTask ?? "NONE",
    });
  },
});

// ==========================================
// ACTIONS DEFINITION
// ==========================================

/**
 * Create the Gigaverse agent with all necessary actions
 */
createDreams({
  logger: LogLevel.INFO,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension],
  context: goalContexts,
  actions: [
    // start run (sends the starting 1-2 dungeon)
    // collect loot (selects the loot from the resonse)
    /**
     * Action to attack in the rock-paper-scissors game
     */
    action({
      name: "attackInDungeon",
      description:
        "Attack in the dungeon using rock-paper-scissors game mechanics",
      schema: z
        .object({
          action: z
            .enum([
              "rock",
              "paper",
              "scissor",
              "loot_one",
              "loot_two",
              "loot_three",
            ])
            .describe("The attack move to make"),
          dungeonId: z
            .number()
            .default(0)
            .describe("The ID of the dungeon. It is always 0. "),
        })
        .describe(
          "You use this to make an action in a dungeon. If the lootPhase == true then you can select the Loot option, which will then take you to the next phase. If the lootPhase == false then you can select the Rock, Paper, Scissors option."
        ),
      async handler(data, ctx: any, agent: Agent) {
        try {
          const { action, dungeonId } = data;

          const payload = {
            action: action,
            actionToken: new Date().getTime().toString(),
            dungeonId: dungeonId,
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Attack action failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            result,
            message: `Successfully performed ${action} attack in dungeon ${0}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error performing attack action:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to perform attack action",
          };
        }
      },
    }),

    /**
     * Action to fetch upcoming enemies data
     */
    action({
      name: "getUpcomingEnemies",
      description:
        "Fetch information about all upcoming enemies in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          const response = await fetch(
            "https://gigaverse.io/api/indexer/enemies",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch enemies failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            enemies: result,
            message: "Successfully fetched upcoming enemies data",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching enemies data:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch upcoming enemies data",
          };
        }
      },
    }),

    /**
     * Action to fetch the player's current state in the dungeon
     */
    action({
      name: "getPlayerState",
      description: "Fetch the current state of the player in the dungeon",
      schema: z.object({}), // No parameters needed for this GET request
      async handler(data, ctx: any, agent: Agent) {
        try {
          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/state",
            {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
            }
          );

          if (!response.ok) {
            throw new Error(
              `Fetch player state failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            playerState: result,
            message: "Successfully fetched player's dungeon state",
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error fetching player state:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to fetch player's dungeon state",
          };
        }
      },
    }),

    /**
     * Action to start a new dungeon run
     */
    action({
      name: "startNewRun",
      description:
        "Start a new dungeon run. Use this when the player dies or wants to start a new run from outside the dungeon.",
      schema: z.object({
        dungeonId: z
          .number()
          .default(1)
          .describe("The ID of the dungeon to start. Default is 1."),
      }),
      async handler(data, ctx: any, agent: Agent) {
        try {
          const { dungeonId } = data;

          const payload = {
            action: "start_run",
            actionToken: new Date().getTime().toString(),
            dungeonId: dungeonId,
          };

          const response = await fetch(
            "https://gigaverse.io/api/game/dungeon/action",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${env.GIGA_TOKEN}`,
              },
              body: JSON.stringify(payload),
            }
          );

          if (!response.ok) {
            throw new Error(
              `Start new run failed with status ${response.status}`
            );
          }

          const result = await response.json();
          return {
            success: true,
            result,
            message: `Successfully started a new run in dungeon ${dungeonId}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("Error starting new run:", error);
          return {
            success: false,
            error: errorMessage,
            message: "Failed to start a new dungeon run",
          };
        }
      },
    }),
  ],
}).start({ id: "test", initialGoal: "", initialTasks: [] });

--- End File: examples/games/gigaverse/example-gigaverse.ts ---

--- File: examples/games/gigaverse/package.json ---
{
  "name": "games",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/chromadb": "workspace:*",
    "@daydreamsai/discord": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: examples/games/gigaverse/package.json ---

--- File: examples/games/gigaverse/simple-ui.ts ---
/**
 * Simple Terminal UI for Gigaverse
 *
 * This file provides a simpler terminal UI that doesn't rely on the blessed library.
 * It uses basic ANSI escape codes for colors and formatting.
 */

import { LogLevel } from "@daydreamsai/core";

// ANSI color codes
const COLORS = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  dim: "\x1b[2m",
  underscore: "\x1b[4m",
  blink: "\x1b[5m",
  reverse: "\x1b[7m",
  hidden: "\x1b[8m",

  black: "\x1b[30m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
  white: "\x1b[37m",

  bgBlack: "\x1b[40m",
  bgRed: "\x1b[41m",
  bgGreen: "\x1b[42m",
  bgYellow: "\x1b[43m",
  bgBlue: "\x1b[44m",
  bgMagenta: "\x1b[45m",
  bgCyan: "\x1b[46m",
  bgWhite: "\x1b[47m",
};

// Map log levels to colors
const LOG_LEVEL_COLORS = {
  [LogLevel.TRACE]: COLORS.dim + COLORS.white,
  [LogLevel.DEBUG]: COLORS.blue,
  [LogLevel.INFO]: COLORS.green,
  [LogLevel.WARN]: COLORS.yellow,
  [LogLevel.ERROR]: COLORS.red,
};

// Map game elements to colors
const GAME_COLORS = {
  rock: COLORS.red,
  paper: COLORS.green,
  scissor: COLORS.blue,
  health: COLORS.red,
  mana: COLORS.blue,
  gold: COLORS.yellow,
  enemy: COLORS.magenta,
  loot: COLORS.cyan,
};

// Clear the terminal
export function clearScreen(): void {
  process.stdout.write("\x1Bc");
}

// Print a section header
export function printHeader(title: string): void {
  const width = process.stdout.columns || 80;
  const padding = "=".repeat(Math.floor((width - title.length - 4) / 2));
  console.log(
    `\n${padding} ${COLORS.bright}${title}${COLORS.reset} ${padding}\n`
  );
}

// Print a log message
export function logMessage(level: LogLevel, message: string): void {
  const color = LOG_LEVEL_COLORS[level] || COLORS.white;
  const levelName = LogLevel[level].toUpperCase();
  const timestamp = new Date().toLocaleTimeString();
  console.log(
    `${color}[${timestamp}] [${levelName}] ${message}${COLORS.reset}`
  );
}

// Print player stats
export function printPlayerStats(playerState: any): void {
  if (!playerState) {
    console.log(`${COLORS.yellow}No player data available${COLORS.reset}`);
    return;
  }

  printHeader("Player Stats");

  const { health, maxHealth, gold, level, inventory } = playerState;

  // Create a health bar
  const healthPercentage = Math.floor((health / maxHealth) * 100);
  const healthBar = createProgressBar(healthPercentage, COLORS.red);

  console.log(
    `${COLORS.bright}Health:${COLORS.reset} ${health}/${maxHealth} ${healthBar}`
  );
  console.log(`${COLORS.bright}Level:${COLORS.reset} ${level}`);
  console.log(
    `${COLORS.bright}Gold:${COLORS.reset} ${COLORS.yellow}${gold}${COLORS.reset}`
  );

  // Format inventory if available
  if (inventory && inventory.length > 0) {
    console.log(`\n${COLORS.bright}Inventory:${COLORS.reset}`);
    inventory.forEach((item: any) => {
      console.log(`  - ${item.name} (${item.quantity})`);
    });
  } else {
    console.log(`\n${COLORS.bright}Inventory:${COLORS.reset} None`);
  }
}

// Print game state
export function printGameState(gameState: any): void {
  if (!gameState) {
    console.log(`${COLORS.yellow}No game state available${COLORS.reset}`);
    return;
  }

  printHeader("Game State");

  const { dungeonId, currentRoom, lootPhase, enemyName, enemyHealth } =
    gameState;

  console.log(`${COLORS.bright}Dungeon:${COLORS.reset} ${dungeonId}`);
  console.log(`${COLORS.bright}Room:${COLORS.reset} ${currentRoom}`);
  console.log(
    `${COLORS.bright}Phase:${COLORS.reset} ${lootPhase ? "Loot Selection" : "Combat"}`
  );

  if (enemyName && !lootPhase) {
    // Create an enemy health bar if in combat
    const enemyHealthPercentage = Math.floor(
      (enemyHealth.current / enemyHealth.max) * 100
    );
    const enemyHealthBar = createProgressBar(
      enemyHealthPercentage,
      COLORS.magenta
    );

    console.log(
      `\n${COLORS.bright}Current Enemy:${COLORS.reset} ${COLORS.magenta}${enemyName}${COLORS.reset}`
    );
    console.log(
      `${COLORS.bright}Enemy Health:${COLORS.reset} ${enemyHealth.current}/${enemyHealth.max} ${enemyHealthBar}`
    );
  } else if (lootPhase) {
    console.log(`\n${COLORS.bright}Select your reward!${COLORS.reset}`);
    console.log(
      `Use the ${COLORS.cyan}loot_one${COLORS.reset}, ${COLORS.cyan}loot_two${COLORS.reset}, or ${COLORS.cyan}loot_three${COLORS.reset} actions to choose.`
    );
  }
}

// Print enemy information
export function printEnemyInfo(enemies: any): void {
  if (!enemies || !enemies.entities || enemies.entities.length === 0) {
    console.log(`${COLORS.yellow}No enemy data available${COLORS.reset}`);
    return;
  }

  printHeader("Upcoming Enemies");

  // Display information about upcoming enemies
  const enemyList = enemies.entities.slice(0, 5); // Show first 5 enemies

  enemyList.forEach((enemy: any, index: number) => {
    console.log(
      `${COLORS.magenta}${index + 1}. ${enemy.NAME_CID}${COLORS.reset}`
    );

    // Display move stats if available
    if (enemy.MOVE_STATS_CID_array && enemy.MOVE_STATS_CID_array.length >= 8) {
      const moveStats = enemy.MOVE_STATS_CID_array;
      console.log(
        `   Rock: ${moveStats[0]}, Paper: ${moveStats[2]}, Scissors: ${moveStats[4]}`
      );
    }

    console.log("");
  });
}

// Log an agent action
export function logAgentAction(action: string, result: any): void {
  // Format the action for display
  const timestamp = new Date().toLocaleTimeString();
  console.log(
    `\n${COLORS.bright}[${timestamp}] Agent Action:${COLORS.reset} ${action}`
  );

  // Add result information if available
  if (result) {
    if (result.success) {
      console.log(`${COLORS.green}✓ Success:${COLORS.reset} ${result.message}`);
    } else {
      console.log(`${COLORS.red}✗ Failed:${COLORS.reset} ${result.message}`);
    }
  }
}

// Visualize a rock-paper-scissors move
export function visualizeRPSMove(
  playerMove: string,
  enemyMove: string,
  result: string
): void {
  const moveSymbols: Record<string, string> = {
    rock: "✊",
    paper: "✋",
    scissor: "✌️",
  };

  const playerSymbol = moveSymbols[playerMove] || playerMove;
  const enemySymbol = moveSymbols[enemyMove] || enemyMove;

  let resultColor = COLORS.yellow;
  if (result === "win") resultColor = COLORS.green;
  if (result === "lose") resultColor = COLORS.red;

  printHeader("Rock-Paper-Scissors Result");

  console.log(
    `${COLORS.bright}You:${COLORS.reset} ${GAME_COLORS[playerMove as keyof typeof GAME_COLORS] || COLORS.white}${playerSymbol}${COLORS.reset}  vs  ${COLORS.bright}Enemy:${COLORS.reset} ${GAME_COLORS[enemyMove as keyof typeof GAME_COLORS] || COLORS.white}${enemySymbol}${COLORS.reset}`
  );
  console.log(
    `\n${COLORS.bright}Result:${COLORS.reset} ${resultColor}${result.toUpperCase()}${COLORS.reset}\n`
  );
}

// Create a visual progress bar
function createProgressBar(percentage: number, color: string): string {
  const width = 20;
  const filledWidth = Math.floor((percentage / 100) * width);
  const emptyWidth = width - filledWidth;

  const filled = "█".repeat(filledWidth);
  const empty = "░".repeat(emptyWidth);

  return `${color}${filled}${COLORS.reset}${empty} ${percentage}%`;
}

// Print a divider line
export function printDivider(): void {
  const width = process.stdout.columns || 80;
  console.log("\n" + "-".repeat(width) + "\n");
}

// Print help information
export function printHelp(): void {
  printHeader("Help");
  console.log("This is a simple terminal UI for the Gigaverse game.");
  console.log("Press Ctrl+C to exit the application.");
}

// Initialize the UI
export function initializeUI(): void {
  clearScreen();
  console.log(
    `${COLORS.green}${COLORS.bright}Gigaverse Simple Terminal UI${COLORS.reset}`
  );
  console.log(
    `${COLORS.dim}A simpler alternative to the blessed-based UI${COLORS.reset}`
  );
  printDivider();
}

// Print detailed game state from GigaverseState
export function printDetailedGameState(state: any): void {
  printHeader("Current Game Status");

  // Game location info
  console.log(`${COLORS.bright}${COLORS.cyan}Location:${COLORS.reset}`);
  console.log(`${COLORS.bright}Dungeon:${COLORS.reset} ${state.currentDungeon}`);
  console.log(`${COLORS.bright}Room:${COLORS.reset} ${state.currentRoom}`);
  console.log(`${COLORS.bright}Loot Phase:${COLORS.reset} ${state.lootPhase === "true" ? "Yes" : "No"}`);
  
  // Battle info
  if (state.lastBattleResult) {
    console.log(`\n${COLORS.bright}${COLORS.yellow}Last Battle:${COLORS.reset}`);
    console.log(`${COLORS.bright}Result:${COLORS.reset} ${state.lastBattleResult}`);
    console.log(`${COLORS.bright}Enemy Move:${COLORS.reset} ${state.lastEnemyMove}`);
  }
  
  // Player stats
  console.log(`\n${COLORS.bright}${COLORS.green}Player Stats:${COLORS.reset}`);
  
  // Health and shield
  const healthPercentage = Math.floor((parseInt(state.playerHealth) / parseInt(state.playerMaxHealth)) * 100) || 0;
  const healthBar = createProgressBar(healthPercentage, COLORS.red);
  console.log(`${COLORS.bright}Health:${COLORS.reset} ${state.playerHealth}/${state.playerMaxHealth} ${healthBar}`);
  
  const shieldPercentage = Math.floor((parseInt(state.playerShield) / parseInt(state.playerMaxShield)) * 100) || 0;
  const shieldBar = createProgressBar(shieldPercentage, COLORS.blue);
  console.log(`${COLORS.bright}Shield:${COLORS.reset} ${state.playerShield}/${state.playerMaxShield} ${shieldBar}`);
  
  // Weapon stats
  console.log(`\n${COLORS.bright}Weapon Stats:${COLORS.reset}`);
  console.log(`${COLORS.red}Rock:${COLORS.reset} ATK ${state.rockAttack} | DEF ${state.rockDefense} | Charges ${state.rockCharges}`);
  console.log(`${COLORS.green}Paper:${COLORS.reset} ATK ${state.paperAttack} | DEF ${state.paperDefense} | Charges ${state.paperCharges}`);
  console.log(`${COLORS.blue}Scissor:${COLORS.reset} ATK ${state.scissorAttack} | DEF ${state.scissorDefense} | Charges ${state.scissorCharges}`);
  
  // Enemy stats if available
  if (parseInt(state.enemyHealth) > 0 || state.currentEnemy !== "0") {
    console.log(`\n${COLORS.bright}${COLORS.red}Enemy Stats:${COLORS.reset}`);
    console.log(`${COLORS.bright}Enemy ID:${COLORS.reset} ${state.currentEnemy}`);
    
    const enemyHealthPercentage = Math.floor((parseInt(state.enemyHealth) / parseInt(state.enemyMaxHealth)) * 100) || 0;
    const enemyHealthBar = createProgressBar(enemyHealthPercentage, COLORS.red);
    console.log(`${COLORS.bright}Health:${COLORS.reset} ${state.enemyHealth}/${state.enemyMaxHealth} ${enemyHealthBar}`);
    
    const enemyShieldPercentage = Math.floor((parseInt(state.enemyShield) / parseInt(state.enemyMaxShield)) * 100) || 0;
    const enemyShieldBar = createProgressBar(enemyShieldPercentage, COLORS.blue);
    console.log(`${COLORS.bright}Shield:${COLORS.reset} ${state.enemyShield}/${state.enemyMaxShield} ${enemyShieldBar}`);
  }
  
  // Loot options if available
  if (state.lootPhase === "true" && state.lootOptions && state.lootOptions.length > 0) {
    console.log(`\n${COLORS.bright}${COLORS.yellow}Loot Options:${COLORS.reset}`);
    state.lootOptions.forEach((loot: any, index: number) => {
      console.log(`${COLORS.bright}Option ${index + 1}:${COLORS.reset} ${loot.boonTypeString} (Rarity: ${loot.RARITY_CID})`);
    });
  }
  
  printDivider();
}

// Export a simple UI object
export const simpleUI = {
  clearScreen,
  printHeader,
  logMessage,
  printPlayerStats,
  printGameState,
  printEnemyInfo,
  logAgentAction,
  visualizeRPSMove,
  printDivider,
  printHelp,
  initializeUI,
  printDetailedGameState,
};

--- End File: examples/games/gigaverse/simple-ui.ts ---

--- File: examples/games/lootsurvivor/README.md ---
# Loot Survivor CLI agent

### Make sure you have your starknet env setup in root dir like usual

> check todo at the bottom to see current usage !

1. install deps in root

```bash
bun install
```

then build core

```bash
cd packages/core/
bun run build
```

and also build the defai package located at `packages/defai`:

```bash
cd packages/defai
bun run build
```

then from root, to start the agent:

```bash
bun run examples/games/lootsurvivor/example-lootsurvivor.ts
```

TODO IMPORTANT

- fix the new game issue. CURRENTLY i have to start a new game manually, and
  then boot agent and say something like "You are adventurer 12345. You have
  already been created, so now check state, decide what to do next, act"
- ~~DONE update max health state display~~
- ~~DONE item xp tracking (greatness)~~
- ~~DONE fix level display~~
- ~~DONE market items and cost~~
- ~~DONE check to make sure we are async await for the txns to go through before
  sending the api call to the agent. because i think wwe are calculating state
  before waiting for response, and sending the incomplete state to the agent.~~

--- End File: examples/games/lootsurvivor/README.md ---

--- File: examples/games/lootsurvivor/example-lootsurvivor.ts ---
import {
  action,
  type ActionCall,
  type Agent,
  context,
  createDreams,
  extension,
  render,
  validateEnv,
  LogLevel,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { anthropic } from "@ai-sdk/anthropic";
import { string, z } from "zod";
import { StarknetChain } from "@daydreamsai/defai";

/**
 * NOTE: To resolve the '@daydreamsai/defai' module error:
 * 1. First make sure you have the package installed by running:
 *    pnpm add @daydreamsai/defai
 *
 * 2. If developing within the monorepo, you may need to add it to your workspace:
 *    In package.json, add:
 *    "dependencies": {
 *      "@daydreamsai/defai": "workspace:*"
 *    }
 */

// Validate environment variables
const env = validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    STARKNET_RPC_URL: z.string().min(1, "STARKNET_RPC_URL is required"),
    STARKNET_ADDRESS: z.string().min(1, "STARKNET_ADDRESS is required"),
    STARKNET_PRIVATE_KEY: z.string().min(1, "STARKNET_PRIVATE_KEY is required"),
  })
);

// Initialize Starknet chain connection
const starknet = new StarknetChain({
  rpcUrl: env.STARKNET_RPC_URL,
  address: env.STARKNET_ADDRESS,
  privateKey: env.STARKNET_PRIVATE_KEY,
});

// Game contract addresses
const GAME_CONTRACT_ADDRESS =
  "0x018108b32cea514a78ef1b0e4a0753e855cdf620bc0565202c02456f618c4dc4"; // Loot Survivor contract address

// Define an interface for the Loot Survivor state
interface LootSurvivorState {
  // Game state
  adventurerId: string;
  adventurerHealth: string;
  adventurerMaxHealth: string;
  level: string;
  xp: string;
  gold: string;
  statUpgrades: string;

  // Battle state
  inBattle: string;
  lastAction: string;
  lastDamageDealt: string;
  lastDamageTaken: string;
  lastCritical: string;
  battleActionCount: string;

  // Stats
  strength: string;
  dexterity: string;
  vitality: string;
  intelligence: string;
  wisdom: string;
  charisma: string;
  luck: string;

  // Equipment
  weapon: string;
  chest: string;
  head: string;
  waist: string;
  foot: string;
  hand: string;
  neck: string;
  ring: string;

  // Equipment XP (greatness levels)
  weaponXP: string;
  chestXP: string;
  headXP: string;
  waistXP: string;
  footXP: string;
  handXP: string;
  neckXP: string;
  ringXP: string;

  // Beast info
  currentBeast: string;
  beastHealth: string;
  beastMaxHealth: string;
  beastLevel: string;
  beastTier: string;
  beastType: string;
  beastSpecial1: string;
  beastSpecial2: string;
  beastSpecial3: string;

  // Bag/Inventory
  bagItems: string[];

  // Market
  marketItems: Array<{ id: string; name: string; price: string }>;
}

// Helper to convert hex values to decimal
function hexToDec(hex: string): string {
  // Remove '0x' prefix if present
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  return parseInt(cleanHex, 16).toString();
}

// Function to get prefix1 name from ID
function getPrefix1(prefixId: string): string {
  const prefixNames: { [key: string]: string } = {
    "1": "Agony",
    "2": "Apocalypse",
    "3": "Armageddon",
    "4": "Beast",
    "5": "Behemoth",
    "6": "Blight",
    "7": "Blood",
    "8": "Bramble",
    "9": "Brimstone",
    "10": "Brood",
    "11": "Carrion",
    "12": "Cataclysm",
    "13": "Chimeric",
    "14": "Corpse",
    "15": "Corruption",
    "16": "Damnation",
    "17": "Death",
    "18": "Demon",
    "19": "Dire",
    "20": "Dragon",
    "21": "Dread",
    "22": "Doom",
    "23": "Dusk",
    "24": "Eagle",
    "25": "Empyrean",
    "26": "Fate",
    "27": "Foe",
    "28": "Gale",
    "29": "Ghoul",
    "30": "Gloom",
    "31": "Glyph",
    "32": "Golem",
    "33": "Grim",
    "34": "Hate",
    "35": "Havoc",
    "36": "Honour",
    "37": "Horror",
    "38": "Hypnotic",
    "39": "Kraken",
    "40": "Loath",
    "41": "Maelstrom",
    "42": "Mind",
    "43": "Miracle",
    "44": "Morbid",
    "45": "Oblivion",
    "46": "Onslaught",
    "47": "Pain",
    "48": "Pandemonium",
    "49": "Phoenix",
    "50": "Plague",
    "51": "Rage",
    "52": "Rapture",
    "53": "Rune",
    "54": "Skull",
    "55": "Sol",
    "56": "Soul",
    "57": "Sorrow",
    "58": "Spirit",
    "59": "Storm",
    "60": "Tempest",
    "61": "Torment",
    "62": "Vengeance",
    "63": "Victory",
    "64": "Viper",
    "65": "Vortex",
    "66": "Woe",
    "67": "Wrath",
    "68": "Lights",
    "69": "Shimmering",
  };
  return prefixNames[prefixId] || "";
}

// Function to get prefix2 name from ID
function getPrefix2(suffixId: string): string {
  const suffixNames: { [key: string]: string } = {
    "1": "Bane",
    "2": "Root",
    "3": "Bite",
    "4": "Song",
    "5": "Roar",
    "6": "Grasp",
    "7": "Instrument",
    "8": "Glow",
    "9": "Bender",
    "10": "Shadow",
    "11": "Whisper",
    "12": "Shout",
    "13": "Growl",
    "14": "Tear",
    "15": "Peak",
    "16": "Form",
    "17": "Sun",
    "18": "Moon",
  };
  return suffixNames[suffixId] || "";
}

// Function to get suffix name from ID
function getItemSuffix(suffixId: string): string {
  const itemSuffixes: { [key: string]: string } = {
    "1": "of Power",
    "2": "of Giant",
    "3": "of Titans",
    "4": "of Skill",
    "5": "of Perfection",
    "6": "of Brilliance",
    "7": "of Enlightenment",
    "8": "of Protection",
    "9": "of Anger",
    "10": "of Rage",
    "11": "of Fury",
    "12": "of Vitriol",
    "13": "of the Fox",
    "14": "of Detection",
    "15": "of Reflection",
    "16": "of the Twins",
  };
  return itemSuffixes[suffixId] || "";
}

// Function to get item tier from ID
function getItemTier(itemId: number): string {
  // Tier mapping according to loot.cairo and constants.cairo
  // The itemId directly corresponds to the item tiers defined in the contract

  // Item types by tier
  const tierRanges: { [key: string]: number[] } = {
    T1: [
      // Jewelry
      1, 2, 3, 6, 7, 8,
      // Weapons and armor - Per itemId in constants.cairo
      9, 13, 17, 22, 27, 32, 37, 42, 47, 52, 57, 62, 67, 72, 77, 82, 87, 92, 97,
    ],
    T2: [
      // Jewelry
      4,
      // Weapons and armor
      10, 14, 18, 23, 28, 33, 38, 43, 48, 53, 58, 63, 68, 73, 78, 83, 88, 93,
      98,
    ],
    T3: [
      // Jewelry
      5,
      // Weapons and armor
      11, 15, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64, 69, 74, 79, 84, 89, 94,
      99,
    ],
    T4: [
      // Higher tier items
      20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100,
    ],
    T5: [
      // Lowest tier items
      12, 16, 21, 26, 31, 36, 41, 46, 51, 56, 61, 66, 71, 76, 81, 86, 91, 96,
      101,
    ],
  };

  // Check each tier
  for (const [tier, ids] of Object.entries(tierRanges)) {
    if (ids.includes(itemId)) {
      return tier;
    }
  }

  // Default if not found
  console.log(`[WARNING] Could not determine tier for item ID: ${itemId}`);
  return "Unknown";
}

// Function to get price based on tier and charisma
function getItemPrice(tier: string, charisma: number = 0): number {
  // Formula: 4 * (6 - tier_number) - charisma
  // With a minimum price of 1 gold
  const TIER_PRICE = 4; // Base multiplier
  const MIN_PRICE = 1; // Minimum item price

  let tierNumber = 0;
  switch (tier) {
    case "T1":
      tierNumber = 1;
      break;
    case "T2":
      tierNumber = 2;
      break;
    case "T3":
      tierNumber = 3;
      break;
    case "T4":
      tierNumber = 4;
      break;
    case "T5":
      tierNumber = 5;
      break;
    default:
      tierNumber = 0;
      break;
  }

  // Calculate price using the formula and apply minimum price
  const price = Math.max(TIER_PRICE * (6 - tierNumber) - charisma, MIN_PRICE);
  return price;
}

// Function to get potion price based on level and charisma
function getPotionPrice(level: number, charisma: number = 0): number {
  // Formula: level - (2 * charisma)
  // With a minimum price of 1 gold
  const MIN_PRICE = 1;
  const CHARISMA_DISCOUNT = 2;

  const price = Math.max(level - CHARISMA_DISCOUNT * charisma, MIN_PRICE);
  return price;
}

/**
 * Game constants for item greatness levels
 */
const SUFFIX_UNLOCK_GREATNESS = 15;
const PREFIXES_UNLOCK_GREATNESS = 19;

/**
 * Calculates item greatness level from XP value
 * Uses the same formula as adventurer level: sqrt(xp)
 * @param xp - The item's XP value
 */
function calculateGreatness(xp: number): number {
  return Math.floor(Math.sqrt(xp));
}

/**
 * Determines if an item has enough greatness to get a suffix
 * @param greatness - The item's greatness level
 */
function canHaveSuffix(greatness: number): boolean {
  return greatness >= SUFFIX_UNLOCK_GREATNESS;
}

/**
 * Determines if an item has enough greatness to get prefixes
 * @param greatness - The item's greatness level
 */
function canHavePrefixes(greatness: number): boolean {
  return greatness >= PREFIXES_UNLOCK_GREATNESS;
}

// Function to get item type from ID
function getItemType(itemId: number): string {
  // Based on ItemUtils in utils.cairo
  // Necklace: items 1-3 (Pendant, Necklace, Amulet)
  if (itemId >= 1 && itemId <= 3) {
    return "Necklace";
  }
  // Ring: items 4-8 (Silver Ring, Bronze Ring, Platinum Ring, Titanium Ring, Gold Ring)
  else if (itemId >= 4 && itemId <= 8) {
    return "Ring";
  }
  // Magic/Cloth: items 9-41
  // Ghost Wand through Gloves
  else if (itemId >= 9 && itemId <= 41) {
    return "Magic/Cloth";
  }
  // Blade/Hide: items 42-71
  // Katana through Leather Gloves
  else if (itemId >= 42 && itemId <= 71) {
    return "Blade/Hide";
  }
  // Bludgeon/Metal: items 72-101
  // Warhammer through Heavy Gloves
  else if (itemId >= 72 && itemId <= 101) {
    return "Bludgeon/Metal";
  }
  return "Unknown";
}

/**
 * Gets a formatted item name with special properties based on its greatness level
 * @param itemId - The base item ID
 * @param xp - The item's XP value
 * @param special1 - The item's suffix ID (e.g., "of Power")
 * @param special2 - The item's prefix1 ID (e.g., "Agony")
 * @param special3 - The item's prefix2 ID (e.g., "Bane")
 */
function getFullItemName(
  itemId: number,
  xp: number,
  special1?: string,
  special2?: string,
  special3?: string
): string {
  // Get the base item name
  const baseName = ITEM_NAMES[itemId - 1] || `Unknown (${itemId})`;

  // Get the item type
  const itemType = getItemType(itemId);

  // Calculate greatness level from XP
  const greatness = calculateGreatness(xp);

  // Start with the base name
  let fullName = baseName;

  // Add suffix if greatness is high enough
  if (canHaveSuffix(greatness) && special1 && parseInt(special1) > 0) {
    fullName += " " + getItemSuffix(special1);
  }

  // Add prefixes if greatness is high enough
  if (canHavePrefixes(greatness)) {
    // Add prefix1 (e.g., "Agony")
    if (special2 && parseInt(special2) > 0) {
      fullName = getPrefix1(special2) + " " + fullName;
    }

    // Add prefix2 (e.g., "Bane")
    if (special3 && parseInt(special3) > 0) {
      fullName += " " + getPrefix2(special3);
    }
  }

  // Add item type to the name
  fullName += ` [${itemType}]`;

  return fullName;
}

// Function to parse adventurer data from Starknet response
function parseAdventurerData(adventurerResult: any): {
  health: string;
  xp: string;
  gold: string;
  beast_health: string;
  stat_upgrades_available: string;
  stats: {
    strength: string;
    dexterity: string;
    vitality: string;
    intelligence: string;
    wisdom: string;
    charisma: string;
    luck: string;
  };
  equipment: {
    weapon: { id: string; xp: string };
    chest: { id: string; xp: string };
    head: { id: string; xp: string };
    waist: { id: string; xp: string };
    foot: { id: string; xp: string };
    hand: { id: string; xp: string };
    neck: { id: string; xp: string };
    ring: { id: string; xp: string };
  };
  battle_action_count: string;
} {
  if (!adventurerResult || !Array.isArray(adventurerResult)) {
    console.error(`[ERROR] Invalid adventurer data format:`, adventurerResult);
    return {
      health: "0",
      xp: "0",
      gold: "0",
      beast_health: "0",
      stat_upgrades_available: "0",
      stats: {
        strength: "0",
        dexterity: "0",
        vitality: "0",
        intelligence: "0",
        wisdom: "0",
        charisma: "0",
        luck: "0",
      },
      equipment: {
        weapon: { id: "0", xp: "0" },
        chest: { id: "0", xp: "0" },
        head: { id: "0", xp: "0" },
        waist: { id: "0", xp: "0" },
        foot: { id: "0", xp: "0" },
        hand: { id: "0", xp: "0" },
        neck: { id: "0", xp: "0" },
        ring: { id: "0", xp: "0" },
      },
      battle_action_count: "0",
    };
  }

  try {
    // Debug log the raw data to better understand it
    console.log(`[DEBUG] Parsing adventurer data with ${adventurerResult.length} fields:`, adventurerResult);

    // Based on the Adventurer struct in the contract
    const health = hexToDec(adventurerResult[0]);
    const xp = hexToDec(adventurerResult[1]);
    const gold = hexToDec(adventurerResult[2]);
    const beast_health = hexToDec(adventurerResult[3]);
    const stat_upgrades_available = hexToDec(adventurerResult[4]);

    // Stats struct (fields 5-11)
    const stats = {
      strength: hexToDec(adventurerResult[5]),
      dexterity: hexToDec(adventurerResult[6]),
      vitality: hexToDec(adventurerResult[7]),
      intelligence: hexToDec(adventurerResult[8]),
      wisdom: hexToDec(adventurerResult[9]),
      charisma: hexToDec(adventurerResult[10]),
      luck: hexToDec(adventurerResult[11]),
    };

    // Equipment struct - each item has an ID and XP
    // The structure follows the Equipment struct in the contract
    const equipment = {
      weapon: {
        id: hexToDec(adventurerResult[12]),
        xp: hexToDec(adventurerResult[13]),
      },
      chest: {
        id: hexToDec(adventurerResult[14]),
        xp: hexToDec(adventurerResult[15]),
      },
      head: {
        id: hexToDec(adventurerResult[16]),
        xp: hexToDec(adventurerResult[17]),
      },
      waist: {
        id: hexToDec(adventurerResult[18]),
        xp: hexToDec(adventurerResult[19]),
      },
      foot: {
        id: hexToDec(adventurerResult[20]),
        xp: hexToDec(adventurerResult[21]),
      },
      hand: {
        id: hexToDec(adventurerResult[22]),
        xp: hexToDec(adventurerResult[23]),
      },
      neck: {
        id: hexToDec(adventurerResult[24]),
        xp: hexToDec(adventurerResult[25]),
      },
      ring: {
        id: hexToDec(adventurerResult[26]),
        xp: hexToDec(adventurerResult[27]),
      },
    };

    // Battle action count
    const battle_action_count = adventurerResult.length > 28 ? hexToDec(adventurerResult[28]) : "0";

    // Debug log the parsed data
    console.log(`[DEBUG] Parsed adventurer data:`, {
      health,
      xp,
      gold,
      beast_health,
      stat_upgrades_available,
      stats,
      equipment,
      battle_action_count
    });

    return {
      health,
      xp,
      gold,
      beast_health,
      stat_upgrades_available,
      stats,
      equipment,
      battle_action_count,
    };
  } catch (error) {
    console.error(`[ERROR] Failed to parse adventurer data: ${error}`);
    console.error(`[ERROR] Raw data:`, adventurerResult);
    return {
      health: "0",
      xp: "0",
      gold: "0",
      beast_health: "0",
      stat_upgrades_available: "0",
      stats: {
        strength: "0",
        dexterity: "0",
        vitality: "0",
        intelligence: "0",
        wisdom: "0",
        charisma: "0",
        luck: "0",
      },
      equipment: {
        weapon: { id: "0", xp: "0" },
        chest: { id: "0", xp: "0" },
        head: { id: "0", xp: "0" },
        waist: { id: "0", xp: "0" },
        foot: { id: "0", xp: "0" },
        hand: { id: "0", xp: "0" },
        neck: { id: "0", xp: "0" },
        ring: { id: "0", xp: "0" },
      },
      battle_action_count: "0",
    };
  }
}

// Function to parse beast data from Starknet response
function parseBeastData(beastResult: any): {
  id: string;
  starting_health: string;
  combat_spec: {
    tier: string;
    item_type: string;
    level: string;
    specials: {
      special1: string;
      special2: string;
      special3: string;
    };
  };
} {
  if (!beastResult || !Array.isArray(beastResult)) {
    return {
      id: "0",
      starting_health: "0",
      combat_spec: {
        tier: "0",
        item_type: "0",
        level: "0",
        specials: {
          special1: "0",
          special2: "0",
          special3: "0",
        },
      },
    };
  }

  try {
    // Beast struct has:
    // 1. id (u8)
    // 2. starting_health (u16)
    // 3. combat_spec (CombatSpec)
    //    - tier (Tier)
    //    - item_type (Type)
    //    - level (u16)
    //    - specials (SpecialPowers)
    //      - special1, special2, special3 (u8)

    const id = hexToDec(beastResult[0]);
    const starting_health = hexToDec(beastResult[1]);

    // CombatSpec structure
    const tier = hexToDec(beastResult[2]);
    const item_type = hexToDec(beastResult[3]);
    const level = hexToDec(beastResult[4]);

    // Specials sub-structure
    const special1 = hexToDec(beastResult[5]);
    const special2 = hexToDec(beastResult[6]);
    const special3 = hexToDec(beastResult[7]);

    return {
      id,
      starting_health,
      combat_spec: {
        tier,
        item_type,
        level,
        specials: {
          special1,
          special2,
          special3,
        },
      },
    };
  } catch (error) {
    console.error(`[ERROR] Failed to parse beast data: ${error}`);
    return {
      id: "0",
      starting_health: "0",
      combat_spec: {
        tier: "0",
        item_type: "0",
        level: "0",
        specials: {
          special1: "0",
          special2: "0",
          special3: "0",
        },
      },
    };
  }
}

// Function to map beast type to readable string
function getBeastType(typeId: string): string {
  const types: { [key: string]: string } = {
    "0": "None",
    "1": "Magic/Cloth",
    "2": "Blade/Hide",
    "3": "Bludgeon/Metal",
    "4": "Necklace",
    "5": "Ring",
  };
  return types[typeId] || `Type ${typeId}`;
}

// Function to map beast tier to readable string
function getBeastTier(tierId: string): string {
  const tiers: { [key: string]: string } = {
    "0": "None",
    "1": "T1",
    "2": "T2",
    "3": "T3",
    "4": "T4",
    "5": "T5",
  };
  return tiers[tierId] || `Tier ${tierId}`;
}

// Function to map beast ID to proper name
function getBeastName(beastId: string): string {
  const beastNames: { [key: string]: string } = {
    "0": "None",
    "1": "Warlock",
    "2": "Typhon",
    "3": "Jiangshi",
    "4": "Anansi",
    "5": "Basilisk",
    "6": "Gorgon",
    "7": "Kitsune",
    "8": "Lich",
    "9": "Chimera",
    "10": "Wendigo",
    "11": "Rakshasa",
    "12": "Werewolf",
    "13": "Banshee",
    "14": "Draugr",
    "15": "Vampire",
    "16": "Goblin",
    "17": "Ghoul",
    "18": "Wraith",
    "19": "Sprite",
    "20": "Kappa",
    "21": "Fairy",
    "22": "Leprechaun",
    "23": "Kelpie",
    "24": "Pixie",
    "25": "Gnome",
    "26": "Griffin",
    "27": "Manticore",
    "28": "Phoenix",
    "29": "Dragon",
    "30": "Minotaur",
    "31": "Qilin",
    "32": "Ammit",
    "33": "Nue",
    "34": "Skinwalker",
    "35": "Chupacabra",
    "36": "Weretiger",
    "37": "Wyvern",
    "38": "Roc",
    "39": "Harpy",
    "40": "Pegasus",
    "41": "Hippogriff",
    "42": "Fenrir",
    "43": "Jaguar",
    "44": "Satori",
    "45": "Dire Wolf",
    "46": "Bear",
    "47": "Wolf",
    "48": "Mantis",
    "49": "Spider",
    "50": "Rat",
    "51": "Kraken",
    "52": "Colossus",
    "53": "Balrog",
    "54": "Leviathan",
    "55": "Tarrasque",
    "56": "Titan",
    "57": "Nephilim",
    "58": "Behemoth",
    "59": "Hydra",
    "60": "Juggernaut",
    "61": "Oni",
    "62": "Jotunn",
    "63": "Ettin",
    "64": "Cyclops",
    "65": "Giant",
    "66": "Nemean Lion",
    "67": "Berserker",
    "68": "Yeti",
    "69": "Golem",
    "70": "Ent",
    "71": "Troll",
    "72": "Bigfoot",
    "73": "Ogre",
    "74": "Orc",
    "75": "Skeleton",
  };
  return beastNames[beastId] || `Beast #${beastId}`;
}

async function getAdventurerState(
  contractAddress: string,
  adventurerId: string
): Promise<LootSurvivorState | null> {
  try {
    console.log(
      `[STARKNET] Calling get_adventurer function for ID: ${adventurerId}`
    );

    const adventurerResult = await starknet.read({
      contractAddress,
      entrypoint: "get_adventurer",
      calldata: [adventurerId],
    });

    console.log(
      `[STARKNET] Raw adventurer result:`,
      JSON.stringify(adventurerResult)
    );

    if (!adventurerResult || adventurerResult.message) {
      console.error(
        `[ERROR] Failed to get adventurer: ${adventurerResult?.message || "Unknown error"}`
      );
      return null;
    }

    // Parse adventurer data
    const adventurerData = parseAdventurerData(
      adventurerResult.result || adventurerResult
    );

    console.log(`[DEBUG] Adventurer data after parsing:`, adventurerData);

    // Calculate level
    const xpNumber = parseInt(adventurerData.xp);
    const level = Math.floor(Math.sqrt(xpNumber));

    // Check if in battle
    const inBattle = parseInt(adventurerData.beast_health) > 0;

    // Map item IDs to names
    const getItemName = (
      item: { id: string; xp: string },
      special1?: string,
      special2?: string,
      special3?: string
    ): string => {
      const itemId = parseInt(item.id);
      if (itemId <= 0) {
        return "None";
      }

      // Get XP value
      const xp = item.xp ? parseInt(item.xp) : 0;

      // Use our helper function to get the full name with special properties
      return getFullItemName(itemId, xp, special1, special2, special3);
    };

    // Calculate max health based on game constants
    const baseHealth = 100; // STARTING_HEALTH from constants
    const vitalityBonus = parseInt(adventurerData.stats.vitality) * 15; // HEALTH_INCREASE_PER_VITALITY is 15
    const maxHealth = Math.min(baseHealth + vitalityBonus, 1023); // MAX_ADVENTURER_HEALTH is 1023

    // Create state object
    const state: LootSurvivorState = {
      adventurerId,
      adventurerHealth: adventurerData.health,
      adventurerMaxHealth: maxHealth.toString(), // Correctly calculated max health
      level: level.toString(),
      xp: adventurerData.xp,
      gold: adventurerData.gold,
      statUpgrades: adventurerData.stat_upgrades_available,

      // Stats
      strength: adventurerData.stats.strength,
      dexterity: adventurerData.stats.dexterity,
      vitality: adventurerData.stats.vitality,
      intelligence: adventurerData.stats.intelligence,
      wisdom: adventurerData.stats.wisdom,
      charisma: adventurerData.stats.charisma,
      luck: adventurerData.stats.luck,

      // Equipment
      weapon: getItemName(
        adventurerData.equipment.weapon,
        adventurerData.equipment.weapon.xp &&
          parseInt(adventurerData.equipment.weapon.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.weapon.xp &&
          parseInt(adventurerData.equipment.weapon.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.weapon.xp &&
          parseInt(adventurerData.equipment.weapon.xp) >= 19
          ? "1"
          : undefined
      ),
      chest: getItemName(
        adventurerData.equipment.chest,
        adventurerData.equipment.chest.xp &&
          parseInt(adventurerData.equipment.chest.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.chest.xp &&
          parseInt(adventurerData.equipment.chest.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.chest.xp &&
          parseInt(adventurerData.equipment.chest.xp) >= 19
          ? "1"
          : undefined
      ),
      head: getItemName(
        adventurerData.equipment.head,
        adventurerData.equipment.head.xp &&
          parseInt(adventurerData.equipment.head.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.head.xp &&
          parseInt(adventurerData.equipment.head.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.head.xp &&
          parseInt(adventurerData.equipment.head.xp) >= 19
          ? "1"
          : undefined
      ),
      waist: getItemName(
        adventurerData.equipment.waist,
        adventurerData.equipment.waist.xp &&
          parseInt(adventurerData.equipment.waist.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.waist.xp &&
          parseInt(adventurerData.equipment.waist.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.waist.xp &&
          parseInt(adventurerData.equipment.waist.xp) >= 19
          ? "1"
          : undefined
      ),
      foot: getItemName(
        adventurerData.equipment.foot,
        adventurerData.equipment.foot.xp &&
          parseInt(adventurerData.equipment.foot.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.foot.xp &&
          parseInt(adventurerData.equipment.foot.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.foot.xp &&
          parseInt(adventurerData.equipment.foot.xp) >= 19
          ? "1"
          : undefined
      ),
      hand: getItemName(
        adventurerData.equipment.hand,
        adventurerData.equipment.hand.xp &&
          parseInt(adventurerData.equipment.hand.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.hand.xp &&
          parseInt(adventurerData.equipment.hand.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.hand.xp &&
          parseInt(adventurerData.equipment.hand.xp) >= 19
          ? "1"
          : undefined
      ),
      neck: getItemName(
        adventurerData.equipment.neck,
        adventurerData.equipment.neck.xp &&
          parseInt(adventurerData.equipment.neck.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.neck.xp &&
          parseInt(adventurerData.equipment.neck.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.neck.xp &&
          parseInt(adventurerData.equipment.neck.xp) >= 19
          ? "1"
          : undefined
      ),
      ring: getItemName(
        adventurerData.equipment.ring,
        adventurerData.equipment.ring.xp &&
          parseInt(adventurerData.equipment.ring.xp) >= 15
          ? "1"
          : undefined,
        adventurerData.equipment.ring.xp &&
          parseInt(adventurerData.equipment.ring.xp) >= 19
          ? "1"
          : undefined,
        adventurerData.equipment.ring.xp &&
          parseInt(adventurerData.equipment.ring.xp) >= 19
          ? "1"
          : undefined
      ),

      // Equipment XP (greatness levels)
      weaponXP: adventurerData.equipment.weapon.xp,
      chestXP: adventurerData.equipment.chest.xp,
      headXP: adventurerData.equipment.head.xp,
      waistXP: adventurerData.equipment.waist.xp,
      footXP: adventurerData.equipment.foot.xp,
      handXP: adventurerData.equipment.hand.xp,
      neckXP: adventurerData.equipment.neck.xp,
      ringXP: adventurerData.equipment.ring.xp,

      // Beast info
      currentBeast: "None",
      beastHealth: adventurerData.beast_health,
      beastMaxHealth: "0",
      beastLevel: "0",
      beastTier: "0",
      beastType: "0",
      beastSpecial1: "None",
      beastSpecial2: "None",
      beastSpecial3: "None",

      // Battle state
      inBattle: inBattle ? "true" : "false",
      lastAction: "None",
      lastDamageDealt: "0",
      lastDamageTaken: "0",
      lastCritical: "false",
      battleActionCount: adventurerData.battle_action_count,

      // Bag/Inventory
      bagItems: [],

      // Market - Initialize as empty array
      marketItems: [],
    };

    console.log(`[DEBUG] Created initial state:`, {
      adventurerId: state.adventurerId,
      health: state.adventurerHealth,
      maxHealth: state.adventurerMaxHealth,
      level: state.level,
      xp: state.xp,
      gold: state.gold,
      inBattle: state.inBattle,
      stats: {
        strength: state.strength,
        dexterity: state.dexterity,
        vitality: state.vitality,
        intelligence: state.intelligence,
        wisdom: state.wisdom,
        charisma: state.charisma,
        luck: state.luck,
      },
      upgrades: state.statUpgrades,
    });

    // If in battle, get beast details
    if (inBattle) {
      try {
        console.log(`[STARKNET] Calling get_attacking_beast function`);
        const beastResult = await starknet.read({
          contractAddress: GAME_CONTRACT_ADDRESS,
          entrypoint: "get_attacking_beast",
          calldata: [adventurerId],
        });

        console.log(
          `[STARKNET] Raw beast result:`,
          JSON.stringify(beastResult)
        );

        if (beastResult && !beastResult.message) {
          const beastData = parseBeastData(beastResult.result || beastResult);

          state.currentBeast = getBeastName(beastData.id);
          state.beastMaxHealth = beastData.starting_health;
          state.beastLevel = beastData.combat_spec.level;
          state.beastTier = getBeastTier(beastData.combat_spec.tier);
          state.beastType = getBeastType(beastData.combat_spec.item_type);

          // Get formatted special properties for display
          const special1 = beastData.combat_spec.specials.special1;
          const special2 = beastData.combat_spec.specials.special2;
          const special3 = beastData.combat_spec.specials.special3;

          // Format special1 (item suffix like "of Power")
          state.beastSpecial1 =
            parseInt(special1) > 0 ? getItemSuffix(special1) : "None";

          // Format special2 (prefix1 like "Agony")
          state.beastSpecial2 =
            parseInt(special2) > 0 ? getPrefix1(special2) : "None";

          // Format special3 (prefix2 like "Bane")
          state.beastSpecial3 =
            parseInt(special3) > 0 ? getPrefix2(special3) : "None";
        }
      } catch (beastError) {
        console.log(
          `[STARKNET] Could not retrieve beast details: ${beastError}`
        );
      }
    }

    // Try to get bag items
    try {
      console.log(`[STARKNET] Calling get_bag function`);
      const bagResult = await starknet.read({
        contractAddress,
        entrypoint: "get_bag",
        calldata: [adventurerId],
      });

      console.log(`[STARKNET] Raw bag result:`, JSON.stringify(bagResult));

      if (bagResult && !bagResult.message && (bagResult.result || bagResult)) {
        const rawBag = bagResult.result || bagResult;
        state.bagItems = [];

        // The bag in the contract is a struct with 15 items
        // Each item has id and xp fields
        for (let i = 0; i < 15; i++) {
          // In the array response, items are consecutive
          // item1.id, item1.xp, item2.id, item2.xp, ...
          const itemIdIndex = i * 2; // ID at even indices
          const itemXpIndex = i * 2 + 1; // XP at odd indices

          if (itemIdIndex < rawBag.length && rawBag[itemIdIndex] !== "0x0") {
            const itemId = hexToDec(rawBag[itemIdIndex]);
            if (itemId !== "0") {
              const itemName = getItemName({ id: itemId.toString(), xp: "0" });
              state.bagItems.push(itemName);
            }
          }
        }
      }
    } catch (bagError) {
      console.log(`[STARKNET] Could not retrieve bag items: ${bagError}`);
      // Initialize empty bag array if we couldn't fetch it
      state.bagItems = [];
    }

    // Always try to get market items, especially if there are stat upgrades available
    try {
      console.log(`[STARKNET] Calling get_market function`);
      const marketResult = await starknet.read({
        contractAddress: GAME_CONTRACT_ADDRESS,
        entrypoint: "get_market",
        calldata: [adventurerId],
      });

      console.log(
        `[STARKNET] Raw market result:`,
        JSON.stringify(marketResult)
      );

      if (
        marketResult &&
        !marketResult.message &&
        (marketResult.result || marketResult)
      ) {
        const rawMarket = marketResult.result || marketResult;
        state.marketItems = [];

        // Log the raw market for further debugging
        console.log(
          `[MARKET] Raw market data (${rawMarket.length} items):`,
          rawMarket
        );

        // Process each market item ID
        // The data appears to be a flattened array of item IDs
        for (let i = 0; i < rawMarket.length; i++) {
          const itemId = hexToDec(rawMarket[i]);
          if (itemId !== "0") {
            const itemName = getItemName({ id: itemId.toString(), xp: "0" });
            const tier = getItemTier(parseInt(itemId));
            // Apply charisma discount to price
            const price = getItemPrice(
              tier,
              parseInt(adventurerData.stats.charisma)
            );

            state.marketItems.push({
              id: itemId.toString(),
              name: itemName,
              price: price.toString(),
            });

            // Debug log
            console.log(
              `[MARKET] Added item: ${itemName} (ID: ${itemId}, Tier: ${tier}, Price: ${price} gold, with CHA discount)`
            );
          }
        }

        // Log total market items
        console.log(
          `[MARKET] Total items available: ${state.marketItems.length}`
        );
      } else {
        // Initialize as empty array if market fetch failed
        state.marketItems = [];
        console.log(
          `[MARKET] Could not retrieve market items or market is not available yet.`
        );
      }
    } catch (marketError) {
      console.log(`[STARKNET] Could not retrieve market items: ${marketError}`);
      // Initialize as empty array if we couldn't fetch it
      state.marketItems = [];
    }

    // Log the final complete state for debugging
    console.log(`[DEBUG] Final complete state created for adventurer ${adventurerId}`);
    // Print the complete state to the console
    printGameState(state);

    return state;
  } catch (error) {
    console.error(`[ERROR] Failed to get adventurer state: ${error}`);
    return null;
  }
}

// Function to print the current game state to console
function printGameState(state: LootSurvivorState) {
  console.log("\n=== GAME STATE ===");
  console.log(
    `Adventurer: ID ${state.adventurerId} | Health: ${state.adventurerHealth}/${state.adventurerMaxHealth}`
  );
  console.log(`Level: ${state.level} | XP: ${state.xp} | Gold: ${state.gold}`);
  console.log(`Battle Actions: ${state.battleActionCount}`);

  console.log("\n=== STATS ===");
  console.log(
    `STR: ${state.strength} | DEX: ${state.dexterity} | VIT: ${state.vitality}`
  );
  console.log(
    `INT: ${state.intelligence} | WIS: ${state.wisdom} | CHA: ${state.charisma} | LCK: ${state.luck}`
  );
  console.log(`Available Upgrades: ${state.statUpgrades}`);

  console.log("\n=== EQUIPMENT ===");
  console.log(
    `Weapon: ${state.weapon}${state.weaponXP ? ` (Greatness: ${calculateGreatness(parseInt(state.weaponXP))}, XP: ${state.weaponXP})` : ""}`
  );
  console.log(
    `Chest: ${state.chest}${state.chestXP ? ` (Greatness: ${calculateGreatness(parseInt(state.chestXP))}, XP: ${state.chestXP})` : ""}`
  );
  console.log(
    `Head: ${state.head}${state.headXP ? ` (Greatness: ${calculateGreatness(parseInt(state.headXP))}, XP: ${state.headXP})` : ""}`
  );
  console.log(
    `Waist: ${state.waist}${state.waistXP ? ` (Greatness: ${calculateGreatness(parseInt(state.waistXP))}, XP: ${state.waistXP})` : ""}`
  );
  console.log(
    `Foot: ${state.foot}${state.footXP ? ` (Greatness: ${calculateGreatness(parseInt(state.footXP))}, XP: ${state.footXP})` : ""}`
  );
  console.log(
    `Hand: ${state.hand}${state.handXP ? ` (Greatness: ${calculateGreatness(parseInt(state.handXP))}, XP: ${state.handXP})` : ""}`
  );
  console.log(
    `Neck: ${state.neck}${state.neckXP ? ` (Greatness: ${calculateGreatness(parseInt(state.neckXP))}, XP: ${state.neckXP})` : ""}`
  );
  console.log(
    `Ring: ${state.ring}${state.ringXP ? ` (Greatness: ${calculateGreatness(parseInt(state.ringXP))}, XP: ${state.ringXP})` : ""}`
  );

  if (state.inBattle === "true") {
    console.log("\n=== BATTLE ===");
    console.log(`Beast: ${state.currentBeast} (Level ${state.beastLevel})`);
    console.log(`Beast Health: ${state.beastHealth}/${state.beastMaxHealth}`);
    console.log(`Beast Tier: ${state.beastTier} | Type: ${state.beastType}`);
    console.log(
      `Specials: ${state.beastSpecial1}, ${state.beastSpecial2}, ${state.beastSpecial3}`
    );
  }

  console.log("\n=== INVENTORY ===");
  console.log(
    `Bag Items: ${state.bagItems.length > 0 ? state.bagItems.join(", ") : "None"}`
  );

  console.log("\n=== MARKET ===");
  // Show potion price first
  const potionPrice = getPotionPrice(
    parseInt(state.level),
    parseInt(state.charisma)
  );
  console.log(`Potion: ${potionPrice} gold (Restores 10 HP)`);

  // Show items grouped by tier
  if (state.marketItems.length > 0) {
    console.log("Available Items:");
    // Group items by tier for better organization
    const itemsByTier: {
      [key: string]: Array<{ name: string; price: string }>;
    } = {};

    state.marketItems.forEach((item) => {
      const tier = getItemTier(parseInt(item.id));
      if (!itemsByTier[tier]) {
        itemsByTier[tier] = [];
      }
      itemsByTier[tier].push({ name: item.name, price: item.price });
    });

    // Display by tier (lowest price first)
    const tierOrder = ["T5", "T4", "T3", "T2", "T1"];

    tierOrder.forEach((tier) => {
      if (itemsByTier[tier] && itemsByTier[tier].length > 0) {
        console.log(`  [${tier}]`);
        itemsByTier[tier].forEach((item) => {
          console.log(`  - ${item.name} (${item.price} gold)`);
        });
      }
    });
  } else {
    console.log("Available Items: None");
  }

  console.log("\n=== LAST ACTION ===");
  console.log(
    `${state.lastAction} | Damage Dealt: ${state.lastDamageDealt} | Damage Taken: ${state.lastDamageTaken}`
  );
  console.log(`Critical Hit: ${state.lastCritical}`);
  console.log("===================\n");
}

// Function to generate a formatted state summary for the agent
function generateStateSummary(state: LootSurvivorState): string {
  return `
Current Adventurer State:
- ID: ${state.adventurerId}
- Health: ${state.adventurerHealth}/${state.adventurerMaxHealth}
- Level: ${state.level} (XP: ${state.xp})
- Gold: ${state.gold}
- In Battle: ${state.inBattle === "true" ? "Yes" : "No"}
${state.inBattle === "true" ? `- Fighting: ${state.currentBeast} (Level ${state.beastLevel})
- Beast Health: ${state.beastHealth}/${state.beastMaxHealth}
- Beast Type: ${state.beastType}` : ''}

Stats:
- Strength: ${state.strength}
- Dexterity: ${state.dexterity}
- Vitality: ${state.vitality}
- Intelligence: ${state.intelligence}
- Wisdom: ${state.wisdom}
- Charisma: ${state.charisma}
- Luck: ${state.luck}
- Available Stat Upgrades: ${state.statUpgrades}

Equipment:
- Weapon: ${state.weapon}
- Chest: ${state.chest}
- Head: ${state.head}
- Waist: ${state.waist}
- Foot: ${state.foot}
- Hand: ${state.hand}
- Neck: ${state.neck}
- Ring: ${state.ring}

Inventory:
- Bag Items: ${Array.isArray(state.bagItems) && state.bagItems.length > 0 ? state.bagItems.join(", ") : "None"}

Market:
- Available Items: ${Array.isArray(state.marketItems) && state.marketItems.length > 0
      ? state.marketItems.map(item => `${item.name} (${item.price} gold)`).join(", ")
      : "None"}

Last Action: ${state.lastAction}
`;
}

// Fix the initializeLootSurvivorMemory function to properly initialize marketItems
export function initializeLootSurvivorMemory(ctx: any): LootSurvivorState {
  if (!ctx.agentMemory) {
    ctx.agentMemory = {
      adventurerId: "0",
      adventurerHealth: "0",
      adventurerMaxHealth: "100", // Update to default base health
      level: "1",
      xp: "0",
      gold: "0",
      statUpgrades: "0",

      strength: "0",
      dexterity: "0",
      vitality: "0",
      intelligence: "0",
      wisdom: "0",
      charisma: "0",
      luck: "0",

      weapon: "None",
      chest: "None",
      head: "None",
      waist: "None",
      foot: "None",
      hand: "None",
      neck: "None",
      ring: "None",

      // Initialize equipment XP fields
      weaponXP: "0",
      chestXP: "0",
      headXP: "0",
      waistXP: "0",
      footXP: "0",
      handXP: "0",
      neckXP: "0",
      ringXP: "0",

      currentBeast: "None",
      beastHealth: "0",
      beastMaxHealth: "0",
      beastLevel: "0",
      beastTier: "0",
      beastType: "0",
      beastSpecial1: "None",
      beastSpecial2: "None",
      beastSpecial3: "None",

      inBattle: "false",
      lastAction: "None",
      lastDamageDealt: "0",
      lastDamageTaken: "0",
      lastCritical: "false",
      battleActionCount: "0",

      bagItems: [],
      marketItems: [], // Ensure this is always initialized as an empty array
    };
  } else {
    // Ensure critical fields are always initialized
    ctx.agentMemory.bagItems = ctx.agentMemory.bagItems || [];
    ctx.agentMemory.marketItems = ctx.agentMemory.marketItems || [];
  }
  return ctx.agentMemory as LootSurvivorState;
}

// Create a centralized game state manager
const gameStateManager = {
  // Current state cache
  currentState: null as LootSurvivorState | null,

  // Last fetch timestamp to avoid excessive refetching
  lastFetchTime: 0,

  // Minimum time between state refreshes (in milliseconds)
  minRefreshInterval: 1000,

  // Initialize state for a given adventurer ID
  async initialize(adventurerId: string): Promise<LootSurvivorState | null> {
    console.log(`[STATE_MANAGER] Initializing state for adventurer: ${adventurerId}`);
    this.currentState = await this._fetchLatestState(adventurerId);
    return this.currentState;
  },

  // Get current state, refreshing if necessary
  async getState(adventurerId: string, forceRefresh = false): Promise<LootSurvivorState | null> {
    const now = Date.now();

    // Check if we need to fetch a fresh state
    if (
      forceRefresh ||
      !this.currentState ||
      this.currentState.adventurerId !== adventurerId ||
      now - this.lastFetchTime > this.minRefreshInterval
    ) {
      console.log(`[STATE_MANAGER] Fetching fresh state for adventurer: ${adventurerId}`);
      this.currentState = await this._fetchLatestState(adventurerId);
      this.lastFetchTime = now;
    }

    return this.currentState;
  },

  // Update state after an action
  async updateAfterAction(
    adventurerId: string,
    actionName: string,
    txHash?: string
  ): Promise<LootSurvivorState | null> {
    // No need to manually wait for transaction confirmation
    // starknet.write() already includes waitForTransaction

    // Always fetch fresh state after an action
    console.log(`[STATE_MANAGER] Updating state after ${actionName}`);
    this.currentState = await this._fetchLatestState(adventurerId);
    this.lastFetchTime = Date.now();

    if (this.currentState) {
      // Update last action if not already set
      if (actionName && this.currentState.lastAction === "None") {
        console.log(`[STATE_MANAGER] Setting last action to: ${actionName}`);
        this.currentState.lastAction = actionName;
      }

      // Print the state for debugging too
      console.log(`[STATE_MANAGER] Updated state details:`, {
        adventurerId: this.currentState.adventurerId,
        health: this.currentState.adventurerHealth,
        maxHealth: this.currentState.adventurerMaxHealth,
        level: this.currentState.level,
        xp: this.currentState.xp,
        gold: this.currentState.gold,
        inBattle: this.currentState.inBattle,
        lastAction: this.currentState.lastAction
      });
    }

    return this.currentState;
  },

  // Apply state to agent memory context
  applyToMemory(ctx: any): LootSurvivorState {
    // Initialize memory first
    const memoryState = initializeLootSurvivorMemory(ctx);

    // Then apply current state if available
    if (this.currentState) {
      // Create a deep copy of important objects to avoid reference issues
      const stateCopy = { ...this.currentState };

      // Copy arrays to avoid reference issues
      if (Array.isArray(this.currentState.bagItems)) {
        stateCopy.bagItems = [...this.currentState.bagItems];
      }

      if (Array.isArray(this.currentState.marketItems)) {
        stateCopy.marketItems = this.currentState.marketItems.map(item => ({ ...item }));
      }

      // Apply the copied state to memory
      Object.assign(memoryState, stateCopy);

      console.log(`[STATE_MANAGER] Applied state to agent memory for adventurer: ${this.currentState.adventurerId}`);
      console.log(`[STATE_MANAGER] Memory state now has:`, {
        adventurerId: memoryState.adventurerId,
        health: memoryState.adventurerHealth,
        maxHealth: memoryState.adventurerMaxHealth,
        level: memoryState.level,
        gold: memoryState.gold,
        inBattle: memoryState.inBattle,
        stats: {
          strength: memoryState.strength,
          dexterity: memoryState.dexterity,
          vitality: memoryState.vitality,
          intelligence: memoryState.intelligence,
          wisdom: memoryState.wisdom,
          charisma: memoryState.charisma,
          luck: memoryState.luck,
        },
        bagItems: Array.isArray(memoryState.bagItems) ? memoryState.bagItems.length : 0,
        marketItems: Array.isArray(memoryState.marketItems) ? memoryState.marketItems.length : 0,
      });
    } else {
      console.warn(`[STATE_MANAGER] No current state to apply to memory`);
    }

    return memoryState;
  },

  // Private method to fetch the latest state
  async _fetchLatestState(adventurerId: string): Promise<LootSurvivorState | null> {
    const state = await getAdventurerState(GAME_CONTRACT_ADDRESS, adventurerId);
    if (!state) {
      console.error(`[STATE_MANAGER] Failed to fetch state for adventurer: ${adventurerId}`);
    }
    return state;
  }
};

// Define item names array based on the ItemString module in constants.cairo
// Items are 1-indexed in the contract, so we'll match that here
const ITEM_NAMES = [
  "Pendant",
  "Necklace",
  "Amulet",
  "Silver Ring",
  "Bronze Ring",
  "Platinum Ring",
  "Titanium Ring",
  "Gold Ring",
  "Ghost Wand",
  "Grave Wand",
  "Bone Wand",
  "Wand",
  "Grimoire",
  "Chronicle",
  "Tome",
  "Book",
  "Divine Robe",
  "Silk Robe",
  "Linen Robe",
  "Robe",
  "Shirt",
  "Crown",
  "Divine Hood",
  "Silk Hood",
  "Linen Hood",
  "Hood",
  "Brightsilk Sash",
  "Silk Sash",
  "Wool Sash",
  "Linen Sash",
  "Sash",
  "Divine Slippers",
  "Silk Slippers",
  "Wool Shoes",
  "Linen Shoes",
  "Shoes",
  "Divine Gloves",
  "Silk Gloves",
  "Wool Gloves",
  "Linen Gloves",
  "Gloves",
  "Katana",
  "Falchion",
  "Scimitar",
  "Long Sword",
  "Short Sword",
  "Demon Husk",
  "Dragonskin Armor",
  "Studded Leather Armor",
  "Hard Leather Armor",
  "Leather Armor",
  "Demon Crown",
  "Dragon's Crown",
  "War Cap",
  "Leather Cap",
  "Cap",
  "Demonhide Belt",
  "Dragonskin Belt",
  "Studded Leather Belt",
  "Hard Leather Belt",
  "Leather Belt",
  "Demonhide Boots",
  "Dragonskin Boots",
  "Studded Leather Boots",
  "Hard Leather Boots",
  "Leather Boots",
  "Demon's Hands",
  "Dragonskin Gloves",
  "Studded Leather Gloves",
  "Hard Leather Gloves",
  "Leather Gloves",
  "Warhammer",
  "Quarterstaff",
  "Maul",
  "Mace",
  "Club",
  "Holy Chestplate",
  "Ornate Chestplate",
  "Plate Mail",
  "Chain Mail",
  "Ring Mail",
  "Ancient Helm",
  "Ornate Helm",
  "Great Helm",
  "Full Helm",
  "Helm",
  "Ornate Belt",
  "War Belt",
  "Plated Belt",
  "Mesh Belt",
  "Heavy Belt",
  "Holy Greaves",
  "Ornate Greaves",
  "Greaves",
  "Chain Boots",
  "Heavy Boots",
  "Holy Gauntlets",
  "Ornate Gauntlets",
  "Gauntlets",
  "Chain Gloves",
  "Heavy Gloves",
];

// Template for the agent's context
export const template = `
You are an expert AI agent playing Loot Survivor, a roguelike dungeon crawler game on Starknet blockchain. Your goal is to progress as far as possible, defeat beasts, collect loot, and upgrade your character to become stronger.

CRITICAL RULES - YOU MUST FOLLOW THESE EXACTLY:
1. If stat_upgrades_available > 0, you MUST use upgradeAdventurer to allocate ALL stat points BEFORE doing anything else.
2. When stat upgrades are available, the market is also available - you can buy items and potions.
3. You CANNOT explore if stat_upgrades_available > 0 - the game mechanics prevent this.
4. If in battle (inBattle = true), you MUST resolve it (attack or flee) before doing any other action.

Game Overview:
- Roguelike dungeon crawler with permadeath (once you die, you need to start over)
- Turn-based combat system with elemental effectiveness mechanics
- Character progression through XP, level-ups, and equipment upgrades
- Resource management (health, gold, items)
- Battle increasingly difficult beasts
- Collect gold and items
- Level up your character
- Manage health and resources
- Make strategic combat decisions
- Track XP for level-up timing

IMPORTANT RULES:
- If stat_upgrades_available is non-zero, you MUST allocate those stat points before exploring
- You can only upgrade stats if you have available stat points (1 point = 1 stat upgrade)
- When stat points are available, the market is also available for purchases
- If in battle, you MUST resolve the battle (attack or flee) before doing anything else
- When confused or stuck, check: Are you in battle? Do you have available stat points?

Combat Mechanics:
- Weapon types: Blade, Bludgeon, and Magic
- Armor materials: Cloth, Hide, and Metal
- Weapon effectiveness:
  - Blade: Weak vs Metal, Fair vs Hide, Strong vs Cloth
  - Bludgeon: Fair vs Metal, Strong vs Hide, Weak vs Cloth
  - Magic: Strong vs Metal, Weak vs Hide, Fair vs Cloth
- Stats affect combat: Strength boosts damage, Vitality increases health, etc.
- Combat calculations:
  - Base damage = Item Greatness * (6 - Tier)
  - Beast damage = Beast Level * (6 - Beast Tier)
  - Final damage = Weapon power - Armor defense
- Critical hits chance = luck / 100
- Critical damage bonus = random(20-100%)

Beast Types:
- Magical Beasts: Weak to Blade weapons, Strong against Metal armor
- Hunter Beasts: Weak to Bludgeon weapons, Strong against Cloth armor
- Brute Beasts: Weak to Magic weapons, Strong against Hide armor
- Beast Tiers affect power: Tier 1 (highest) to Tier 5 (lowest)

Resource Management:
- HP management is critical for survival
- XP gained through successful actions
- Gold for purchasing items and potions
- Potion cost = adventurer_level - (2 * charisma)
- Each potion adds 10HP

Stats System:
- Strength: +10% attack damage
- Vitality: +15HP max and current health
- Dexterity: Better flee chances
- Intelligence: Better obstacle avoidance
- Wisdom: Better ambush evasion
- Charisma: Item/potion discount
- Luck: Critical hit chance (only from items)

Current Game State:
<adventurer_stats>
Adventurer ID: {{adventurerId}}
Health: {{adventurerHealth}}/{{adventurerMaxHealth}}
Level: {{level}}
XP: {{xp}}
Gold: {{gold}}
Battle Actions: {{battleActionCount}}
</adventurer_stats>

<adventurer_attributes>
Strength: {{strength}}
Dexterity: {{dexterity}}
Vitality: {{vitality}}
Intelligence: {{intelligence}}
Wisdom: {{wisdom}}
Charisma: {{charisma}}
Luck: {{luck}}
Available Stat Upgrades: {{statUpgrades}}
</adventurer_attributes>

<equipment>
Weapon: {{weapon}}
Chest: {{chest}}
Head: {{head}}
Waist: {{waist}}
Foot: {{foot}}
Hand: {{hand}}
Neck: {{neck}}
Ring: {{ring}}
</equipment>

<battle_status>
In Battle: {{inBattle}}
Beast: {{currentBeast}}
Beast Health: {{beastHealth}}/{{beastMaxHealth}}
Beast Level: {{beastLevel}}
Beast Tier: {{beastTier}}
Beast Type: {{beastType}}
Beast Specials: {{beastSpecial1}}, {{beastSpecial2}}, {{beastSpecial3}}
Last Action: {{lastAction}}
Last Damage Dealt: {{lastDamageDealt}}
Last Damage Taken: {{lastDamageTaken}}
Critical Hit: {{lastCritical}}
</battle_status>

<inventory>
Bag Items: {{bagItems}}
</inventory>

<market>
Available Items: {{marketItems}}
</market>

Available Actions:
1. Combat Actions:
   - attack(adventurer_id, to_the_death): 
     * Single attack when to_the_death = false
     * Fight until victory/death when to_the_death = true
   - flee(adventurer_id, to_the_death):
     * Single escape attempt when to_the_death = false
     * Keep trying until escape/death when to_the_death = true

2. Exploration Actions:
   - explore(adventurer_id, till_beast):
     * Single exploration when till_beast = false
     * Keep exploring until beast when till_beast = true

3. Inventory Management:
   - equipItems(adventurer_id, items): Equip items from bag
   - upgradeAdventurer(adventurer_id, potions, stats, items):
     * Buy and use potions
     * Upgrade character stats
     * Purchase and optionally equip items

4. Character Management:
   - newGame(starting_weapon, name, character_class): Start new adventure
   - getAdventurerState(adventurer_id): Refresh game state

Strategic Guidelines:
1. ALWAYS check for available stat upgrades first - you MUST allocate them before exploring
2. Prioritize survival - manage your health and know when to flee
3. Choose equipment upgrades that complement your playstyle
4. Be aware of weapon effectiveness against different armor types
5. Upgrade stats strategically - Vitality for health, Strength for damage, etc.
6. Save gold for important purchases rather than buying every item
7. Assess beast difficulty before engaging in combat
8. Use your strongest equipment and keep your bag organized
9. Calculate flee probability: Dexterity / Level
10. Combat assessment: Compare your weapon type vs beast armor type
11. Calculate potion costs vs benefits: Consider potion cost = level - (2 * charisma)
12. Consider strategic fleeing for long-term survival

DECISION MAKING PRIORITY ORDER:
1. If stat_upgrades_available > 0: MUST use upgradeAdventurer to allocate points
2. If in battle (inBattle = true): MUST attack or flee
3. If health is low: Consider buying potions
4. If market has good items: Consider buying equipment
5. Otherwise: Explore to find beasts and loot

Your task is to analyze the current game state and make strategic decisions. Follow these steps:

1. First, check if you have available stat upgrades that MUST be allocated
2. Check if you're in battle that needs immediate resolution
3. Analyze your current stats, health, equipment, and resources
4. Evaluate the current situation (exploring, in battle, shopping)
5. Consider the best action based on the game state
6. Explain your reasoning and decision clearly

Inside your thinking block, use <strategy_planning> tags to show your thought process:

1. Assess your current status and strengths/weaknesses
2. List possible actions and their potential outcomes
3. Weigh risks vs. rewards
4. Choose the optimal action

If you die during gameplay, start a new game immediately and continue playing. If you encounter any errors, ask the user to re-authenticate.

Output Format:
Decision: [Your chosen action]
Explanation: [A clear explanation of your decision and how it fits your strategy]
Next Steps: [Brief outline of your plan for the next few turns]

Remember to constantly adapt your strategy as the game state changes. Your goal is long-term survival and progression.
`;

// Context for the agent
export const goalContexts = context({
  type: "goal",
  schema: z.object({
    id: string(),
    initialGoal: z.string().default("Survive and progress in Loot Survivor"),
    initialTasks: z
      .array(z.string())
      .default([
        "Make strategic decisions",
        "Manage resources",
        "Defeat beasts",
        "Upgrade your adventurer",
        "Collect loot",
        "Explore the world",
        "Shop for items",
        "Sell items",
        "Buy items",
      ]),
  }),

  key() {
    return "1";
  },

  create(_state): LootSurvivorState {
    return {
      adventurerId: "0",
      adventurerHealth: "0",
      adventurerMaxHealth: "100", // Set to base health value
      level: "1",
      xp: "0",
      gold: "0",
      statUpgrades: "0",

      strength: "0",
      dexterity: "0",
      vitality: "0",
      intelligence: "0",
      wisdom: "0",
      charisma: "0",
      luck: "0",

      weapon: "None",
      chest: "None",
      head: "None",
      waist: "None",
      foot: "None",
      hand: "None",
      neck: "None",
      ring: "None",

      // Added equipment XP fields
      weaponXP: "0",
      chestXP: "0",
      headXP: "0",
      waistXP: "0",
      footXP: "0",
      handXP: "0",
      neckXP: "0",
      ringXP: "0",

      currentBeast: "None",
      beastHealth: "0",
      beastMaxHealth: "0",
      beastLevel: "0",
      beastTier: "0",
      beastType: "0",
      beastSpecial1: "None",
      beastSpecial2: "None",
      beastSpecial3: "None",

      inBattle: "false",
      lastAction: "None",
      lastDamageDealt: "0",
      lastDamageTaken: "0",
      lastCritical: "false",
      battleActionCount: "0",

      bagItems: [],
      marketItems: [], // Empty array of {id, name, price}
    };
  },

  render({ memory }) {
    // Add debug logging to see what's in memory before rendering
    console.log(`[RENDER] Starting render with memory:`, {
      adventurerId: memory.adventurerId ?? "0",
      health: memory.adventurerHealth ?? "0",
      maxHealth: memory.adventurerMaxHealth ?? "0",
      level: memory.level ?? "1",
      xp: memory.xp ?? "0",
      gold: memory.gold ?? "0",
      statUpgrades: memory.statUpgrades ?? "0",
      inBattle: memory.inBattle ?? "false",
    });

    // Calculate potion price for the UI
    const potionPrice =
      memory.level && memory.charisma
        ? getPotionPrice(parseInt(memory.level), parseInt(memory.charisma))
        : 1;

    // Debug log to see what's in memory.marketItems
    console.log(`[RENDER] Market items before formatting:`, memory.marketItems);

    // Ensure memory.marketItems is always an array
    const marketItems = Array.isArray(memory.marketItems) ? memory.marketItems : [];

    // Format market items to include potion at the top
    const formattedMarketItems =
      marketItems.length > 0
        ? `Potion: ${potionPrice} gold (Restores 10 HP), ` +
        marketItems
          .map(
            (item: { name: string; price: string }) =>
              `${item.name} (${item.price} gold)`
          )
          .join(", ")
        : `Potion: ${potionPrice} gold (Restores 10 HP)`;

    console.log(`[RENDER] Formatted market items for agent:`, formattedMarketItems);

    // Format bag items for display
    const bagItemsString = Array.isArray(memory.bagItems) && memory.bagItems.length > 0
      ? memory.bagItems.join(", ")
      : "None";

    console.log(`[RENDER] Bag items for agent:`, bagItemsString);

    // Create template parameters
    const templateParams = {
      adventurerId: memory.adventurerId ?? "0",
      adventurerHealth: memory.adventurerHealth ?? "0",
      adventurerMaxHealth: memory.adventurerMaxHealth ?? "0",
      level: memory.level ?? "1",
      xp: memory.xp ?? "0",
      gold: memory.gold ?? "0",
      battleActionCount: memory.battleActionCount ?? "0",

      strength: memory.strength ?? "0",
      dexterity: memory.dexterity ?? "0",
      vitality: memory.vitality ?? "0",
      intelligence: memory.intelligence ?? "0",
      wisdom: memory.wisdom ?? "0",
      charisma: memory.charisma ?? "0",
      luck: memory.luck ?? "0",
      statUpgrades: memory.statUpgrades ?? "0",

      weapon: memory.weapon
        ? `${memory.weapon}${memory.weaponXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.weaponXP))})` : ""}`
        : "None",
      chest: memory.chest
        ? `${memory.chest}${memory.chestXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.chestXP))})` : ""}`
        : "None",
      head: memory.head
        ? `${memory.head}${memory.headXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.headXP))})` : ""}`
        : "None",
      waist: memory.waist
        ? `${memory.waist}${memory.waistXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.waistXP))})` : ""}`
        : "None",
      foot: memory.foot
        ? `${memory.foot}${memory.footXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.footXP))})` : ""}`
        : "None",
      hand: memory.hand
        ? `${memory.hand}${memory.handXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.handXP))})` : ""}`
        : "None",
      neck: memory.neck
        ? `${memory.neck}${memory.neckXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.neckXP))})` : ""}`
        : "None",
      ring: memory.ring
        ? `${memory.ring}${memory.ringXP ? ` (Greatness: ${calculateGreatness(parseInt(memory.ringXP))})` : ""}`
        : "None",

      currentBeast: memory.currentBeast ?? "None",
      beastHealth: memory.beastHealth ?? "0",
      beastMaxHealth: memory.beastMaxHealth ?? "0",
      beastLevel: memory.beastLevel ?? "0",
      beastTier: memory.beastTier ?? "0",
      beastType: memory.beastType ?? "0",
      beastSpecial1: memory.beastSpecial1 ?? "None",
      beastSpecial2: memory.beastSpecial2 ?? "None",
      beastSpecial3: memory.beastSpecial3 ?? "None",

      inBattle: memory.inBattle ?? "false",
      lastAction: memory.lastAction ?? "None",
      lastDamageDealt: memory.lastDamageDealt ?? "0",
      lastDamageTaken: memory.lastDamageTaken ?? "0",
      lastCritical: memory.lastCritical ?? "false",

      bagItems: bagItemsString,
      marketItems: formattedMarketItems,
    };

    // Log the final template parameters for debugging
    console.log(`[RENDER] Rendering template with parameters:`, {
      adventurerId: templateParams.adventurerId,
      health: `${templateParams.adventurerHealth}/${templateParams.adventurerMaxHealth}`,
      level: templateParams.level,
      gold: templateParams.gold,
      inBattle: templateParams.inBattle,
      statUpgrades: templateParams.statUpgrades,
      lastAction: templateParams.lastAction
    });

    return render(template, templateParams as any);
  },
});

// Create the Loot Survivor agent with UI integration
export const lootSurvivor = extension({
  name: "lootSurvivor",
  contexts: {
    goal: goalContexts,
  },
  actions: [
    /**
     * Action to start a new game
     */
    action({
      name: "newGame",
      description: "Start a new game in Loot Survivor",
      schema: z
        .object({
          startingWeapon: z
            .enum(["Wand", "Book", "Club", "ShortSword"])
            .describe(
              "The weapon to start with (Blade, Bludgeon, or Magic type. Wand and Book are magic types.)"
            ),
          name: z.string().describe("The name of your adventurer"),
        })
        .describe("Start a new game with a chosen weapon, and name"),
      async handler(data, ctx: any, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Starting New Game - Weapon: ${data.startingWeapon}, Name: ${data.name}`
          );

          const { startingWeapon, name } = data;

          // Map starting weapon to weapon ID
          const weaponIdMap: Record<string, number> = {
            Club: 76,
            Book: 16,
            Wand: 12,
            ShortSword: 46,
          };

          const weaponId = weaponIdMap[startingWeapon] || 1;

          console.log(`[STARKNET] Calling new_game function on contract`);

          // Updated to match ABI parameters
          const result = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "new_game",
            calldata: [
              env.STARKNET_ADDRESS, // client_reward_address (using our configured address)
              weaponId, // weapon
              Buffer.from(name).toString("hex"), // name
              0, // golden_token_id (default 0)
              0, // delay_reveal (false)
              0, // custom_renderer (0x0 address)
              0, // launch_tournament_winner_token_id (0)
              env.STARKNET_ADDRESS, // mint_to (using our configured address)
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${result.transaction_hash}`
          );

          // Create a new adventurer ID from the transaction hash or result
          const adventurerId = result.transaction_hash || "unknown";

          // Initialize adventurer state through state manager
          console.log(`[NEWGAME] Waiting for transaction and initializing game state`);
          const state = await gameStateManager.updateAfterAction(
            adventurerId,
            "New Game Created",
            result.transaction_hash
          );

          if (!state) {
            return {
              success: false,
              error: "Failed to retrieve adventurer state after creation",
              message: "Failed to start a new game",
            };
          }

          // Apply the state to agent memory
          gameStateManager.applyToMemory(ctx);

          console.log(
            `[ACTION] New Game Created - Adventurer ID: ${state.adventurerId}`
          );

          // Set initial weapon and action in state directly, since blockchain might not reflect it immediately
          if (state) {
            state.weapon = ITEM_NAMES[weaponId - 1] || startingWeapon;
            state.lastAction = "New Game Created";
          }

          return {
            success: true,
            message: `Successfully started a new game with ${startingWeapon} and name ${name}. Your adventurer ID is ${adventurerId}.`,
            adventurerId: adventurerId // Return the ID so the agent can reference it
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to start new game:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to start a new game",
          };
        }
      },
    }),

    /**
     * Action to explore the world
     */
    action({
      name: "explore",
      description: "Explore the world to find beasts, obstacles, or treasures",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
          tillBeast: z
            .boolean()
            .default(false)
            .describe(
              "Whether to explore until finding a beast (true) or just once (false)"
            ),
        })
        .describe(
          "Explore the world to discover beasts, obstacles, or treasures"
        ),
      async handler(data, ctx: any, _agent: Agent) {
        try {
          // Get current state through the state manager
          const currentState = await gameStateManager.getState(data.adventurerId);

          // Check if there are any stat upgrades available - if so, reject the action
          if (currentState && parseInt(currentState.statUpgrades) > 0) {
            console.log("[ACTION] Rejecting explore - stat upgrades available:", currentState.statUpgrades);
            return {
              success: false,
              error: "Cannot explore when stat upgrades are available",
              message: "You must allocate all available stat points before exploring. Use upgradeAdventurer action first.",
            };
          }

          console.log(
            `[ACTION] Exploring - Adventurer ID: ${data.adventurerId}, Till Beast: ${data.tillBeast}`
          );

          const { adventurerId, tillBeast } = data;

          // Store initial state to compare later
          const initialState = currentState ? { ...currentState } : null;

          // Use Starknet to call explore function
          console.log(`[STARKNET] Calling explore function on contract`);
          const exploreResult = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "explore",
            calldata: [
              adventurerId,
              tillBeast ? 1 : 0, // Convert boolean to 0/1
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${exploreResult.transaction_hash}`
          );

          // Update state through the state manager
          const updatedState = await gameStateManager.updateAfterAction(
            adventurerId,
            "Exploring",
            exploreResult.transaction_hash
          );

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve updated adventurer state",
              message: "Failed to explore: could not get updated adventurer state",
            };
          }

          // Determine what happened during exploration by comparing before/after states
          let actionDescription = "Explored area";

          // Check for beast encounter
          if (updatedState.inBattle === "true") {
            actionDescription = "Discovered Beast";
            console.log(
              `[ENCOUNTER] Found Beast: ${updatedState.currentBeast || "Unknown"} (Level ${updatedState.beastLevel || "Unknown"})`
            );
          }
          // Check for health decrease (obstacle)
          else if (
            initialState &&
            parseInt(updatedState.adventurerHealth) < parseInt(initialState.adventurerHealth || "0")
          ) {
            const damageTaken =
              parseInt(initialState.adventurerHealth || "0") -
              parseInt(updatedState.adventurerHealth);
            actionDescription = `Encountered Obstacle (-${damageTaken} HP)`;
            updatedState.lastDamageTaken = damageTaken.toString();
            console.log(`[ENCOUNTER] Obstacle: Took ${damageTaken} damage`);
          }
          // Check for gold increase (discovery)
          else if (
            initialState &&
            parseInt(updatedState.gold) > parseInt(initialState.gold || "0")
          ) {
            const goldFound =
              parseInt(updatedState.gold) - parseInt(initialState.gold || "0");
            actionDescription = `Found ${goldFound} Gold`;
            console.log(`[DISCOVERY] Found ${goldFound} Gold`);
          }
          // Check if health increased (health discovery)
          else if (
            initialState &&
            parseInt(updatedState.adventurerHealth) > parseInt(initialState.adventurerHealth || "0")
          ) {
            const healthFound =
              parseInt(updatedState.adventurerHealth) -
              parseInt(initialState.adventurerHealth || "0");
            actionDescription = `Found ${healthFound} Health`;
            console.log(`[DISCOVERY] Found ${healthFound} Health`);
          }
          // Check if bag items count changed (item discovery)
          else if (
            initialState &&
            Array.isArray(initialState.bagItems) &&
            Array.isArray(updatedState.bagItems) &&
            updatedState.bagItems.length > initialState.bagItems.length
          ) {
            // Find the new item by comparing arrays
            const newItems = updatedState.bagItems.filter(
              (item: string) => !initialState.bagItems.includes(item)
            );
            if (newItems.length > 0) {
              actionDescription = `Found Item: ${newItems[0]}`;
              console.log(`[DISCOVERY] Found Item: ${newItems[0]}`);
            } else {
              actionDescription = "Found an Item";
              console.log(`[DISCOVERY] Found an item`);
            }
          }
          // Nothing interesting happened
          else {
            actionDescription = "Explored area, found nothing";
            console.log(`[EXPLORATION] Found nothing of interest`);
          }

          // Update last action in state
          updatedState.lastAction = actionDescription;

          // Check if level up occurred
          if (
            initialState &&
            parseInt(updatedState.statUpgrades) > parseInt(initialState.statUpgrades || "0")
          ) {
            console.log(`[LEVEL UP] Gained stat points! Available: ${updatedState.statUpgrades}`);
          }

          // Apply updated state to agent memory
          gameStateManager.applyToMemory(ctx);

          // Update the return statement in the explore handler
          console.log(`[ACTION] Exploration Complete - ${actionDescription}`);

          const stateSummary = generateStateSummary(updatedState);
          console.log(`[EXPLORE] Sending state summary to agent`);

          return {
            success: true,
            message: `${actionDescription}\n\n${stateSummary}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to explore:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to explore",
          };
        }
      },
    }),

    /**
     * Action to attack a beast
     */
    action({
      name: "attackBeast",
      description: "Attack the beast you're currently facing",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
          toTheDeath: z
            .boolean()
            .default(false)
            .describe(
              "Whether to fight to the death (true) or just attack once (false)"
            ),
        })
        .describe("Attack the beast you encountered"),
      async handler(data, ctx, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Attacking Beast - Adventurer ID: ${data.adventurerId}, To Death: ${data.toTheDeath}`
          );

          const { adventurerId, toTheDeath } = data;

          // Get current state through the state manager
          const currentState = await gameStateManager.getState(adventurerId);

          // Make sure we're in battle
          if (!currentState || currentState.inBattle !== "true") {
            return {
              success: false,
              error: "Not in battle",
              message: "Cannot attack: you are not in battle with a beast",
            };
          }

          // Store initial state to compare later for damage calculation
          const initialState = { ...currentState };
          console.log(`[ATTACK] Initial beast health: ${initialState.beastHealth}, adventurer health: ${initialState.adventurerHealth}`);

          // Record the name of the beast we're fighting for better messaging
          const beastName = initialState.currentBeast || "Beast";

          console.log(`[STARKNET] Calling attack function on contract`);
          const attackResult = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "attack",
            calldata: [
              adventurerId,
              toTheDeath ? 1 : 0, // Convert boolean to 0/1
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${attackResult.transaction_hash}`
          );

          // Update state through the state manager but use a descriptive action name for better logs
          const updatedState = await gameStateManager.updateAfterAction(
            adventurerId,
            `Attacking ${beastName}`,
            attackResult.transaction_hash
          );

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve updated adventurer state",
              message: "Failed to attack: could not get updated adventurer state",
            };
          }

          // Calculate damage dealt to beast - ensure we handle undefined values
          const initialBeastHealth = parseInt(initialState.beastHealth || "0");
          const updatedBeastHealth = parseInt(updatedState.beastHealth || "0");
          const damageDealt = Math.max(0, initialBeastHealth - updatedBeastHealth);

          // Calculate damage taken by adventurer
          const initialAdvHealth = parseInt(initialState.adventurerHealth || "0");
          const updatedAdvHealth = parseInt(updatedState.adventurerHealth || "0");
          const damageTaken = Math.max(0, initialAdvHealth - updatedAdvHealth);

          // Store damage values in state for reference
          updatedState.lastDamageDealt = damageDealt.toString();
          updatedState.lastDamageTaken = damageTaken.toString();

          // We don't know if it was critical without event logs, so default is false
          updatedState.lastCritical = "false";

          // Log detailed attack results for debugging
          console.log(`[ATTACK] Damage calculation:`, {
            initialBeastHealth,
            updatedBeastHealth,
            damageDealt,
            initialAdvHealth,
            updatedAdvHealth,
            damageTaken
          });

          // Check if beast was defeated
          const beastDefeated = updatedBeastHealth <= 0;

          // Check if adventurer died
          const adventurerDied = updatedAdvHealth <= 0;

          // Check for XP and gold gains
          const initialXP = parseInt(initialState.xp || "0");
          const updatedXP = parseInt(updatedState.xp || "0");
          const xpGained = Math.max(0, updatedXP - initialXP);

          const initialGold = parseInt(initialState.gold || "0");
          const updatedGold = parseInt(updatedState.gold || "0");
          const goldGained = Math.max(0, updatedGold - initialGold);

          // Create detailed action description with specific numbers for the agent
          let actionDescription = "";

          if (adventurerDied) {
            actionDescription = `Died while attacking ${beastName}`;
            console.log(`[DEATH] Your adventurer has been slain!`);
          } else if (beastDefeated) {
            actionDescription = `Defeated ${beastName}`;
            if (xpGained > 0 || goldGained > 0) {
              actionDescription += ` (Gained`;
              if (xpGained > 0) actionDescription += ` ${xpGained} XP`;
              if (xpGained > 0 && goldGained > 0) actionDescription += `,`;
              if (goldGained > 0) actionDescription += ` ${goldGained} Gold`;
              actionDescription += `)`;
            }
            console.log(`[VICTORY] ${beastName} slain!`);
          } else {
            // Most important case - clearly describe attack results
            actionDescription = `Attacked ${beastName}: Dealt ${damageDealt} damage`;
            if (damageTaken > 0) {
              actionDescription += `, took ${damageTaken} damage`;
            }
            actionDescription += ` (Beast health: ${updatedBeastHealth}/${initialState.beastMaxHealth})`;

            console.log(
              `[BATTLE] Attacked ${beastName}, dealt ${damageDealt} damage, took ${damageTaken} damage`
            );
          }

          // Update the last action in state
          updatedState.lastAction = actionDescription;
          console.log(`[ATTACK] Set lastAction to: "${actionDescription}"`);

          // Check for level up
          const initialLevel = parseInt(initialState.level || "1");
          const updatedLevel = parseInt(updatedState.level || "1");
          if (updatedLevel > initialLevel) {
            console.log(
              `[LEVEL UP] Advanced to level ${updatedLevel}! Available stat points: ${updatedState.statUpgrades}`
            );
          }

          // Apply updated state to agent memory
          gameStateManager.applyToMemory(ctx);

          console.log(`[ACTION] Attack Complete - ${actionDescription}`);

          // Return a clear, detailed message about the attack outcome
          const stateSummary = generateStateSummary(updatedState);
          console.log(`[ATTACK] Sending state summary to agent`);
          return {
            success: true,
            message: `${actionDescription}\n\n${stateSummary}`,
            // Include additional details that might be useful to the agent
            details: {
              beastName,
              damageDealt,
              damageTaken,
              beastHealth: updatedBeastHealth,
              beastMaxHealth: initialState.beastMaxHealth,
              beastDefeated,
              xpGained,
              goldGained,
              levelUp: updatedLevel > initialLevel
            }
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to attack beast:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to attack beast",
          };
        }
      },
    }),

    /**
     * Action to get the current state of the adventurer
     */
    action({
      name: "getAdventurerState",
      description: "Get the current state of your adventurer",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
        })
        .describe("Get the current state of your adventurer"),
      async handler(data, ctx, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Getting Adventurer State - ID: ${data.adventurerId}`
          );

          const { adventurerId } = data;

          // Force refresh state through state manager
          const updatedState = await gameStateManager.getState(adventurerId, true);

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve adventurer state",
              message: "Failed to get adventurer state",
            };
          }

          // Apply the updated state to agent memory
          const memoryState = gameStateManager.applyToMemory(ctx);

          console.log(`[ACTION] State Retrieved Successfully`);

          // Create a detailed state summary to return directly to the agent
          const stateSummary = generateStateSummary(updatedState);

          console.log(`[ACTION] Sending state summary to agent`);

          return {
            success: true,
            message: `State retrieved successfully. ${stateSummary}`,
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error(
            "[ERROR] Failed to get adventurer state:",
            errorMessage
          );

          return {
            success: false,
            error: errorMessage,
            message: "Failed to get adventurer state",
          };
        }
      },
    }),

    /**
     * Action to flee from a beast
     */
    action({
      name: "fleeBeast",
      description: "Try to flee from the beast you're currently facing",
      schema: z
        .object({
          adventurerId: z.string().describe("The ID of your adventurer"),
          toTheDeath: z
            .boolean()
            .default(false)
            .describe("Always false as this is a flee attempt"),
        })
        .describe("Try to flee from the beast you encountered"),
      async handler(data, ctx: any, _agent: Agent) {
        try {
          console.log(
            `[ACTION] Attempting to Flee - Adventurer ID: ${data.adventurerId}`
          );

          const { adventurerId, toTheDeath } = data;

          // Get current state through the state manager
          const currentState = await gameStateManager.getState(adventurerId);

          // Make sure we're in battle
          if (!currentState || currentState.inBattle !== "true") {
            return {
              success: false,
              error: "Not in battle",
              message: "Cannot flee: you are not in battle with a beast",
            };
          }

          // Store initial state to compare later
          const initialState = { ...currentState };

          // Record the name of the beast we're fleeing from
          const beastName = initialState.currentBeast || "Beast";
          console.log(`[FLEE] Attempting to flee from ${beastName}`);

          // Use Starknet to call flee function
          console.log(`[STARKNET] Calling flee function on contract`);
          const fleeResult = await starknet.write({
            contractAddress: GAME_CONTRACT_ADDRESS,
            entrypoint: "flee",
            calldata: [
              adventurerId,
              toTheDeath ? 1 : 0, // Typically should be 0 for flee
            ],
          });

          console.log(
            `[STARKNET] Transaction hash: ${fleeResult.transaction_hash}`
          );

          // Update state through the state manager
          const updatedState = await gameStateManager.updateAfterAction(
            adventurerId,
            `Fleeing from ${beastName}`,
            fleeResult.transaction_hash
          );

          if (!updatedState) {
            return {
              success: false,
              error: "Failed to retrieve updated adventurer state",
              message: "Failed to flee: could not get updated adventurer state",
            };
          }

          // Determine what happened during flee attempt by comparing before/after states

          // Calculate damage taken during flee attempt
          const initialHealth = parseInt(initialState.adventurerHealth || "0");
          const updatedHealth = parseInt(updatedState.adventurerHealth || "0");
          const damageTaken = Math.max(0, initialHealth - updatedHealth);

          // Update state with damage information
          updatedState.lastDamageTaken = damageTaken.toString();
          updatedState.lastDamageDealt = "0"; // We don't deal damage during flee attempts

          // Check if flee was successful - we're no longer in battle
          const fleeSuccessful = updatedState.inBattle === "false";

          // Check if adventurer died
          const adventurerDied = updatedHealth <= 0;

          // Create detailed action description
          let actionDescription = "";

          if (adventurerDied) {
            actionDescription = `Died while fleeing from ${beastName}`;
            console.log(`[DEATH] Your adventurer died while attempting to flee!`);
          } else if (fleeSuccessful) {
            actionDescription = `Successfully fled from ${beastName}`;
            if (damageTaken > 0) {
              actionDescription += ` (took ${damageTaken} damage)`;
            }
            console.log(`[FLEE] Successfully escaped from ${beastName}!`);
          } else {
            actionDescription = `Failed to flee from ${beastName}`;
            if (damageTaken > 0) {
              actionDescription += ` (took ${damageTaken} damage)`;
            }
            console.log(
              `[FLEE] Failed to escape from ${beastName}!${damageTaken > 0 ? ` Took ${damageTaken} damage!` : ''}`
            );
          }

          // Update the last action in state
          updatedState.lastAction = actionDescription;
          console.log(`[FLEE] Set lastAction to: "${actionDescription}"`);

          // Apply state to agent memory
          gameStateManager.applyToMemory(ctx);

          console.log(`[ACTION] Flee Attempt Complete - ${actionDescription}`);

          const stateSummary = generateStateSummary(updatedState);
          console.log(`[FLEE] Sending state summary to agent`);

          return {
            success: true,
            message: `${actionDescription}\n\n${stateSummary}`,
            details: {
              beastName,
              fleeSuccessful,
              damageTaken,
              adventurerDied,
              // Include the current health so the agent knows its situation
              currentHealth: updatedHealth,
              maxHealth: parseInt(updatedState.adventurerMaxHealth || "100")
            }
          };
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error("[ERROR] Failed to flee from beast:", errorMessage);

          return {
            success: false,
            error: errorMessage,
            message: "Failed to flee from beast",
          };
        }
      },
    }),
  ],
});

// Add a utility function to wait for transaction confirmation
async function waitForTransaction(txHash: string, waitTime: number = 5000): Promise<void> {
  console.log(`[STARKNET] Waiting for transaction ${txHash} to be confirmed...`);

  try {
    // First add a small delay to allow transaction to propagate
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Then poll until the transaction is confirmed
    let status = "RECEIVED";
    let attempts = 0;
    const maxAttempts = 30; // Prevent infinite loops
    const pollInterval = 2000; // 2 seconds between checks

    while (!["ACCEPTED_ON_L2", "ACCEPTED_ON_L1"].includes(status) && attempts < maxAttempts) {
      try {
        // Use the direct account.waitForTransaction method with polling
        const receipt = await starknet.write({
          contractAddress: GAME_CONTRACT_ADDRESS,
          entrypoint: "check_transaction_status", // Using a read-only entrypoint to get access to provider
          calldata: [txHash],
        });

        // Extract status from receipt if available
        if (receipt && typeof receipt === 'object' && 'execution_status' in receipt) {
          const executionStatus = receipt.execution_status;
          if (executionStatus === "SUCCEEDED") {
            status = "ACCEPTED_ON_L2";
          } else if (executionStatus === "REVERTED") {
            console.error(`[STARKNET] Transaction ${txHash} failed with status: REVERTED`);
            throw new Error(`Transaction failed: REVERTED`);
          }
        }

        if (!["ACCEPTED_ON_L2", "ACCEPTED_ON_L1"].includes(status)) {
          console.log(`[STARKNET] Transaction ${txHash} not confirmed yet. Waiting...`);
          await new Promise(resolve => setTimeout(resolve, pollInterval));
        }
      } catch (error) {
        console.warn(`[STARKNET] Error checking transaction status: ${error}`);
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }

      attempts++;
    }

    if (attempts >= maxAttempts) {
      console.warn(`[STARKNET] Transaction confirmation timed out after ${attempts} attempts. Proceeding anyway.`);
    } else {
      console.log(`[STARKNET] Transaction ${txHash} confirmed with status: ${status}`);
    }
  } catch (error) {
    console.error(`[STARKNET] Error waiting for transaction: ${error}`);
    // Fall back to simple delay in case of errors with receipt fetching
    console.log(`[STARKNET] Falling back to delay of ${waitTime}ms`);
    await new Promise(resolve => setTimeout(resolve, waitTime));
  }

  console.log(`[STARKNET] Resuming after transaction confirmation`);
}

// Add back the createDreams initialization at the end of the file
// Add this at the very end of the file

// Initialize the agent
createDreams({
  logger: LogLevel.INFO,
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension, lootSurvivor],
  context: goalContexts,
  actions: [],
}).start({
  id: "loot-survivor-game",
  initialGoal:
    "Progress as far as possible in Loot Survivor, defeat beasts, collect loot, and upgrade your character.",
  initialTasks: [
    "Check adventurer state",
    "Start a new game if needed",
    "Explore and battle beasts strategically",
    "Manage equipment and upgrades",
    "Make decisions based on health and beast strength",
  ],
});

console.log(
  "Loot Survivor agent is now running! The agent will play the game through CLI."
);
--- End File: examples/games/lootsurvivor/example-lootsurvivor.ts ---

--- File: examples/mcp/mcp-agent.ts ---
import { createDreams } from "@daydreamsai/core";
import { createMcpExtension } from "@daydreamsai/mcp";
import { LogLevel } from "@daydreamsai/core";
import path from "path";
import { groq } from "@ai-sdk/groq";
import { cli } from "@daydreamsai/cli";

/**
 * This example demonstrates how to create an agent that connects to an MCP server
 * and uses its resources through the MCP extension.
 *
 * It sets up a connection to a local MCP server that provides access to resources
 * like application logs.
 */

// Create an agent with the MCP extension
createDreams({
  model: groq("deepseek-r1-distill-llama-70b"),
  logger: LogLevel.INFO,
  contexts: [cli],
  // Add the MCP extension with the example server configuration
  extensions: [
    createMcpExtension([
      {
        id: "example-server",
        name: "Example Resource Server",
        transport: {
          type: "stdio",
          command: "tsx",
          args: [path.join(__dirname, "mcp-server-example.ts")],
        },
      },
    ]),
  ],
}).start();

--- End File: examples/mcp/mcp-agent.ts ---

--- File: examples/mcp/mcp-server-example.mjs ---
import {
  McpServer,
  ResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool("add", { a: z.number(), b: z.number() }, async ({ a, b }) => ({
  content: [{ type: "text", text: String(a + b) }],
}));

// Add a dynamic greeting resource
server.resource(
  "greeting",
  new ResourceTemplate("greeting://{name}", { list: undefined }),
  async (uri, { name }) => ({
    contents: [
      {
        uri: uri.href,
        text: `Hello, ${name}!`,
      },
    ],
  })
);

server.resource(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "add",
        description: "Add two numbers",
        parameters: {
          a: { type: "number" },
          b: { type: "number" },
        },
      },
    ],
  };
});

// Start receiving messages on stdin and sending messages on stdout
const transport = new StdioServerTransport();
await server.connect(transport);

--- End File: examples/mcp/mcp-server-example.mjs ---

--- File: examples/mcp/mcp-server-example.ts ---
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool("add", { a: z.number(), b: z.number() }, async ({ a, b }) => ({
  content: [{ type: "text", text: String(a + b) }],
}));

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});

--- End File: examples/mcp/mcp-server-example.ts ---

--- File: examples/mcp/package.json ---
{
  "name": "mcp",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.0",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/mcp": "workspace:*",
    "@modelcontextprotocol/sdk": "^1.7.0",
    "zod": "^3.24.2"
  }
}

--- End File: examples/mcp/package.json ---

--- File: examples/server/README.md ---
# server

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run 
```

This project was created using `bun init` in bun v1.2.5. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.

--- End File: examples/server/README.md ---

--- File: examples/server/mcp/api.ts ---
import { createMcpClient } from "@daydreamsai/mcp";
import { Client as McpClient } from "@modelcontextprotocol/sdk/client/index.js";
import path from "path";
import { env } from "bun";
import { api } from "../utils";

export interface McpServerConfig {
  id: string;
  name: string;
  transport:
    | {
        type: "stdio";
        // For stdio transport
        command?: string;
        args?: string[];
      }
    | {
        type: "sse";
        // For SSE transport
        serverUrl?: string;
        sseEndpoint?: string;
        messageEndpoint?: string;
      };
  capabilities?: {
    prompts?: Record<string, unknown>;
    resources?: Record<string, unknown>;
    tools?: Record<string, unknown>;
  };
  env?: Record<string, string>;
}

export async function createMcpProxyApi({
  servers,
}: {
  servers: McpServerConfig[];
}) {
  const clients = new Map<string, McpClient>();

  for (const config of servers) {
    const client = await createMcpClient(config);
    clients.set(config.id, client);
  }

  return api({
    "/api/mcp/servers": async (req) => {
      return Response.json({
        servers: servers.map(({ id, name }) => ({ id, name })),
      });
    },
    "/api/mcp/servers/:serverId/tools": async (req) => {
      const { serverId } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");
      const { tools } = await client!.listTools();
      return Response.json({
        tools,
      });
    },
    "/api/mcp/servers/:serverId/tools/:tool": async (req) => {
      if (req.method !== "POST") {
        return new Response("Method not allowed", {
          status: 405,
        });
      }

      const { serverId, tool } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");

      const data = (await req.json()) as {
        args: any;
      };

      try {
        const result = await client.callTool({
          name: tool,
          arguments: data.args,
        });

        // const toolResult = JSON.parse((result.content as any)[0].text);
        return Response.json({
          serverId,
          tool: req.params.tool,
          result: result.content,
        });
      } catch (error) {
        return Response.json({
          serverId,
          tool,
          result: {
            error,
            message: error instanceof Error ? error.message : undefined,
          },
        });
      }
    },
    "/api/mcp/servers/:serverId/prompts": async (req) => {
      const { serverId } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");
      const res = await client!.listPrompts();
      return Response.json(res);
    },
    "/api/mcp/servers/:serverId/resources": async (req) => {
      const { serverId } = req.params;
      const client = clients.get(serverId);
      if (!client) throw new Error("Unknow client");
      const res = await client!.listResources();
      return Response.json(res);
    },
  });
}

--- End File: examples/server/mcp/api.ts ---

--- File: examples/server/mcp/servers/example.ts ---
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Create an MCP server
const server = new McpServer({
  name: "Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool("add", { a: z.number(), b: z.number() }, async ({ a, b }) => ({
  content: [{ type: "text", text: String(a + b) }],
}));

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});

--- End File: examples/server/mcp/servers/example.ts ---

--- File: examples/server/package.json ---
{
  "name": "server",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/mcp": "workspace:*",
    "@e2b/code-interpreter": "^1.0.4",
    "h3": "^1.15.1",
    "unstorage": "^1.15.0"
  },
  "peerDependencies": {
    "typescript": "^5"
  }
}

--- End File: examples/server/package.json ---

--- File: examples/server/server.ts ---
import { env, type RouterTypes } from "bun";
import { sanboxTools } from "./tools/sandbox";
import { basicTools } from "./tools/utils";
import { createToolsApi } from "./tools/api";
import { createMcpProxyApi, type McpServerConfig } from "./mcp/api";
import path from "path";
import { createStorageApi } from "./storage";
import fsLiteDriver from "unstorage/drivers/fs-lite";

export function createServer<
  R extends { [K in keyof R]: RouterTypes.RouteValue<K & string> },
>(params: { routes: R }) {
  const server = Bun.serve({
    port: 5555,
    routes: {
      "/ping": () => {
        return new Response("pong");
      },
      ...params.routes,
    },
  });
  return server;
}

const tools = {
  ...sanboxTools,
  ...basicTools,
};

export type ServerTools = typeof tools;

const mcpServers: McpServerConfig[] = [
  {
    id: "example-server",
    name: "Example Resource Server",
    transport: {
      type: "stdio",
      command: "tsx",
      args: [path.join(__dirname, "./mcp/servers/example.ts")],
    },
  },
  {
    id: "github",
    name: "GitHub MCP Server",
    transport: {
      type: "stdio",
      command: "docker",
      args: [
        "run",
        "-i",
        "--rm",
        "-e",
        "GITHUB_PERSONAL_ACCESS_TOKEN",
        "ghcr.io/github/github-mcp-server",
      ],
    },
    env: {
      GITHUB_PERSONAL_ACCESS_TOKEN: env.GITHUB_TOKEN!,
    },
  },
];

const mcpApi = await createMcpProxyApi({
  servers: mcpServers,
});

const server = createServer({
  routes: {
    ...createToolsApi({ tools }),
    ...createStorageApi(fsLiteDriver({ base: "./data/storage" })),
    ...mcpApi,
  },
});

--- End File: examples/server/server.ts ---

--- File: examples/server/storage.ts ---
import { createStorage, type Driver } from "unstorage";
import { createH3StorageHandler } from "unstorage/server";
import { createApp, toWebHandler } from "h3";
import { api } from "./utils";

export function createStorageApi(driver: Driver) {
  const storage = createStorage({
    driver,
  });

  const storageHandler = createH3StorageHandler(storage, {
    authorize(req) {
      console.log({ req });
    },
  });
  const app = createApp({ debug: true });
  app.use("/api/storage", storageHandler);
  const handler = toWebHandler(app);
  return api({
    "/api/storage/*": (req) => handler(req),
  });
}

--- End File: examples/server/storage.ts ---

--- File: examples/server/tools/api.ts ---
import { type CoreMessage } from "ai";
import zodToJsonSchema from "zod-to-json-schema";
import { randomUUIDv7, type RouterTypes } from "bun";
import { api, type ToolSet } from "../utils";

export function createToolsApi<Tools extends ToolSet>({
  tools,
}: {
  tools: {
    [K in keyof Tools]: Tools[K];
  };
}) {
  return api(() => {
    const state = {
      tools: Object.entries(tools as ToolSet).map(([name, tool]) => ({
        name,
        ...tool,
      })),
    };
    return {
      "/api/tools": {
        GET: async () => {
          return Response.json({
            tools: state.tools.map((tool) => ({
              name: tool.name,
              description: tool.description,
              parameters: zodToJsonSchema(tool.parameters, "schema")
                .definitions!["schema"],
            })),
          });
        },
      },
      "/api/tools/:tool": {
        POST: async (req) => {
          const data = (await req.json()) as {
            args: any;
            messages?: CoreMessage[];
            toolCallId?: string;
          };

          const tool = state.tools.find(
            (tool) => tool.name === req.params.tool
          )!;
          const args = tool.parameters.parse(data.args);
          const toolCallId = data.toolCallId ?? randomUUIDv7();

          try {
            const result = tool.execute
              ? await tool.execute(args, {
                  messages: data.messages ?? [],
                  toolCallId,
                  abortSignal: req.signal,
                })
              : args;
            return Response.json({
              tool: req.params.tool,
              toolCallId,
              result,
            });
          } catch (error) {
            return Response.json({
              tool: req.params.tool,
              toolCallId,
              result: {
                error,
                message: error instanceof Error ? error.message : undefined,
              },
            });
          }
        },
      },
    };
  });
}

--- End File: examples/server/tools/api.ts ---

--- File: examples/server/tools/sandbox.ts ---
import { tool } from "ai";
import { z } from "zod";
import { createToolSet } from "../utils";
import { Sandbox } from "@e2b/code-interpreter";
import { env } from "bun";
const e2bApiKey = env.E2B_API_KEY;

export type SandboxTools = typeof sanboxTools;

export const sanboxTools = createToolSet({
  "sandbox.runCode": tool({
    parameters: z.object({
      code: z.string(),
      language: z.enum(["python", "js"]),
      sandboxId: z.string(),
    }),
    execute: async ({ code, language, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });

      const response = await sdx.runCode(code, {
        language,
        onStdout(output) {
          console.log("out", output);
        },
        onStderr(output) {
          console.log("err", output);
        },
      });

      return response;
    },
  }),
  "sandbox.files.list": tool({
    parameters: z.object({
      path: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ path, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.list(path);
    },
  }),
  "sandbox.files.read": tool({
    parameters: z.object({
      path: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ path, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.read(path);
    },
  }),
  "sandbox.files.write": tool({
    parameters: z.object({
      path: z.string(),
      content: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ path, content, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.write(path, content);
    },
  }),
  "sandbox.files.rename": tool({
    parameters: z.object({
      oldPath: z.string(),
      newPath: z.string(),
      sandboxId: z.string(),
    }),
    execute: async ({ oldPath, newPath, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.files.rename(oldPath, newPath);
    },
  }),
  "sandbox.commands.run": tool({
    parameters: z.object({
      sandboxId: z.string(),
      cmd: z.string(),
      background: z.boolean().optional().default(false),
      // cwd: z.string().optional().describe("the working directory"),
      envs: z.record(z.string()).optional(),
    }),
    execute: async ({ cmd, background, envs, sandboxId }) => {
      const sdx = sandboxId
        ? await Sandbox.connect(sandboxId, { apiKey: e2bApiKey })
        : await Sandbox.create({ apiKey: e2bApiKey });
      return await sdx.commands.run(cmd, {
        background: background as any,
        // cwd,
        envs,
        onStdout(data) {
          console.log(data);
        },
      });
    },
  }),
});

--- End File: examples/server/tools/sandbox.ts ---

--- File: examples/server/tools/utils.ts ---
import { tool } from "ai";
import { z } from "zod";
import { createToolSet } from "../utils";
import { createContainer, http } from "@daydreamsai/core";
import { tavily, type TavilyClient } from "@tavily/core";
import { env } from "bun";

const container = createContainer();

container.singleton("tavily", () =>
  tavily({
    apiKey: env.TAVILY_API_KEY!,
  })
);

export type BasicTools = typeof basicTools;

export const basicTools = createToolSet({
  getWeather: tool({
    parameters: z.object({ location: z.string() }),
    description: "get the weather for a location",
    execute: async ({ location }, options) => {
      const geolocation = await http.get.json<{
        results: { latitude: number; longitude: number }[];
      }>("https://geocoding-api.open-meteo.com/v1/search", {
        name: location,
        count: 1,
        language: "en",
        format: "json",
      });
      if (geolocation.results[0]) {
        const res = await http.get.json<{ test: true }>(
          "https://api.open-meteo.com/v1/forecast",
          {
            latitude: geolocation.results[0].latitude,
            longitude: geolocation.results[0].longitude,
            current_weather: "true", // Request current weather data
          }
        );

        return res;
      }

      return "Failed";
    },
  }),
  "tavily.search": tool({
    description: "Execute a search query using Tavily Search.",
    parameters: z.object({
      query: z.string().describe("The search query to execute with Tavily."),
      topic: z
        .enum(["general", "news"])
        .optional()
        .default("general")
        .describe(
          "The category of the search.news is useful for retrieving real-time updates, particularly about politics, sports, and major current events covered by mainstream media sources. general is for broader, more general-purpose searches that may include a wide range of sources."
        ),
      maxResults: z.number().min(1).max(20).default(5).optional(),
      searchDepth: z
        .enum(["basic", "advanced"])
        .default("basic")
        .optional()
        .describe(
          "The depth of the search. advanced search is tailored to retrieve the most relevant sources and content snippets for your query, while basic search provides generic content snippets from each source."
        ),
    }),
    async execute({ query, topic, searchDepth, maxResults }) {
      const response = await container
        .resolve<TavilyClient>("tavily")
        .search(query, {
          searchDepth,
          topic,
          maxResults,
        });

      return {
        results: response.results.map((result) => ({
          title: result.title,
          url: result.url,
          content: result.content,
        })),
        totalResults: response.results.length,
      };
    },
  }),
  "tavily.extract": tool({
    description:
      "Extract web page content from one or more specified URLs using Tavily Extract.",
    parameters: z.object({
      urls: z
        .array(z.string())
        .describe("A list of URLs to extract content from."),

      extractDepth: z
        .enum(["basic", "advanced"])
        .default("basic")
        .optional()
        .describe(
          "The depth of the extraction process. advanced extraction retrieves more data, including tables and embedded content, with higher success but may increase latency.basic extraction costs 1 credit per 5 successful URL extractions, while advanced extraction costs 2 credits per 5 successful URL extractions."
        ),
    }),
    async execute({ urls, extractDepth }) {
      const response = await container
        .resolve<TavilyClient>("tavily")
        .extract(urls, {
          extractDepth,
        });

      return {
        results: response.results.map((result) => ({
          url: result.url,
          content: result.rawContent,
          images: result.images,
        })),
        totalResults: response.results.length,
      };
    },
  }),
});

--- End File: examples/server/tools/utils.ts ---

--- File: examples/server/utils.ts ---
import type { Tool } from "ai";
import { type RouterTypes } from "bun";

export type ToolSet = Record<string, Tool<any, any>>;

export function createToolSet<Tools extends ToolSet>(tools: {
  [K in keyof Tools]: Tools[K];
}) {
  return tools;
}

export function api<
  R extends { [K in keyof R]: RouterTypes.RouteValue<K & string> },
>(r: R | (() => R)) {
  return typeof r === "function" ? r() : r;
}

--- End File: examples/server/utils.ts ---

--- File: examples/tasks/eternum.ts ---
// This is all you need to inject into the LLM

export const ETERNUM_CONTEXT = `

Your Realms are:

Uw Rohi 
$REALM_ID: 6933
outer_col: 2147483646
outer_row: 2147483671

You are an AI assistant helping players with Eternum, a strategy game focused on realm development. Your purpose is to:

# Game Overview
1. Guide players through game mechanics
2. Help optimize resource management and building decisions  
3. Provide strategic recommendations based on game state

# Game Overview
- Players expand their Realm to build a hyperstructure
- Hyperstructures require 3M fragments and significant resources
- Once built, hyperstructures generate points when defended
- First player to accumulate 9M points wins the game

# When advising players, focus on:
- Current realm status and resources
- Strategic building placement
- Resource gathering efficiency
- Progress toward hyperstructure goals

<import_game_info>
1. Realm has no restrictions on building placement the level does not matter.
2. Building a building just requires having the resources along with a free space available.
</import_game_info>

Please familiarize yourself with the following game information:

<contract_addresses>
   - eternum-trade_systems: 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF
   - eternum-building_systems: 0x36b82076142f07fbd8bf7b2cabf2e6b190082c0b242c6ecc5e14b2c96d1763c
</contract_addresses>

<resource_ids>
  Stone = 1,
    Coal = 2,
    Wood = 3,
    Copper = 4,
    Ironwood = 5,
    Obsidian = 6,
    Gold = 7,
    Silver = 8,
    Mithral = 9,
    AlchemicalSilver = 10,
    ColdIron = 11,
    DeepCrystal = 12,
    Ruby = 13,
    Diamonds = 14,
    Hartwood = 15,
    Ignium = 16,
    TwilightQuartz = 17,
    TrueIce = 18,
    Adamantine = 19,
    Sapphire = 20,
    EtherealSilica = 21,
    Dragonhide = 22,
    AncientFragment = 29,
    Donkey = 249,
    Knight = 250,
    Crossbowman = 251,
    Paladin = 252,
    Lords = 253,
    Wheat = 254,
    Fish = 255
</resource_ids>

3. Building Types:
    None = 0
    Castle = 1
    Resource = 2
    Farm = 3
    Fishing Village = 4
    Barracks = 5
    Market = 6
    Archery Range = 7
    Stable = 8
    Trading Post = 9
    Workers Hut = 10
    Watch Tower = 11
    Walls = 12
    Storehouse = 13
    Bank = 14
    Fragment Mine = 15

4. Building Costs:
    Market: 750000 Fish, 125000 Stone, 50000 Obsidian, 25000 Ruby, 5000 DeepCrystal
    Barracks: 1000000 Wheat, 75000 Wood, 75000 Coal, 50000 Silver, 45000 Gold
    Archery Range: 1000000 Fish, 75000 Wood, 75000 Obsidian, 25000 Gold, 25000 Hartwood
    Stable: 1000000 Wheat, 75000 Wood, 75000 Silver, 35000 Ironwood, 25000 Gold
    Workers Hut: 300000 Wheat, 75000 Stone, 75000 Wood, 75000 Coal
    Storehouse: 1000000 Fish, 75000 Coal, 75000 Stone, 10000 Sapphire
    Farm: 450000 Fish
    Fishing Village: 450000 Wheat

5. Building Population Effects:
    None: 0
    Castle: 0
    Bank: 0
    Fragment Mine: 0
    Resource: 2
    Farm: 1
    Fishing Village: 1
    Barracks: 2
    Market: 3
    Archery Range: 2
    Stable: 3
    Trading Post: 2
    Workers Hut: 0
    Watch Tower: 2
    Walls: 2
    Storehouse: 2

6. Realm Levels and Upgrade Requirements:
Level 0 (Settlement):
  - 6 buildable hexes - starting realm level

Level 1 (City):
  - 18 buildable hexes
  - Requires: 3000k Wheat and 3000k Fish

Level 2 (Kingdom):
  Requires:
  - 600k ColdIron
  - 600k Hartwood  
  - 600k Diamonds
  - 600k Sapphire
  - 600k DeepCrystal
  - 5000k Wheat
  - 5000k Fish

Level 3 (Empire):
  Requires:
  - 50k AlchemicalSilver
  - 50k Adamantine
  - 50k Mithral 
  - 50k Dragonhide
  - 9000k Wheat
  - 9000k Fish

7. Building Descriptions:
    Farm: Creates Wheat
    Fishing Village: Creates Fish

When assisting players, follow these guidelines:

1. Buying Resources:
   a. Examine the market data using the eternum_Orders function.
   b. Accept an order using the eternum_AcceptOrder model with the correct parameters.


2. If asked to build a farm:
   a. Check resources
   b. Check space 
   c. Build farm


3. Realm Upgrades:
   a. Assess the current realm level and check if upgrade requirements are met.
   b. Advise on resource gathering if requirements are not met.
   c. Suggest upgrading when all requirements are satisfied.

When responding to player queries or requests:

1. Begin your analysis inside <game_analysis> tags:
   a. Summarize the current game context
   b. Identify the player's main concerns or goals
   c. List relevant game mechanics and resources
   d. Consider possible actions and their consequences
   e. Formulate a recommendation or strategy

2. Provide a clear explanation of your recommendation or the action to be taken.
3. Include relevant game data, calculations, or resource requirements as needed.
4. If multiple options are available, present them clearly with pros and cons.



Remember to always provide accurate information based on the game mechanics and current context. If you're unsure about any aspect, state so clearly and suggest where the player might find more information within the game.

<game_analysis>

<query_guide>
You are an AI assistant specialized in helping users query information about the Eternum game using GraphQL. Your task is to understand the user's request, construct an appropriate GraphQL query, and explain how to use it.



When a user asks for information about the game, follow these steps:

1. Analyze the user's request and determine which type of query is needed. Always follow <best_practices>
2. Break down your approach inside <query_analysis> tags, including:
   - A summary of the user's request
   - Identification of the relevant query type(s) needed
   - A list of specific parameters or variables required for the query
   - Consideration of any potential challenges or edge cases
3. Construct the appropriate GraphQL query based on the available models and query structures.
4. Provide the query in <query> tags.
5. Explain how to use the query and what it will return in <explanation> tags.
6. You should always use the entity_id in your queries unless specifically searching by realm_id. The entity_id is the id of the realm and how you query the realm.

Here are the main query structures you can use:

1. Get Realm Info:

\`\`\`graphql
query GetRealmInfo {
  s0EternumRealmModels(where: { realm_id: REALM_ID }) {
    edges {
      node {
          entity_id
          level
      }
    }
  }
}
\`\`\`

2. Get Realm Position:
\`\`\`graphql
query GetRealmPosition {
  s0EternumPositionModels(where: { entity_id: ENTITY_ID }, limit: 1) {
    edges {
      node {
   
          x
          y
      }
    }
  }
}
\`\`\`

3. Get Realm Details:
\`\`\`graphql
query GetRealmDetails {
  s0EternumResourceModels(where: { entity_id: ENTITY_ID }, limit: 100) {
    edges {
      node {
          resource_type
          balance
      }
    }
  }
  s0EternumBuildingModels(where: { outer_col: X, outer_row: Y }) {
    edges {
      node {
          category
          entity_id
          inner_col
          inner_row
      }
    }
  }
}
\`\`\`

4. Schema Introspection:
\`\`\`graphql
query IntrospectModel {
  __type(name: MODEL_NAME) {
    name
    fields {
      name
      type {
        name
        kind
        ofType {
          name
          kind
        }
      }
    }
  }
}
\`\`\`




<AVAILABLE_MODELS>
 s0EternumAcceptOrderModels
      s0EternumAcceptPartialOrderModels
      s0EternumAddressNameModels
      s0EternumArmyModels
      s0EternumArmyTroopsModels
      s0EternumArrivalTimeModels
      s0EternumBankModels
      s0EternumBattleModels
      s0EternumBattleClaimDataModels
      s0EternumBattleConfigModels
      s0EternumBattleJoinDataModels
      s0EternumBattleLeaveDataModels
      s0EternumBattlePillageDataModels
      s0EternumBattlePillageDataTroopsModels
      s0EternumBattlePillageDataU8u128Models
      s0EternumBattleStartDataModels
      s0EternumBattleBattleArmyModels
      s0EternumBattleBattleHealthModels
      s0EternumBattleTroopsModels
      s0EternumBuildingModels
      s0EternumBuildingCategoryPopConfigModels
      s0EternumBuildingConfigModels
      s0EternumBuildingGeneralConfigModels
      s0EternumBuildingQuantityv2Models
      s0EternumBurnDonkeyModels
      s0EternumCancelOrderModels
      s0EternumCapacityCategoryModels
      s0EternumCapacityConfigModels
      s0EternumContributionModels
      s0EternumCreateGuildModels
      s0EternumCreateOrderModels
      s0EternumDetachedResourceModels
      s0EternumEntityNameModels
      s0EternumEntityOwnerModels
      s0EternumEpochModels
      s0EternumEpochContractAddressu16Models
      s0EternumFragmentMineDiscoveredModels
      s0EternumGameEndedModels
      s0EternumGuildModels
      s0EternumGuildMemberModels
      s0EternumGuildWhitelistModels
      s0EternumHealthModels
      s0EternumHyperstructureModels
      s0EternumHyperstructureCoOwnersChangeModels
      s0EternumHyperstructureCoOwnersChangeContractAddressu16Models
      s0EternumHyperstructureConfigModels
      s0EternumHyperstructureContributionModels
      s0EternumHyperstructureContributionU8u128Models
      s0EternumHyperstructureFinishedModels
      s0EternumHyperstructureResourceConfigModels
      s0EternumJoinGuildModels
      s0EternumLevelingConfigModels
      s0EternumLiquidityModels
      s0EternumLiquidityEventModels
      s0EternumLiquidityFixedModels
      s0EternumMapConfigModels
      s0EternumMapExploredModels
      s0EternumMapExploredU8u128Models
      s0EternumMarketModels
      s0EternumMarketFixedModels
      s0EternumMercenariesConfigModels
      s0EternumMercenariesConfigU8u128Models
      s0EternumMessageModels
      s0EternumMovableModels
      s0EternumOrdersModels
      s0EternumOwnedResourcesTrackerModels
      s0EternumOwnerModels
      s0EternumPopulationModels
      s0EternumPopulationConfigModels
      s0EternumPositionModels
      s0EternumProductionModels
      s0EternumProductionDeadlineModels
      s0EternumProductionInputModels
      s0EternumProductionOutputModels
      s0EternumProgressModels
      s0EternumProtecteeModels
      s0EternumProtectorModels
      s0EternumQuantityModels
      s0EternumQuantityTrackerModels
      s0EternumQuestModels
      s0EternumQuestBonusModels
      s0EternumQuestConfigModels
      s0EternumRealmModels
      s0EternumRealmLevelConfigModels
      s0EternumRealmMaxLevelConfigModels
      s0EternumResourceModels
      s0EternumResourceAllowanceModels
      s0EternumResourceBridgeConfigModels
      s0EternumResourceBridgeFeeSplitConfigModels
      s0EternumResourceBridgeWhitelistConfigModels
      s0EternumResourceCostModels
      s0EternumResourceTransferLockModels
      s0EternumSeasonModels
      s0EternumSettleRealmDataModels
      s0EternumSettlementConfigModels
      s0EternumSpeedConfigModels
      s0EternumStaminaModels
      s0EternumStaminaConfigModels
      s0EternumStaminaRefillConfigModels
      s0EternumStatusModels
      s0EternumStructureModels
      s0EternumStructureCountModels
      s0EternumStructureCountCoordModels
      s0EternumSwapEventModels
      s0EternumTickConfigModels
      s0EternumTileModels
      s0EternumTradeModels
      s0EternumTransferModels
      s0EternumTransferU8u128Models
      s0EternumTravelModels
      s0EternumTravelFoodCostConfigModels
      s0EternumTravelStaminaCostConfigModels
      s0EternumTravelCoordModels
      s0EternumTroopConfigModels
      s0EternumTrophyCreationModels
      s0EternumTrophyCreationTaskModels
      s0EternumTrophyProgressionModels
      s0EternumWeightModels
      s0EternumWeightConfigModels
      s0EternumWorldConfigModels
</AVAILABLE_MODELS>

<best_practices>
1. Always first use GetRealmInfo to get the entity_id.
2. Always validate entity_id before querying. Use the introspection get the entity_id.
3. Always replace the <entity_id> with the actual entity_id.  
4. Use pagination for large result sets.
5. Include only necessary fields in your queries.
6. Handle null values appropriately.
</best_practices>

<import_query_context>
1. Always use entity_id in queries unless specifically searching by realm_id.
2. Use limit parameters to control result size.
3. Include proper type casting in variables.
4. Follow the nested structure: Models → edges → node → specific type.
5. Only use the models listed in the AVAILABLE_MODELS section to query.
</import_query_context>

Remember to replace placeholders like <realm_id>, <entity_id>, <x>, <y>, and <model_name> with actual values when constructing queries.

Now, please wait for a user query about the Eternum game, and respond according to the steps outlined above.

</query_guide>
`;

// API DOCs etc
export const PROVIDER_GUIDE = `

<PROVIDER_GUIDE>

    Use these to call functions with graphql


  <IMPORTANT_RULES>
    1. If you receive an error, you may need to try again, the error message should tell you what went wrong.
    2. To verify a successful transaction, read the response you get back. You don't need to query anything.
    3. Never include slashes in your calldata.
  </IMPORTANT_RULES>

  <FUNCTIONS>
    <CREATE_ORDER>
      <DESCRIPTION>
        Creates a new trade order between realms.
      </DESCRIPTION>
      <PARAMETERS>
        - maker_id: ID of the realm creating the trade
        - maker_gives_resources: Resources the maker is offering
        - taker_id: ID of the realm that can accept the trade
        - taker_gives_resources: Resources requested from the taker
        - signer: Account executing the transaction
        - expires_at: When the trade expires
      </PARAMETERS>
      <EXAMPLE>
     
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "create_order",
            "calldata": [
              123,         
              1,           
              1,           
              100,         
              456,         
              1,           
              2,           
              50,          
              1704067200   
            ]
          }
  
      </EXAMPLE>
    </CREATE_ORDER>

    <ACCEPT_ORDER>
      <DESCRIPTION>
        Accepts an existing trade order.
      </DESCRIPTION>
      <PARAMETERS>
        - taker_id: ID of the realm accepting the trade
        - trade_id: ID of the trade being accepted
        - maker_gives_resources: Resources the maker is offering
        - taker_gives_resources: Resources requested from the taker
        - signer: Account executing the transaction
      </PARAMETERS>
      <EXAMPLE>
        <JSON>
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "accept_order",
            "calldata": [
              123,
              789,
              1,
              1,
              100,
              1,
              2,
              50
            ]
          }
        </JSON>
      </EXAMPLE>
    </ACCEPT_ORDER>

    <ACCEPT_PARTIAL_ORDER>
      <DESCRIPTION>
        Accepts a portion of an existing trade order.
      </DESCRIPTION>
      <PARAMETERS>
        - taker_id: ID of the realm accepting the trade
        - trade_id: ID of the trade being accepted
        - maker_gives_resources: Resources the maker is offering
        - taker_gives_resources: Resources requested from the taker
        - taker_gives_actual_amount: Actual amount taker will give
        - signer: Account executing the transaction
      </PARAMETERS>
      <EXAMPLE>
        <JSON>
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "accept_partial_order",
            "calldata": [
              123,
              789,
              1,
              1,
              100,
              1,
              2,
              50,
              25
            ]
          }
        </JSON>
      </EXAMPLE>
    </ACCEPT_PARTIAL_ORDER>

    <CANCEL_ORDER>
      <DESCRIPTION>
        Cancels an existing trade order.
      </DESCRIPTION>
      <PARAMETERS>
        - trade_id: ID of the trade to cancel
        - return_resources: Resources to return
        - signer: Account executing the transaction
      </PARAMETERS>
      <EXAMPLE>
        <JSON>
          {
            "contractAddress": "<eternum-trade_systems>",
            "entrypoint": "cancel_order",
            "calldata": [
              789,
              1,
              1,
              100
            ]
          }
        </JSON>
      </EXAMPLE>
    </CANCEL_ORDER>

    <CREATE_BUILDING>
      <DESCRIPTION>
        Creates a new building for a realm on the hexagonal grid map.
      </DESCRIPTION>
      <PARAMETERS>
        - entity_id: ID of the realm creating the building (required)
        - directions: Array of directions from castle to building location (required)
        - building_category: Type of building (required)
        - produce_resource_type: Resource type ID this building will produce (required for resource buildings)
      </PARAMETERS>
      <NOTES>
        Never use 0 for produce_resource_type, always use the resource type ID - eg: fish is 1, wheat is 1, etc.
      </NOTES>
      
      <PLACEMENT_GUIDE>
        <DESCRIPTION>
          The map uses a hexagonal grid with your realm's castle at the center (0,0). 
          Buildings are placed by specifying directions outward from the castle.
        </DESCRIPTION>
        
        <DIRECTION_IDS>
          0 = East (→)
          1 = Northeast (↗) 
          2 = Northwest (↖)
          3 = West (←)
          4 = Southwest (↙) 
          5 = Southeast (↘)
        </DIRECTION_IDS>

        <KEY_RULES>
          1. Cannot build on castle location (0,0)
          2. Building distance from castle is limited by realm level
          3. Each direction in the array represents one hex step from castle
          4. Location is determined by following directions sequentially
        </KEY_RULES>

        <RESOURCE_TYPES>
          <BASIC_RESOURCES>
            Stone (1)
            Coal (2) 
            Wood (3)
            Copper (4)
            Ironwood (5)
            Obsidian (6)
          </BASIC_RESOURCES>

          <PRECIOUS_RESOURCES>
            Gold (7)
            Silver (8)
            Mithral (9)
            AlchemicalSilver (10)
            ColdIron (11)
          </PRECIOUS_RESOURCES>

          <RARE_RESOURCES>
            DeepCrystal (12)
            Ruby (13)
            Diamonds (14)
            Hartwood (15)
            Ignium (16)
            TwilightQuartz (17)
            TrueIce (18)
            Adamantine (19)
            Sapphire (20)
            EtherealSilica (21)
            Dragonhide (22)
          </RARE_RESOURCES>

          <SPECIAL_RESOURCES>
            AncientFragment (29)
            Donkey (249)
            Knight (250)
            Crossbowman (251)
            Paladin (252)
            Lords (253)
            Wheat (1)
            Fish (1)
          </SPECIAL_RESOURCES>
        </RESOURCE_TYPES>
      </PLACEMENT_GUIDE>

      <EXAMPLE>
        <DESCRIPTION>
          Create a wood production building one hex northeast of castle:
        </DESCRIPTION>
        <JSON>
          {
            "contractAddress": "<eternum-building_systems>",
            "entrypoint": "create",
            "calldata": [
              123,
              [1],
              1,
              3
            ]
          }
        </JSON>
      </EXAMPLE>
    </CREATE_BUILDING>
  </FUNCTIONS>
</PROVIDER_GUIDE>
`;

--- End File: examples/tasks/eternum.ts ---

--- File: examples/tasks/example-task.ts ---
/**
 * Advanced example demonstrating a hierarchical goal planning system using Dreams
 * with Claude 3.7 Sonnet for autonomous agent behavior in a game environment. This is still alpha and not all features are available.
 *
 * This example shows how to:
 * 1. Create a hierarchical goal planning system (long/medium/short-term goals)
 * 2. Decompose goals into executable tasks
 * 3. Track and update goal progress
 * 4. Integrate with external APIs (Tavily, Eternum)
 *
 * Usage
 * 1. First ask the agent to "set up a plan to win at Eternum"
 * 2. Then ask the agent to execute the plan.
 */
import {
  createDreams,
  context,
  render,
  action,
  LogLevel,
  output,
  createContainer,
  fetchGraphQL,
  type InferContextMemory,
  validateEnv,
} from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { deepResearch } from "../deep-research/research";
import { string, z } from "zod";
import { tavily } from "@tavily/core";
import { ETERNUM_CONTEXT } from "./eternum";
import { anthropic } from "@ai-sdk/anthropic";

validateEnv(
  z.object({
    ANTHROPIC_API_KEY: z.string().min(1, "ANTHROPIC_API_KEY is required"),
    TAVILY_API_KEY: z.string().min(1, "TAVILY_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

/**
 * EXAMPLE USAGE:
 *
 * 1. Initialize the agent with a high-level objective:
 *    "Build a thriving settlement in Eternum with sustainable resource production"
 *
 * 2. The agent will automatically:
 *    - Break this down into hierarchical goals (long/medium/short-term)
 *    - Prioritize goals based on dependencies and importance
 *    - Execute tasks to achieve each goal
 *    - Update goal status as progress is made
 *
 * 3. Sample goal hierarchy:
 *    - Long-term: "Establish a self-sustaining settlement"
 *      - Medium-term: "Secure reliable food production"
 *        - Short-term: "Build 3 farms near water source"
 *          - Tasks: [Scout location, Gather resources, Construct buildings]
 */

// ==========================================
// SCHEMA DEFINITIONS
// ==========================================

/**
 * Defines the structure of individual tasks that make up a goal
 */
const taskSchema = z.object({
  plan: z.string().optional(),
  meta: z.any().optional(),
  actions: z.array(
    z.object({
      type: z.string(),
      context: z.string(),
      payload: z.any(),
    })
  ),
});

/**
 * Defines the structure of a goal with metadata for tracking and execution
 */
export const goalSchema = z
  .object({
    id: z.string(),
    description: z.string().describe("A description of the goal"),
    success_criteria: z.array(z.string()).describe("The criteria for success"),
    dependencies: z.array(z.string()).describe("The dependencies of the goal"),
    priority: z.number().min(1).max(10).describe("The priority of the goal"),
    required_resources: z
      .array(z.string())
      .describe("The resources needed to achieve the goal"),
    estimated_difficulty: z
      .number()
      .min(1)
      .max(10)
      .describe("The estimated difficulty of the goal"),
    tasks: z
      .array(taskSchema)
      .describe(
        "The tasks to achieve the goal. This is where you build potential tasks you need todo, based on your understanding of what you can do. These are actions."
      ),
  })
  .describe("A goal to be achieved");

/**
 * Defines the hierarchical goal planning structure with three time horizons
 */
export const goalPlanningSchema = z.object({
  long_term: z
    .array(goalSchema)
    .describe("Strategic goals that are the main goals you want to achieve"),
  medium_term: z
    .array(goalSchema)
    .describe(
      "Tactical goals that will require many short term goals to achieve"
    ),
  short_term: z
    .array(goalSchema)
    .describe(
      "Immediate actionable goals that will require a few tasks to achieve"
    ),
});

// ==========================================
// MODEL AND CONTAINER SETUP
// ==========================================

// Create a dependency injection container for services
const container = createContainer();

// Register Tavily search service
container.singleton("tavily", () => {
  return tavily({
    apiKey: process.env.TAVILY_API_KEY!,
  });
});

// ==========================================
// CONTEXT DEFINITION
// ==========================================

/**
 * Template for the goal manager context
 * This provides structure for the LLM to understand the current state
 */
const template = `
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}

<goal_planning_rules>
1. Break down the objective into hierarchical goals
2. Each goal must have clear success criteria
3. Identify dependencies between goals
4. Prioritize goals (1-10) based on urgency and impact
5. short term goals should be given a priority of 10
6. Ensure goals are achievable given the current context
7. Consider past experiences when setting goals
8. Use available game state information to inform strategy

# Each goal must include:
- id: Unique temporary ID used in dependencies
- description: Clear goal statement
- success_criteria: Array of specific conditions for completion
- dependencies: Array of prerequisite goal IDs (empty for initial goals)
- priority: Number 1-10 (10 being highest)
- required_resources: Array of resources needed (based on game state)
- estimated_difficulty: Number 1-10 based on past experiences
</goal_planning_rules>
`;

// Type definition for the goal planning schema
type Goal = z.infer<typeof goalPlanningSchema>;

/**
 * Context for managing goals and tasks
 * This maintains the state of goals and provides rendering for the LLM
 */
const goalContexts = context({
  type: "goal-manager",
  schema: z.object({
    id: string(),
  }),

  key({ id }) {
    return id;
  },

  create(state) {
    return {
      goal: null as null | Goal,
      tasks: [],
      currentTask: null,
    };
  },

  render({ memory }) {
    return render(template, {
      goal: memory.goal ?? "NONE",
      tasks: memory?.tasks?.join("\n"),
      currentTask: memory?.currentTask ?? "NONE",
    });
  },
});

// Type for the goal context memory
type GoalContextMemory = InferContextMemory<typeof goalContexts>;

// ==========================================
// ACTIONS DEFINITION
// ==========================================

/**
 * Create the Dreams agent with all necessary components
 */
createDreams({
  logger: LogLevel.INFO,
  debugger: async (contextId, keys, data) => {
    const [type, id] = keys;
    await Bun.write(`./logs/tasks/${contextId}/${id}-${type}.md`, data);
  },
  model: anthropic("claude-3-7-sonnet-latest"),
  extensions: [cliExtension, deepResearch],
  context: goalContexts,
  container,
  actions: [
    /**
     * Action to decompose a goal into executable tasks
     */
    action({
      name: "decomposeGoal",
      description: "Decompose a goal into executable tasks",
      schema: {
        goalId: z.string().describe("ID of the goal to decompose"),
        goalType: z
          .enum(["long_term", "medium_term", "short_term"])
          .describe("Type of goal"),
      },
      handler(data, ctx, agent) {
        const agentMemory = ctx.agentMemory as GoalContextMemory;

        if (!agentMemory.goal) {
          throw new Error("No goals have been set yet");
        }

        const goalType = data.goalType;
        const goalId = data.goalId;

        // Find the goal in the specified category
        const goal = agentMemory.goal[goalType].find(
          (g: any) => g.id === goalId
        );

        if (!goal) {
          throw new Error(
            `Goal with ID ${goalId} not found in ${goalType} goals`
          );
        }

        // Return the goal for task decomposition
        return {
          goal,
          message: `Ready to decompose goal: ${goal.description}`,
        };
      },
    }),

    /**
     * Action to set the complete goal plan
     */
    action({
      name: "setGoalPlan",
      description: "Set the complete goal plan",
      schema: z.object({ goal: goalPlanningSchema }),
      handler(data, ctx, agent) {
        const agentMemory = ctx.agentMemory as GoalContextMemory;
        agentMemory.goal = data.goal;
        return {
          plan: data.goal,
          message: "Goal plan has been set successfully",
        };
      },
    }),

    /**
     * Action to update a goal's state or properties
     */
    action({
      name: "updateGoal",
      description: "Update a goal's state or properties",
      schema: z.object({
        goalId: z.string().describe("ID of the goal to update"),
        goalType: z
          .enum(["long_term", "medium_term", "short_term"])
          .describe("Type of goal"),
        updates: goalSchema.partial().describe("Properties to update"),
      }),
      handler(data, ctx, agent) {
        const agentMemory = ctx.agentMemory as GoalContextMemory;

        if (!agentMemory.goal) {
          throw new Error("No goals have been set yet");
        }

        const goalType = data.goalType;
        const goalId = data.goalId;

        // Find the goal in the specified category
        const goalIndex = agentMemory.goal[goalType].findIndex(
          (g) => g.id === goalId
        );

        if (goalIndex === -1) {
          throw new Error(
            `Goal with ID ${goalId} not found in ${goalType} goals`
          );
        }

        // Update the goal with the provided updates
        agentMemory.goal[goalType][goalIndex] = {
          ...agentMemory.goal[goalType][goalIndex],
          ...data.updates,
        };

        return {
          updatedGoal: agentMemory.goal[goalType][goalIndex],
          message: `Goal ${goalId} has been updated successfully`,
        };
      },
    }),

    /**
     * Action to query Eternum game context
     */
    action({
      name: "queryEternum",
      description:
        "This will tell you everything you need to know about Eternum for how to win the game",
      schema: z.object({ query: z.string() }),
      handler(call, ctx, agent) {
        return {
          data: {
            result: ETERNUM_CONTEXT,
          },
          timestamp: Date.now(),
        };
      },
    }),

    /**
     * Action to query Eternum GraphQL API for game state
     */
    action({
      name: "Query:Eternum:Graphql",
      description: "Search Eternum GraphQL API",
      schema: z.object({
        query: z.string().describe(`
            query GetRealmDetails {
  s0EternumResourceModels(where: { entity_id: ENTITY_ID }, limit: 100) {
    edges {
      node {
          resource_type
          balance
      }
    }
  }
  s0EternumBuildingModels(where: { outer_col: X, outer_row: Y }) {
    edges {
      node {
          category
          entity_id
          inner_col
          inner_row
      }
    }
  }
}`),
      }),
      async handler(data, ctx, agent) {
        const result = await fetchGraphQL(
          "https://api.cartridge.gg/x/eternum-sepolia/torii/graphql",
          data.query
        );

        if (result instanceof Error) {
          return {
            error: result.message,
          };
        }

        return {
          data: {
            result: result,
          },
          timestamp: Date.now(),
        };
      },
    }),
  ],

  // ==========================================
  // OUTPUTS DEFINITION
  // ==========================================

  outputs: {
    /**
     * Output to update the goal state
     */
    "goal-manager:state": output({
      description:
        "Use this when you need to update the goals. Use the goal id to update the goal. You should attempt the goal then call this to update the goal.",
      instructions: "Increment the state of the goal manager",
      schema: z.object({
        type: z
          .enum(["SET", "UPDATE"])
          .describe("SET to set the goals. UPDATE to update a goal."),
        goal: goalSchema,
      }),
      handler: async (call, ctx, agent) => {
        console.log("handler", { call, ctx, agent });

        return {
          data: {
            goal: "",
          },
          timestamp: Date.now(),
        };
      },
    }),
  },
}).start({
  id: "game",
});

--- End File: examples/tasks/example-task.ts ---

--- File: examples/tasks/package.json ---
{
  "name": "tasks",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.15",
    "@ai-sdk/openai": "^1.2.1",
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/cli": "workspace:*",
    "@daydreamsai/core": "workspace:*",
    "@tavily/core": "^0.3.1",
    "zod": "^3.24.2"
  }
}

--- End File: examples/tasks/package.json ---

--- File: examples/telegram/index.ts ---
import { createGroq } from "@ai-sdk/groq";
import { createDreams, LogLevel, validateEnv } from "@daydreamsai/core";
import { telegram } from "@daydreamsai/telegram";
import { deepResearch } from "../deep-research/research";
import { z } from "zod";
import { searchWebAction } from "../actions";

const env = validateEnv(
  z.object({
    TELEGRAM_TOKEN: z.string().min(1, "TELEGRAM_TOKEN is required"),
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    TAVILY_API_KEY: z.string().min(1, "TAVILY_API_KEY is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

createDreams({
  logLevel: LogLevel.DEBUG,
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [telegram, deepResearch],
}).start();

--- End File: examples/telegram/index.ts ---

--- File: examples/telegram/package.json ---
{
  "name": "telegram",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/telegram": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: examples/telegram/package.json ---

--- File: examples/twitter/index.ts ---
import { createGroq } from "@ai-sdk/groq";
import { twitter } from "@daydreamsai/twitter";
import { createDreams, LogLevel, validateEnv } from "@daydreamsai/core";
import { z } from "zod";

const env = validateEnv(
  z.object({
    GROQ_API_KEY: z.string().min(1, "GROQ_API_KEY is required"),
    TWITTER_USERNAME: z.string().min(1, "TWITTER_USERNAME is required"),
    TWITTER_PASSWORD: z.string().min(1, "TWITTER_PASSWORD is required"),
    TWITTER_EMAIL: z.string().min(1, "TWITTER_EMAIL is required"),
    OPENAI_API_KEY: z.string().min(1, "OPENAI_API_KEY is required"),
  })
);

const groq = createGroq({
  apiKey: env.GROQ_API_KEY!,
});

const agent = createDreams({
  logLevel: LogLevel.DEBUG,
  model: groq("deepseek-r1-distill-llama-70b"),
  extensions: [twitter],
});

// Start the agent
await agent.start();

--- End File: examples/twitter/index.ts ---

--- File: examples/twitter/package.json ---
{
  "name": "twitter",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/groq": "^1.1.12",
    "@daydreamsai/core": "workspace:*",
    "@daydreamsai/twitter": "workspace:*",
    "@daydreamsai/cli": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: examples/twitter/package.json ---

--- File: package.json ---
{
  "name": "daydreams",
  "version": "0.0.0",
  "workspaces": [
    "packages/*",
    "clients/*",
    "examples/*"
  ],
  "scripts": {
    "test": "bun run packages/core",
    "build:packages": "./scripts/build.sh",
    "build:packages:watch": "./scripts/build.sh --watch",
    "release": "./scripts/release.sh",
    "release:dry-run": "./scripts/release.sh --dry-run",
    "clean": "./scripts/clean.sh",
    "clean:dry-run": "./scripts/clean.sh --dry-run",
    "clean:deps": "./scripts/clean.sh --deps-only",
    "clean:builds": "./scripts/clean.sh --builds-only",
    "prettier-check": "pnpx prettier --check packages",
    "prettier": "pnpx prettier --write packages",
    "knip": "knip",
    "docs:dev": "cd docs && bun run dev",
    "docs:build": "cd docs && bun run docs:build",
    "docs:start": "cd docs && bun run start"
  },
  "devDependencies": {
    "@types/bun": "^1.2.2",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "knip": "^5.43.6",
    "typedoc": "^0.27.6",
    "typedoc-plugin-frontmatter": "^1.1.2",
    "typedoc-plugin-markdown": "^4.4.1",
    "typescript": "^5.8.2"
  },
  "resolutions": {
    "@mysten/sui": "1.7.0"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.3",
    "@ai-sdk/groq": "^1.2.2",
    "@ai-sdk/openai": "^1.3.5",
    "@ai-sdk/provider": "^1.1.0",
    "@ai-sdk/ui-utils": "^1.2.3",
    "ai": "^4.2.9"
  }
}

--- End File: package.json ---

--- File: packages/chroma/package.json ---
{
  "name": "@daydreamsai/chromadb",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "chromadb": "^1.10.5",
    "zod": "^3.24.2"
  }
}

--- End File: packages/chroma/package.json ---

--- File: packages/chroma/src/chroma.ts ---
/**
 * Imports required dependencies from chromadb and local types
 */
import {
  ChromaClient,
  Collection,
  OpenAIEmbeddingFunction,
  type IEmbeddingFunction,
} from "chromadb";
import { DefaultEmbeddingFunction } from "chromadb";
import type { InferContextMemory, VectorStore } from "@daydreamsai/core";

/**
 * Implementation of VectorStore using ChromaDB as the backend
 */
export class ChromaVectorStore implements VectorStore {
  private client: ChromaClient;
  private collection!: Collection;
  private embedder: IEmbeddingFunction;

  /**
   * Creates a new ChromaVectorStore instance
   * @param collectionName - Name of the ChromaDB collection to use (defaults to "default")
   * @param connection - Optional connection string for ChromaDB
   * @param embedder - Optional custom embedding function implementation
   */
  constructor(
    collectionName: string = "default",
    connection?: string,
    embedder?: IEmbeddingFunction
  ) {
    this.embedder =
      embedder || process.env.OPENAI_API_KEY
        ? new OpenAIEmbeddingFunction({
            openai_api_key: process.env.OPENAI_API_KEY!,
            openai_model: "text-embedding-3-small",
          })
        : new DefaultEmbeddingFunction();

    this.client = new ChromaClient({
      path: connection,
    });
    this.initCollection(collectionName);
  }

  /**
   * Initializes or retrieves the ChromaDB collection
   * @param collectionName - Name of the collection to initialize
   */
  private async initCollection(collectionName: string) {
    this.collection = await this.client.getOrCreateCollection({
      name: collectionName,
      embeddingFunction: this.embedder,
      metadata: {
        description: "Memory storage for AI consciousness",
      },
    });
  }

  /**
   * Adds or updates documents in the vector store
   * @param contextId - Unique identifier for the context
   * @param data - Array of documents to store
   */
  async upsert(
    contextId: string,
    data: InferContextMemory<any>[]
  ): Promise<void> {
    if (data.length === 0) return;

    // Generate IDs for the documents
    const ids = data.map((_, index) => `doc_${Date.now()}_${index}`);

    // Convert documents to strings if they aren't already
    const documents = data.map((item) =>
      typeof item === "string" ? item : JSON.stringify(item)
    );

    await this.collection.add({
      ids,
      documents,
      metadatas: [
        {
          contextId: contextId,
          timestamp: Date.now(),
        },
      ],
    });
  }

  /**
   * Searches for similar documents in the vector store
   * @param contextId - Context to search within
   * @param query - Query text to search for
   * @returns Array of matching documents
   */
  async query(contextId: string, query: string): Promise<any[]> {
    const results = await this.collection.query({
      queryTexts: [query],
      nResults: 5,
      where: {
        contextId: contextId,
      },
    });

    return results.documents[0] || [];
  }

  /**
   * Creates a new index in ChromaDB
   * @param indexName - Name of the index to create
   */
  async createIndex(indexName: string): Promise<void> {
    await this.client.getOrCreateCollection({
      name: indexName,
      embeddingFunction: this.embedder,
    });
  }

  /**
   * Deletes an existing index from ChromaDB
   * @param indexName - Name of the index to delete
   */
  async deleteIndex(indexName: string): Promise<void> {
    await this.collection.delete({
      where: {
        indexName: indexName,
      },
    });
  }
}

/**
 * Factory function to create a new ChromaVectorStore instance
 * @param collectionName - Name of the ChromaDB collection to use (defaults to "default")
 * @param connection - Optional connection string for ChromaDB
 * @param embedder - Optional custom embedding function implementation
 * @returns A new ChromaVectorStore instance
 */
export function createChromaVectorStore(
  collectionName: string = "default",
  connection?: string,
  embedder?: IEmbeddingFunction
) {
  return new ChromaVectorStore(collectionName, connection, embedder);
}

--- End File: packages/chroma/src/chroma.ts ---

--- File: packages/chroma/src/index.ts ---
export * from "./chroma";

--- End File: packages/chroma/src/index.ts ---

--- File: packages/cli/package.json ---
{
  "name": "@daydreamsai/cli",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "zod": "^3.24.2"
  }
}

--- End File: packages/cli/package.json ---

--- File: packages/cli/src/cli.ts ---
import * as readline from "readline/promises";
import { service, context, input, extension, output } from "@daydreamsai/core";
import { z } from "zod";

export const readlineService = service({
  register(container) {
    container.singleton("readline", () =>
      readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      })
    );
  },
});

export const cli = context({
  type: "cli",
  key: ({ user }) => user.toString(),
  schema: { user: z.string() },
  inputs: {
    "cli:message": input({
      async subscribe(send, { container }) {
        const rl = container.resolve<readline.Interface>("readline");

        const controller = new AbortController();

        while (!controller.signal.aborted) {
          const question = await rl.question("> ");
          if (question === "exit") {
            break;
          }
          console.log("User:", question);
          send(cli, { user: "admin" }, question);
        }

        return () => {
          controller.abort();
        };
      },
    }),
  },
  outputs: {
    "cli:message": output({
      description: "Send messages to the user",
      instructions: "Use plain text",
      schema: z.string(),
      handler(data) {
        console.log("Agent:", { data });
        return {
          data,
        };
      },
      examples: [
        `<output type="cli:message">Hi, How can I assist you today?</output>`,
      ],
    }),
  },
});

export const cliExtension = extension({
  name: "cli",
  contexts: {
    cli,
  },
  services: [readlineService],
});

--- End File: packages/cli/src/cli.ts ---

--- File: packages/cli/src/index.ts ---
export * from "./cli";

--- End File: packages/cli/src/index.ts ---

--- File: packages/core/package.json ---
{
  "name": "@daydreamsai/core",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "publishConfig": {
    "main": "./dist/index.js",
    "module": "./dist/index.js",
    "types": "./dist/index.d.ts",
    "exports": {
      "./package.json": "./package.json",
      ".": {
        "types": "./dist/index.d.ts",
        "require": "./dist/index.js",
        "import": "./dist/index.js"
      }
    }
  },
  "devDependencies": {
    "@ai-sdk/anthropic": "^1.2.3",
    "@ai-sdk/groq": "^1.2.2",
    "@ai-sdk/openai": "^1.3.5",
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@ai-sdk/provider": "^1.1.0",
    "@ai-sdk/ui-utils": "^1.2.3",
    "ai": "^4.2.9",
    "dotenv": "^16.4.7",
    "p-defer": "^4.0.1",
    "uuid": "^11.1.0",
    "zod": "^3.24.2",
    "zod-to-json-schema": "^3.24.1"
  }
}

--- End File: packages/core/package.json ---

--- File: packages/core/src/configs.ts ---
type ModelConfig = {
  assist?: boolean;
  prefix?: string;
  thinkTag?: string;
};

export const modelsResponseConfig: Record<string, ModelConfig> = {
  "o3-mini": {
    assist: false,
    prefix: "",
  },
  "claude-3-7-sonnet-20250219": {},
  "qwen-qwq-32b": {
    prefix: "",
  },
  // "google/gemini-2.0-flash-001": {},
  "deepseek-r1-distill-llama-70b": {
    prefix: "",
    assist: false,
  },
};

export const reasoningModels = [
  "claude-3-7-sonnet-20250219",
  "qwen-qwq-32b",
  "deepseek-r1-distill-llama-70b",
  "o3-mini",
];

--- End File: packages/core/src/configs.ts ---

--- File: packages/core/src/container.ts ---
/**
 * Represents a constructor function that creates an instance of type T.
 */
type Constructor<T> = new (...args: any[]) => T;

/**
 * Represents a factory function that creates an instance of type T using the container.
 */
type Factory<T> = (container: Container) => T;

/**
 * Represents any function type.
 */
type FunctionType = (...args: any[]) => any;

/**
 * Represents a dependency injection token that can be a string, symbol, constructor, or function.
 */
type Token = string | symbol | Constructor<any> | FunctionType;

/**
 * Interface for a dependency injection container.
 */
export interface Container {
  /**
   * Registers a factory function for a token.
   * Each time the token is resolved, the factory will be called to create a new instance.
   *
   * @param token - The token to register
   * @param factory - The factory function that creates the instance
   * @returns The container instance for chaining
   */
  register: <T>(token: Token, factory: Factory<T>) => Container;

  /**
   * Registers a singleton factory function for a token.
   * The factory will be called only once when the token is first resolved,
   * and the same instance will be returned for subsequent resolutions.
   *
   * @param token - The token to register
   * @param factory - The factory function that creates the singleton instance
   * @returns The container instance for chaining
   */
  singleton: <T>(token: Token, factory: Factory<T>) => Container;

  /**
   * Registers a pre-created instance for a token.
   *
   * @param token - The token to register
   * @param instance - The instance to register
   * @returns The container instance for chaining
   */
  instance: <T>(token: Token, instance: T) => Container;

  /**
   * Creates an alias for an existing token.
   *
   * @param aliasToken - The alias token (must be a string or symbol)
   * @param originalToken - The original token to alias
   * @returns The container instance for chaining
   */
  alias: (aliasToken: string | symbol, originalToken: Token) => Container;

  /**
   * Resolves a token to its registered instance.
   *
   * @param token - The token to resolve
   * @returns The resolved instance
   * @throws Error if no registration is found for the token
   */
  resolve: <T>(token: Token) => T;
}

/**
 * Creates a new dependency injection container.
 *
 * @returns A new Container instance
 *
 * @example
 * ```typescript
 * const container = createContainer();
 *
 * // Register a transient dependency
 * container.register('logger', () => new Logger());
 *
 * // Register a singleton
 * container.singleton('database', (c) => new Database(c.resolve('config')));
 *
 * // Register a pre-created instance
 * container.instance('config', { connectionString: 'mongodb://localhost:27017' });
 *
 * // Create an alias
 * container.alias('db', 'database');
 *
 * // Resolve dependencies
 * const db = container.resolve<Database>('db');
 * ```
 */
export const createContainer = (): Container => {
  const instances = new Map<Token, any>();
  const factories = new Map<Token, Factory<any>>();
  const singletons = new Set<Token>();
  const aliases = new Map<string | symbol, Token>();

  /**
   * Converts a token to a string representation for error messages.
   */
  const getTokenString = (token: Token): string => {
    if (typeof token === "string") return token;
    if (typeof token === "symbol") return token.toString();
    if (typeof token === "function") {
      return token.name || "anonymous function";
    }
    return "unknown token";
  };

  /**
   * Resolves a token to its original token if it's an alias.
   */
  const resolveToken = (token: Token): Token => {
    if (typeof token === "string" || typeof token === "symbol") {
      return aliases.get(token) || token;
    }
    return token;
  };

  const container: Container = {
    register: <T>(token: Token, factory: Factory<T>): Container => {
      factories.set(token, factory);
      instances.delete(token);
      return container;
    },

    singleton: <T>(token: Token, factory: Factory<T>): Container => {
      factories.set(token, factory);
      singletons.add(token);
      instances.delete(token);
      return container;
    },

    instance: <T>(token: Token, value: T): Container => {
      instances.set(token, value);
      factories.delete(token);
      singletons.delete(token);
      return container;
    },

    alias: (aliasToken: string | symbol, originalToken: Token): Container => {
      aliases.set(aliasToken, originalToken);
      return container;
    },

    resolve: <T>(token: Token): T => {
      const resolvedToken = resolveToken(token);

      if (instances.has(resolvedToken)) {
        return instances.get(resolvedToken);
      }

      const factory = factories.get(resolvedToken);
      if (!factory) {
        throw new Error(
          `No registration found for ${getTokenString(resolvedToken)}`
        );
      }

      if (singletons.has(resolvedToken)) {
        if (!instances.has(resolvedToken)) {
          instances.set(resolvedToken, factory(container));
        }
        return instances.get(resolvedToken);
      }

      return factory(container);
    },
  };

  return container;
};

--- End File: packages/core/src/container.ts ---

--- File: packages/core/src/context.ts ---
import { z, type ZodRawShape } from "zod";
import type {
  AnyAction,
  AnyAgent,
  AnyContext,
  AnyRef,
  Context,
  ContextConfig,
  ContextSettings,
  ContextState,
  InferSchemaArguments,
  Log,
  WorkingMemory,
} from "./types";
import { formatContextLog } from "./formatters";
import { memory } from "./utils";

/**
 * Creates a context configuration
 * @template Memory - Type of working memory
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 * @param ctx - Context configuration object
 * @returns Typed context configuration
 */

export function context<
  TMemory = any,
  Args extends z.ZodTypeAny | ZodRawShape = any,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<
    string,
    z.ZodTypeAny | z.ZodRawShape
  >,
>(
  config: ContextConfig<TMemory, Args, Ctx, Actions, Events>
): Context<TMemory, Args, Ctx, Actions, Events> {
  const ctx: Context<TMemory, Args, Ctx, Actions, Events> = {
    ...config,
    setActions(actions) {
      Object.assign(ctx, { actions });
      return ctx as any;
    },
    setInputs(inputs) {
      ctx.inputs = inputs;
      return ctx;
    },
    setOutputs(outputs) {
      ctx.outputs = outputs;
      return ctx;
    },
    use(composer) {
      ctx.__composers = ctx.__composers?.concat(composer) ?? [composer];
      return ctx;
    },
  };

  return ctx;
}

/**
 * Retrieves and sorts working memory logs
 * @param memory - Working memory object
 * @param includeThoughts - Whether to include thought logs (default: true)
 * @returns Sorted array of memory logs
 */
export function getWorkingMemoryLogs(
  memory: Partial<WorkingMemory>,
  includeThoughts = true
): Log[] {
  return [
    ...(memory.inputs ?? []),
    ...(memory.outputs ?? []),
    ...(memory.calls ?? []),
    ...((includeThoughts ? memory.thoughts : undefined) ?? []),
    ...(memory.results ?? []),
    ...(memory.events ?? []),
  ].sort((a, b) => (a.timestamp > b.timestamp ? 1 : -1));
}

export function getWorkingMemoryAllLogs(
  memory: Partial<WorkingMemory>,
  includeThoughts = true
): AnyRef[] {
  return [
    ...(memory.inputs ?? []),
    ...(memory.outputs ?? []),
    ...(memory.calls ?? []),
    ...((includeThoughts ? memory.thoughts : undefined) ?? []),
    ...(memory.results ?? []),
    ...(memory.events ?? []),
    ...(memory.steps ?? []),
    ...(memory.runs ?? []),
  ].sort((a, b) => (a.timestamp >= b.timestamp ? 1 : -1));
}

export function formatWorkingMemory({
  memory,
  processed,
  size,
}: {
  memory: Partial<WorkingMemory>;
  processed: boolean;
  size?: number;
}) {
  let logs = getWorkingMemoryLogs(memory, false).filter(
    (i) => i.processed === processed
  );

  if (size) {
    logs = logs.slice(-size);
  }

  return logs.map((i) => formatContextLog(i)).flat();
}

/**
 * Creates a default working memory object
 * @returns Empty working memory with initialized arrays
 */
export function createWorkingMemory(): WorkingMemory {
  return {
    inputs: [],
    outputs: [],
    thoughts: [],
    calls: [],
    results: [],
    runs: [],
    steps: [],
    events: [],
  };
}

export function pushToWorkingMemory(workingMemory: WorkingMemory, ref: AnyRef) {
  switch (ref.ref) {
    case "action_call":
      workingMemory.calls.push(ref);
      break;
    case "action_result":
      workingMemory.results.push(ref);
      break;
    case "input":
      workingMemory.inputs.push(ref);
      break;
    case "output":
      workingMemory.outputs.push(ref);
      break;
    case "thought":
      workingMemory.thoughts.push(ref);
      break;
    case "event":
      workingMemory.events.push(ref);
      break;
    case "step":
      workingMemory.steps.push(ref);
      break;
    case "run":
      workingMemory.runs.push(ref);
      break;
    default:
      throw new Error("invalid ref");
  }
}

/**
 * Default working memory config
 * Provides a memory container with standard working memory structure
 */
export const defaultWorkingMemory = memory<WorkingMemory>({
  key: "working-memory",
  create: createWorkingMemory,
});

export function getContextId<TContext extends AnyContext>(
  context: TContext,
  args: z.infer<TContext["schema"]>
) {
  const key = context.key ? context.key(args) : undefined;
  return key ? [context.type, key].join(":") : context.type;
}

export async function createContextState<TContext extends AnyContext>({
  agent,
  context,
  args,
  contexts = [],
  settings: initialSettings = {},
}: {
  agent: AnyAgent;
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
  contexts?: string[];
  settings?: ContextSettings;
}): Promise<ContextState<TContext>> {
  const key = context.key ? context.key(args) : undefined;
  const id = key ? [context.type, key].join(":") : context.type;

  const settings: ContextSettings = {
    model: context.model,
    maxSteps: context.maxSteps,
    maxWorkingMemorySize: context.maxWorkingMemorySize,
    ...initialSettings,
  };

  const options = context.setup
    ? await context.setup(args, settings, agent)
    : {};

  const memory =
    (context.load
      ? await context.load(id, { options, settings })
      : await agent.memory.store.get(`memory:${id}`)) ??
    (context.create
      ? await Promise.try(
          context.create,
          { key, args, id, options, settings },
          agent
        )
      : {});

  return {
    id,
    key,
    args,
    options,
    context,
    memory,
    settings,
    contexts,
  };
}

export async function getContextWorkingMemory(
  agent: AnyAgent,
  contextId: string
) {
  let workingMemory = await agent.memory.store.get<WorkingMemory>(
    ["working-memory", contextId].join(":")
  );

  if (!workingMemory) {
    workingMemory = await defaultWorkingMemory.create();
    await agent.memory.store.set(
      ["working-memory", contextId].join(":"),
      workingMemory
    );
  }

  return workingMemory;
}

export async function saveContextWorkingMemory(
  agent: AnyAgent,
  contextId: string,
  workingMemory: WorkingMemory
) {
  return await agent.memory.store.set(
    ["working-memory", contextId].join(":"),
    workingMemory
  );
}

type ContextStateSnapshot = {
  id: string;
  type: string;
  args: any;
  key?: string;
  settings: Omit<ContextSettings, "model"> & { model?: string };
  contexts: string[];
};

export async function saveContextState(agent: AnyAgent, state: ContextState) {
  const { id, context, key, args, settings, contexts } = state;
  await agent.memory.store.set<ContextStateSnapshot>(`context:${id}`, {
    id,
    type: context.type,
    key,
    args,
    settings: {
      ...settings,
      model: settings.model?.modelId,
    },
    contexts,
  });

  if (state.context.save) {
    await state.context.save(state);
  } else {
    await agent.memory.store.set<any>(`memory:${id}`, state.memory);
  }
}
export async function loadContextState(
  agent: AnyAgent,
  context: AnyContext,
  contextId: string
): Promise<Omit<ContextState, "options" | "memory"> | null> {
  const state = await agent.memory.store.get<ContextStateSnapshot>(
    `context:${contextId}`
  );

  if (!state) return null;

  return {
    ...state,
    context,
    settings: {
      ...state?.settings,
      // todo: agent resolve model?
      model: undefined,
    },
  };
}

export async function saveContextsIndex(
  agent: AnyAgent,
  contextIds: Set<string>
) {
  await agent.memory.store.set<string[]>(
    "contexts",
    Array.from(contextIds.values())
  );
}

function getContextData(
  contexts: Map<string, ContextState>,
  contextId: string
) {
  // todo: verify type?
  if (contexts.has(contextId)) {
    const state = contexts.get(contextId)!;
    return {
      id: contextId,
      type: state.context.type,
      key: state.key,
      args: state.args,
      settings: state.settings,
    };
  }

  const [type, key] = contextId.split(":");

  return {
    id: contextId,
    type,
    key,
  };
}

export function getContexts(
  contextIds: Set<string>,
  contexts: Map<string, ContextState>
) {
  return Array.from(contextIds.values())
    .filter((t) => !!t)
    .map((id) => getContextData(contexts, id));
}

export async function deleteContext(agent: AnyAgent, contextId: string) {
  await agent.memory.store.delete(`context:${contextId}`);
  await agent.memory.store.delete(`memory:${contextId}`);
  await agent.memory.store.delete(`working-memory:${contextId}`);
}

--- End File: packages/core/src/context.ts ---

--- File: packages/core/src/dreams.ts ---
import { z } from "zod";
import type {
  Agent,
  AnyContext,
  Config,
  Debugger,
  Subscription,
  ContextState,
  Episode,
  Registry,
  InputRef,
  WorkingMemory,
  Log,
  AnyRef,
  LogChunk,
} from "./types";
import { Logger } from "./logger";
import { createContainer } from "./container";
import { createServiceManager } from "./serviceProvider";
import { TaskRunner } from "./task";
import {
  getContextId,
  createContextState,
  getContextWorkingMemory,
  saveContextWorkingMemory,
  saveContextState,
  saveContextsIndex,
  loadContextState,
  getContexts,
  deleteContext,
} from "./context";
import { createMemoryStore } from "./memory";
import { createMemory } from "./memory";
import { createVectorStore } from "./memory/base";
import { runGenerate } from "./tasks";
import { exportEpisodesAsTrainingData } from "./memory/utils";
import { LogLevel } from "./types";
import { randomUUIDv7, tryAsync } from "./utils";
import { createContextStreamHandler, handleStream } from "./streaming";
import { mainPrompt, promptTemplate } from "./prompts/main";
import { createEngine } from "./engine";
import type { DeferredPromise } from "p-defer";

export function createDreams<TContext extends AnyContext = AnyContext>(
  config: Config<TContext>
): Agent<TContext> {
  let booted = false;

  const inputSubscriptions = new Map<string, Subscription>();

  const contextIds = new Set<string>();
  const contexts = new Map<string, ContextState>();
  const contextsRunning = new Map<
    string,
    {
      defer: DeferredPromise<AnyRef[]>;
      controller: AbortController;
      push: (log: Log) => Promise<void>;
    }
  >();

  const workingMemories = new Map<string, WorkingMemory>();

  const ctxSubscriptions = new Map<
    string,
    Set<(ref: AnyRef, done: boolean) => void>
  >();

  const __ctxChunkSubscriptions = new Map<
    string,
    Set<(chunk: LogChunk) => void>
  >();

  // todo register everything into registry, remove from agent
  const registry: Registry = {
    contexts: new Map(),
    actions: new Map(),
    outputs: new Map(),
    inputs: new Map(),
    extensions: new Map(),
    models: new Map(),
    prompts: new Map(),
  };

  registry.prompts.set("step", promptTemplate);

  const {
    inputs = {},
    outputs = {},
    events = {},
    actions = [],
    experts = {},
    services = [],
    extensions = [],
    model,
    reasoningModel,
    exportTrainingData,
    trainingDataPath,
  } = config;

  const container = config.container ?? createContainer();

  const taskRunner = config.taskRunner ?? new TaskRunner(3);

  const logger =
    config.logger ??
    new Logger({
      level: config.logLevel ?? LogLevel.INFO,
    });

  if (config.logger && config.logLevel !== undefined) {
    logger.configure({ level: config.logLevel });
  }

  container.instance("logger", logger);

  const debug: Debugger = (...args) => {
    if (!config.debugger) return;
    try {
      config.debugger(...args);
    } catch {
      console.log("debugger failed");
    }
  };

  const serviceManager = createServiceManager(container);

  for (const service of services) {
    serviceManager.register(service);
  }

  if (config.contexts) {
    for (const ctx of config.contexts) {
      registry.contexts.set(ctx.type, ctx);
    }
  }

  for (const extension of extensions) {
    if (extension.inputs) Object.assign(inputs, extension.inputs);
    if (extension.outputs) Object.assign(outputs, extension.outputs);
    if (extension.events) Object.assign(events, extension.events);
    if (extension.actions) actions.push(...extension.actions);
    if (extension.services) {
      for (const service of extension.services) {
        serviceManager.register(service);
      }
    }

    if (extension.contexts) {
      for (const context of Object.values(extension.contexts)) {
        registry.contexts.set(context.type, context);
      }
    }
  }

  const agent: Agent<TContext> = {
    logger,
    inputs,
    outputs,
    events,
    actions,
    experts,
    memory:
      config.memory ?? createMemory(createMemoryStore(), createVectorStore()),
    container,
    model,
    reasoningModel,
    taskRunner,
    debugger: debug,
    context: config.context ?? undefined,
    exportTrainingData,
    trainingDataPath,
    registry,
    emit: (event: string, data: any) => {
      logger.debug("agent:event", event, data);
    },

    isBooted() {
      return booted;
    },

    subscribeContext(contextId, handler) {
      if (!ctxSubscriptions.has(contextId)) {
        ctxSubscriptions.set(contextId, new Set());
      }

      const subs = ctxSubscriptions.get(contextId)!;

      if (subs.has(handler)) {
        throw new Error("handler already registered");
      }

      subs.add(handler);

      return () => {
        subs.delete(handler);
      };
    },

    __subscribeChunk(contextId, handler) {
      if (!__ctxChunkSubscriptions.has(contextId)) {
        __ctxChunkSubscriptions.set(contextId, new Set());
      }

      const subs = __ctxChunkSubscriptions.get(contextId)!;

      if (subs.has(handler)) {
        throw new Error("handler already registered");
      }

      subs.add(handler);

      return () => {
        subs.delete(handler);
      };
    },

    async getAgentContext() {
      return agent.context
        ? await agent.getContext({
            context: agent.context,
            args: contexts.get("agent:context")!.args,
          })
        : undefined;
    },

    async getContexts() {
      return getContexts(contextIds, contexts);
    },

    async getContextById<TContext extends AnyContext>(
      id: string
    ): Promise<ContextState<TContext> | null> {
      if (contexts.has(id)) return contexts.get(id)! as ContextState<TContext>;

      const [type] = id.split(":");

      const context = registry.contexts.get(type) as TContext | undefined;

      if (context && contextIds.has(id)) {
        const stateSnapshot = await loadContextState(agent, context, id);

        if (stateSnapshot) {
          const state = await createContextState({
            agent,
            context,
            args: stateSnapshot.args,
            settings: stateSnapshot.settings,
            contexts: stateSnapshot.contexts,
          });

          await this.saveContext(state);

          return state;
        }
      }

      return null;
    },

    async getContext(params) {
      if (!registry.contexts.has(params.context.type))
        registry.contexts.set(params.context.type, params.context);

      const ctxSchema = params.context.schema
        ? "parse" in params.context.schema
          ? params.context.schema
          : z.object(params.context.schema)
        : undefined;

      const args = ctxSchema ? ctxSchema.parse(params.args) : {};
      const id = getContextId(params.context, args);

      if (!contexts.has(id) && contextIds.has(id)) {
        const stateSnapshot = await loadContextState(agent, params.context, id);

        if (stateSnapshot) {
          await this.saveContext(
            await createContextState({
              agent,
              context: params.context,
              args: params.args,
              settings: stateSnapshot.settings,
              contexts: stateSnapshot.contexts,
            })
          );
        }
      }

      if (!contexts.has(id)) {
        await this.saveContext(
          await createContextState({
            agent,
            context: params.context,
            args: params.args,
          })
        );
      }

      return contexts.get(id)! as ContextState<typeof params.context>;
    },

    async loadContext(params) {
      if (!registry.contexts.has(params.context.type))
        registry.contexts.set(params.context.type, params.context);

      const ctxSchema =
        "parse" in params.context.schema
          ? params.context.schema
          : z.object(params.context.schema);

      const args = ctxSchema.parse(params.args);
      const id = getContextId(params.context, args);

      if (!contexts.has(id) && contextIds.has(id)) {
        const stateSnapshot = await loadContextState(agent, params.context, id);

        if (stateSnapshot) {
          await this.saveContext(
            await createContextState({
              agent,
              context: params.context,
              args: params.args,
              settings: stateSnapshot.settings,
              contexts: stateSnapshot.contexts,
            })
          );
        }
      }

      return (contexts.get(id) as ContextState<typeof params.context>) ?? null;
    },

    async saveContext(ctxState, workingMemory) {
      contextIds.add(ctxState.id);
      contexts.set(ctxState.id, ctxState);

      await saveContextState(agent, ctxState);

      if (workingMemory) {
        workingMemories.set(ctxState.id, workingMemory);
        await saveContextWorkingMemory(agent, ctxState.id, workingMemory);
      }

      await saveContextsIndex(agent, contextIds);

      return true;
    },

    getContextId(params) {
      // logger.trace("agent:getContextId", "Getting context id", params);
      return getContextId(params.context, params.args);
    },

    async getWorkingMemory(contextId) {
      logger.trace("agent:getWorkingMemory", "Getting working memory", {
        contextId,
      });

      if (!workingMemories.has(contextId)) {
        workingMemories.set(
          contextId,
          await getContextWorkingMemory(agent, contextId)
        );
      }

      return workingMemories.get(contextId)!;
    },

    async deleteContext(contextId) {
      //todo: handle if its running;

      contexts.delete(contextId);
      contextIds.delete(contextId);

      contextsRunning.delete(contextId);
      workingMemories.delete(contextId);

      await deleteContext(agent, contextId);

      await saveContextsIndex(agent, contextIds);
    },

    async start(args) {
      if (booted) return agent;
      logger.info("agent:start", "Starting agent", { args, booted });

      booted = true;

      logger.debug("agent:start", "Booting services");
      await serviceManager.bootAll();

      logger.debug("agent:start", "Installing extensions", {
        count: extensions.length,
      });

      for (const extension of extensions) {
        if (extension.install) await tryAsync(extension.install, agent);
      }

      logger.debug("agent:start", "Setting up inputs", {
        count: Object.keys(agent.inputs).length,
      });

      const inputs = {
        ...agent.inputs,
      };

      for (const ctx of registry.contexts.values()) {
        if (ctx.inputs) Object.assign(inputs, ctx.inputs);
      }

      for (const [type, input] of Object.entries(inputs)) {
        if (input.install) {
          logger.trace("agent:start", "Installing input", { type });
          await tryAsync(input.install, agent);
        }

        if (input.subscribe) {
          logger.trace("agent:start", "Subscribing to input", { type });
          let subscription = await tryAsync<Subscription>(
            input.subscribe,
            (context: any, args: any, data: any) => {
              logger.debug("agent", "input", { context, args, data });
              agent
                .send({
                  context,
                  input: { type, data },
                  args,
                })
                .catch((err) => {
                  logger.error("agent:input", "error", err);
                });
            },
            agent
          );

          if (subscription) inputSubscriptions.set(type, subscription);
        }
      }

      logger.debug("agent:start", "Setting up outputs", {
        count: Object.keys(outputs).length,
      });

      for (const [type, output] of Object.entries(outputs)) {
        if (output.install) {
          logger.trace("agent:start", "Installing output", { type });
          await tryAsync(output.install, agent);
        }
      }

      logger.debug("agent:start", "Setting up actions", {
        count: actions.length,
      });

      for (const action of actions) {
        if (action.install) {
          logger.trace("agent:start", "Installing action", {
            name: action.name,
          });
          await tryAsync(action.install, agent);
        }
      }

      logger.debug("agent:start", "Loading saved contexts");
      const savedContexts = await agent.memory.store.get<string[]>("contexts");

      if (savedContexts) {
        logger.trace("agent:start", "Restoring saved contexts", {
          count: savedContexts.length,
        });

        for (const id of savedContexts) {
          contextIds.add(id);
        }
      }

      if (agent.context) {
        logger.debug("agent:start", "Setting up agent context", {
          type: agent.context.type,
        });

        const agentState = await agent.getContext({
          context: agent.context,
          args: args!,
        });

        contexts.set("agent:context", agentState);
      }

      logger.info("agent:start", "Agent started successfully");
      return agent;
    },

    async stop() {
      logger.info("agent:stop", "Stopping agent");
    },

    async run(params) {
      const { context, args, outputs, handlers, abortSignal } = params;
      if (!booted) {
        logger.error("agent:run", "Agent not booted");
        throw new Error("Not booted");
      }

      const model =
        params.model ?? context.model ?? config.reasoningModel ?? config.model;

      if (!model) throw new Error("no model");

      logger.info("agent:run", "Running context", {
        contextType: context.type,
        hasArgs: !!args,
        hasCustomOutputs: !!outputs,
        hasHandlers: !!handlers,
      });

      const ctxId = agent.getContextId({ context, args });

      // try to move this to state
      // we need this here now because its needed to create the handler
      // and we will use that state from contextsRunning so we need to wait before checking and creating
      const ctxState = await agent.getContext({ context, args });
      const workingMemory = await agent.getWorkingMemory(ctxId);
      const agentCtxState = await agent.getAgentContext();

      // todo: allow to control what happens when new input is sent while the ctx is running
      // context.onInput?
      // we should allow to abort the current run, or just push it to current run
      // state.controller.abort()
      if (contextsRunning.has(ctxId)) {
        logger.debug("agent:run", "Context already running", {
          id: ctxId,
        });

        const { defer, push } = contextsRunning.get(ctxId)!;
        params.chain?.forEach((el) => push(el));
        return defer.promise;
      }

      logger.debug("agent:run", "Added context to running set", {
        id: ctxId,
      });

      if (!ctxSubscriptions.has(ctxId)) {
        ctxSubscriptions.set(ctxId, new Set());
      }

      if (!__ctxChunkSubscriptions.has(ctxId)) {
        __ctxChunkSubscriptions.set(ctxId, new Set());
      }

      const engine = createEngine({
        agent,
        ctxState,
        workingMemory,
        handlers,
        agentCtxState,
        subscriptions: ctxSubscriptions.get(ctxId)!,
        __chunkSubscriptions: __ctxChunkSubscriptions.get(ctxId)!,
      });

      contextsRunning.set(ctxId, {
        controller: engine.controller,
        push: engine.push,
        defer: engine.state.defer,
      });

      const { streamState, streamHandler, tags, __streamChunkHandler } =
        createContextStreamHandler({
          abortSignal,
          pushLog(log, done) {
            engine.push(log, done, false);
          },
          __pushLogChunk(chunk) {
            engine.pushChunk(chunk);
          },
        });

      let maxSteps = 0;

      function getMaxSteps() {
        return engine.state.contexts.reduce(
          (maxSteps, ctxState) =>
            Math.max(
              maxSteps,
              ctxState.settings.maxSteps ?? ctxState.context.maxSteps ?? 0
            ),
          5
        );
      }

      await engine.setParams({
        actions: params.actions,
        outputs: params.outputs,
        contexts: params.contexts,
      });

      let stepRef = await engine.start();

      //todo: pull unprocessed, unfinished steps/runs

      if (params.chain) {
        for (const log of params.chain) {
          await engine.push(log);
        }
      }

      await engine.settled();

      const { state } = engine;

      while ((maxSteps = getMaxSteps()) >= state.step) {
        logger.info("agent:run", `Starting step ${state.step}/${maxSteps}`, {
          contextId: ctxState.id,
        });

        try {
          if (state.step > 1) {
            stepRef = await engine.nextStep();
            streamState.index++;
          }

          const promptData = mainPrompt.formatter({
            contexts: state.contexts,
            actions: state.actions,
            outputs: state.outputs,
            workingMemory,
            chainOfThoughtSize: 0,
            maxWorkingMemorySize: ctxState.settings.maxWorkingMemorySize,
          });

          const prompt = mainPrompt.render(promptData);

          stepRef.data.prompt = prompt;

          let streamError: any = null;

          const unprocessed = [
            ...workingMemory.inputs.filter((i) => i.processed === false),
            ...state.chain.filter((i) => i.processed === false),
          ];

          const { stream, getTextResponse } = await taskRunner.enqueueTask(
            runGenerate,
            {
              model,
              prompt,
              workingMemory,
              logger,
              onError: (error) => {
                streamError = error;
                // state.errors.push(error);
              },
            },
            {
              abortSignal,
            }
          );

          logger.debug("agent:run", "Processing stream", { step: state.step });

          await handleStream(
            stream,
            streamState.index,
            tags,
            streamHandler,
            __streamChunkHandler
          );

          if (streamError) {
            throw streamError;
          }

          const response = await getTextResponse();
          stepRef.data.response = response;

          unprocessed.forEach((i) => {
            i.processed = true;
          });

          logger.debug("agent:run", "Waiting for action calls to complete", {
            pendingCalls: state.promises.length,
          });

          await engine.settled();

          stepRef.processed = true;

          await saveContextWorkingMemory(agent, ctxState.id, workingMemory);

          await Promise.all(
            state.contexts.map((state) =>
              state.context.onStep?.(
                {
                  ...state,
                  workingMemory,
                },
                agent
              )
            )
          );

          await Promise.all(
            state.contexts.map((state) => agent.saveContext(state))
          );

          if (!engine.shouldContinue()) break;

          state.step++;
        } catch (error) {
          console.error(error);

          await Promise.allSettled(
            [
              saveContextWorkingMemory(agent, ctxState.id, workingMemory),
              state.contexts.map((state) => agent.saveContext(state)),
            ].flat()
          );

          if (context.onError) {
            try {
              await context.onError(
                error,
                {
                  ...ctxState,
                  workingMemory,
                },
                agent
              );
            } catch (error) {
              break;
            }
          } else {
            break;
          }
        }
      }

      await Promise.all(
        state.contexts.map((state) =>
          state.context.onRun?.(
            {
              ...state,
              workingMemory,
            },
            agent
          )
        )
      );

      await Promise.all(
        state.contexts.map((state) => agent.saveContext(state))
      );

      logger.debug("agent:run", "Removing context from running set", {
        id: ctxState.id,
      });

      contextsRunning.delete(ctxState.id);

      logger.info("agent:run", "Run completed", {
        contextId: ctxState.id,
        chainLength: state.chain.length,
      });

      state.defer.resolve(state.chain);

      return state.chain;
    },

    async send(params) {
      const inputRef: InputRef = {
        id: randomUUIDv7(),
        ref: "input",
        type: params.input.type,
        content: params.input.data,
        data: undefined,
        timestamp: Date.now(),
        processed: false,
      };

      return await agent.run({
        ...params,
        chain: params.chain ? [...params.chain, inputRef] : [inputRef],
      });
    },

    async evaluator(ctx) {
      const { id, memory } = ctx;
      logger.debug("agent:evaluator", "memory", memory);
    },

    /**
     * Exports all episodes as training data
     * @param filePath Optional path to save the training data
     */
    async exportAllTrainingData(filePath?: string) {
      logger.info(
        "agent:exportTrainingData",
        "Exporting episodes as training data"
      );

      // Get all contexts
      const contexts = await agent.getContexts();

      // Collect all episodes from all contexts
      const allEpisodes: Episode[] = [];

      for (const { id } of contexts) {
        const episodes = await agent.memory.vector.query(id, "");
        if (episodes.length > 0) {
          allEpisodes.push(...episodes);
        }
      }

      logger.info(
        "agent:exportTrainingData",
        `Found ${allEpisodes.length} episodes to export`
      );

      // Export episodes as training data
      if (allEpisodes.length > 0) {
        await exportEpisodesAsTrainingData(
          allEpisodes,
          filePath || config.trainingDataPath || "./training-data.jsonl"
        );
        logger.info(
          "agent:exportTrainingData",
          "Episodes exported successfully"
        );
      } else {
        logger.warn("agent:exportTrainingData", "No episodes found to export");
      }
    },
  };

  container.instance("agent", agent);

  return agent;
}

--- End File: packages/core/src/dreams.ts ---

--- File: packages/core/src/engine.ts ---
import {
  createResultsTemplateResolver,
  getValueByPath,
  handleActionCall,
  handleInput,
  handleOutput,
  NotFoundError,
  ParsingError,
  prepareActionCall,
  prepareContexts,
  prepareOutputRef,
  resolveActionCall,
} from "./handlers";
import type {
  ActionCall,
  ActionCtxRef,
  ActionResult,
  AnyAction,
  AnyAgent,
  AnyContext,
  AnyRef,
  ContextRef,
  ContextState,
  ContextStateApi,
  EventRef,
  Handlers,
  Input,
  InputConfig,
  InputRef,
  Log,
  Output,
  OutputCtxRef,
  OutputRef,
  RunRef,
  StepRef,
  TemplateResolver,
  WorkingMemory,
  LogChunk,
  ActionCallContext,
} from "./types";
import pDefer, { type DeferredPromise } from "p-defer";
import { pushToWorkingMemory } from "./context";
import { createEventRef, randomUUIDv7 } from "./utils";
import { ZodError, type ZodIssue } from "zod";

type CallOptions = Partial<{
  templateResolvers: Record<string, TemplateResolver>;
  queueKey: string;
}>;

// type Router<TLog extends AnyRef = AnyRef> = {
//   [K in TLog["ref"]]: K extends "action_call"
//     ? (
//         log: ActionCall,
//         options?: Partial<{
//           templateResolvers: Record<string, TemplateResolver>;
//         }>
//       ) => MaybePromise<ActionResult>
//     : TLog extends { ref: K }
//       ? (log: TLog) => MaybePromise<void>
//       : never;
// };

interface Router {
  input(ref: InputRef): Promise<void>;
  output(ref: OutputRef): Promise<OutputRef[]>;
  action_call(call: ActionCall, options: CallOptions): Promise<ActionResult>;
}

type ErrorRef = {
  log: AnyRef;
  error: unknown;
};

type State = {
  running: boolean;
  step: number;
  chain: AnyRef[];
  ctxState: ContextState;

  inputs: Input[];
  outputs: OutputCtxRef[];
  actions: ActionCtxRef[];
  contexts: ContextState[];

  promises: Promise<any>[];

  errors: ErrorRef[];

  results: Promise<ActionResult>[];

  params?: Partial<{
    outputs: Record<string, Omit<Output<any, any, any, any>, "type">>;
    inputs: Record<string, InputConfig>;
    actions: AnyAction[];
    contexts: ContextRef[];
  }>;

  defer: DeferredPromise<AnyRef[]>;
};

type Engine = ReturnType<typeof createEngine>;

export function createEngine({
  agent,
  ctxState,
  agentCtxState,
  workingMemory,
  subscriptions,
  handlers,
  __chunkSubscriptions,
}: {
  agent: AnyAgent;
  ctxState: ContextState;
  agentCtxState?: ContextState;
  workingMemory: WorkingMemory;
  subscriptions: Set<(log: AnyRef, done: boolean) => void>;
  handlers?: Partial<Handlers>;
  __chunkSubscriptions?: Set<(chunk: LogChunk) => void>;
}) {
  const controller = new AbortController();

  const state: State = {
    running: false,
    step: -1,

    ctxState,

    chain: [],

    inputs: [],
    outputs: [],
    actions: [],
    contexts: [],

    results: [],

    promises: [],

    errors: [],

    defer: pDefer<AnyRef[]>(),
  };

  function pushPromise(promise: Promise<any>) {
    state.promises.push(promise);

    promise.finally(() => {
      state.promises.splice(state.promises.indexOf(promise), 1);
    });
  }

  function pushLogToSubscribers(log: AnyRef, done: boolean) {
    try {
      handlers?.onLogStream?.(structuredClone(log), done);
    } catch (error) {}

    for (const subscriber of subscriptions) {
      try {
        subscriber(structuredClone(log), done);
      } catch (error) {}
    }
  }

  function __pushLogChunkToSubscribers(log: LogChunk) {
    if (__chunkSubscriptions) {
      for (const subscriber of __chunkSubscriptions) {
        try {
          subscriber(structuredClone(log));
        } catch (error) {}
      }
    }
  }

  async function pushLog<TRef extends AnyRef = AnyRef>(
    log: TRef,
    options?: any
  ): Promise<any> {
    // throw?
    if (!state.running) throw new Error("not running!");

    // todo: still push?
    controller.signal.throwIfAborted();

    if (log.ref !== "output") {
      state.chain.push(log);
    }

    try {
      let res: any;

      switch (log.ref) {
        case "input":
          await router.input(log);
          break;
        case "output":
          res = await router.output(log);
          break;
        case "action_call":
          res = await router.action_call(log, options);
          break;
      }

      if (log.ref !== "output") {
        pushToWorkingMemory(workingMemory, log);
      }

      return res;
    } catch (error) {
      if (log.ref === "output") {
        state.chain.push(log);
      }

      const errorRef = { log, error };

      state.errors.push(errorRef);

      __push(createErrorEvent(errorRef), true, true);

      pushToWorkingMemory(workingMemory, log);
    } finally {
      pushLogToSubscribers(log, true);
    }
  }

  async function __push<TRef extends AnyRef = AnyRef>(
    log: TRef,
    done: boolean = true,
    __pushChunk: boolean = true
  ): Promise<any> {
    try {
      if (done) {
        return await pushLog(log);
      } else {
        pushLogToSubscribers(log, false);
      }
    } finally {
      if (__pushChunk) {
        __pushLogChunkToSubscribers({
          type: "log",
          done,
          log,
        });
      }
    }
  }

  const ctxStateApi: ContextStateApi<AnyContext> = {
    push: (log) => pushLog(log),
    emit(event, args, options) {
      const eventRef: EventRef = {
        ref: "event",
        id: randomUUIDv7(),
        name: event as string,
        data: args,
        processed: options?.processed ?? true,
        timestamp: Date.now(),
      };
      __push(eventRef, true, true);
    },
    async callAction(call, options) {
      const res = await pushLog(call, options);
      __pushLogChunkToSubscribers({ type: "log", log: call, done: true });
      return res;
    },
    __getRunResults() {
      return state.results;
    },
  };

  const defaultResolvers: Record<string, TemplateResolver> = {
    calls: createResultsTemplateResolver(state.results),
    shortTermMemory: async (path) => {
      const shortTermMemory = state.contexts.find(
        (state) => state.context.type === "shortTermMemory"
      );
      if (!shortTermMemory) throw new Error("short term memory not found");
      const value = getValueByPath(shortTermMemory.memory, path);
      if (value === undefined)
        throw new Error("invalid short term memory resultPath");
      return value;
    },
  };

  async function templateResolver(
    key: string,
    path: string,
    ctx: ActionCallContext,
    resolvers: Record<string, TemplateResolver<ActionCallContext>>
  ) {
    if (resolvers[key]) return resolvers[key](path, ctx);
    throw new Error("template engine key not implemented");
  }

  const router: Router = {
    async input(log) {
      await handleInput({
        agent,
        ctxState,
        inputRef: log,
        inputs: state.inputs,
        logger: agent.logger,
        workingMemory,
      });
    },

    async action_call(call, options = {}) {
      if (call.processed) throw new Error("Already processed");
      call.processed = true;

      const defer = pDefer<ActionResult>();

      pushPromise(defer.promise);
      state.results.push(defer.promise);

      const action = resolveActionCall({
        call,
        actions: state.actions,
        logger: agent.logger,
      });

      const actionCtxState =
        state.contexts.find(
          (subCtxState: any) => subCtxState.id === action.ctxRef.id
        ) ?? ctxState;

      const templateResolvers = {
        ...defaultResolvers,
        ...ctxState.context.__templateResolvers,
        ...options.templateResolvers,
      };

      const callCtx = await prepareActionCall({
        agent,
        call,
        action,
        state: actionCtxState,
        workingMemory,
        api: ctxStateApi,
        abortSignal: controller.signal,
        agentState: agentCtxState,
        logger: agent.logger,
        templateResolver: (key, path, callCtx) =>
          templateResolver(key, path, callCtx, templateResolvers),
      }).catch((err) => {
        defer.reject(err);
        throw err;
      });

      handleActionCall({
        call,
        callCtx,
        action,
        agent,
        logger: agent.logger,
        taskRunner: agent.taskRunner,
        abortSignal: controller.signal,
        queueKey: options.queueKey,
      })
        .catch((error) => {
          const result: ActionResult = {
            ref: "action_result",
            id: randomUUIDv7(),
            callId: call.id,
            data: { error: formatError(error) },
            name: call.name,
            timestamp: Date.now(),
            processed: false,
          };

          return result;
        })
        .then((res) => {
          defer.resolve(res);
          __push(res, true, true);
          return res;
        });

      return await defer.promise;
    },

    async output(outputRef) {
      const { output } = prepareOutputRef({
        outputRef,
        outputs: state.outputs,
        logger: agent.logger,
      });

      const res = await handleOutput({
        agent,
        logger: agent.logger,
        state:
          state.contexts.find(
            (subCtxState) => subCtxState.id === output.ctxRef.id
          ) ?? ctxState,
        workingMemory,
        output,
        outputRef,
      });

      const refs = Array.isArray(res) ? res : [res];

      for (const ref of refs) {
        agent.logger.debug("agent:output", "Output processed status", {
          type: ref.type,
          processed: ref.processed,
        });

        state.chain.push(ref);

        pushToWorkingMemory(workingMemory, ref);
      }

      return refs;
    },
  };

  const runRef: RunRef = {
    id: randomUUIDv7(),
    ref: "run",
    type: ctxState.context.type,
    data: {},
    processed: false,
    timestamp: Date.now(),
  };

  async function createStep() {
    const newStep: StepRef = {
      ref: "step",
      id: randomUUIDv7(),
      step: state.step,
      type: "main",
      data: {},
      processed: false,
      timestamp: Date.now(),
    };

    await __push(newStep, true, true);

    return newStep;
  }

  return {
    state,
    controller,

    async setParams(params: State["params"]) {
      state.params = params;
    },

    async prepare() {
      const { actions, contexts, inputs, outputs } = await prepareContexts({
        agent,
        ctxState,
        agentCtxState,
        workingMemory,
        params: state.params,
      });

      Object.assign(state, { actions, contexts, inputs, outputs });
    },

    async stop() {
      controller.abort("stop");
    },

    async pushChunk(chunk: LogChunk) {
      __pushLogChunkToSubscribers(chunk);
    },

    async push(log: Log, done: boolean = true, pushChunk: boolean = true) {
      return await __push(log, done, pushChunk);
    },

    async settled() {
      while (state.promises.length > 0) {
        await Promise.allSettled(state.promises);
      }
    },

    async start() {
      if (state.running) throw new Error("alredy running");

      state.running = true;

      await this.prepare();

      await __push(runRef, true, true);

      state.step = 1;
      return createStep();
    },

    async nextStep() {
      await this.prepare();
      return createStep();
    },

    shouldContinue() {
      if (controller.signal.aborted) return false;

      if (state.errors.length > 0) {
        agent.logger.warn("agent:run", "Continuing despite error", {
          errors: state.errors,
          step: state.step,
        });
      }

      for (const ctx of state.contexts) {
        if (!ctx.context.shouldContinue) continue;

        if (
          ctx.context.shouldContinue({
            ...ctx,
            workingMemory,
          })
        )
          return true;
      }

      const pendingResults = state.chain.filter(
        (i) => i.ref !== "thought" && i.processed === false
      );

      return pendingResults.length > 0;
    },
  };
}

function prettifyZodError(error: ZodError): string {
  if (!error || !error.issues || error.issues.length === 0) {
    return "Validation failed, but no specific issues were provided.";
  }

  const errorMessages = error.issues.map((issue: ZodIssue) => {
    const pathString = issue.path.join(".");
    return `- Field \`${pathString || "object root"}\`: ${issue.message} (Code: ${issue.code})`;
  });

  return `Validation Errors:\n${errorMessages.join("\n")}`;
}

function formatError(error: unknown) {
  if (error instanceof Error) {
    return {
      name: error.name,
      message: error.message,
      cause: error.cause,
      // stack: error.stack,
    };
  }

  return JSON.stringify(error);
}

function createErrorEvent(errorRef: ErrorRef) {
  if (errorRef.error instanceof NotFoundError) {
    if (
      errorRef.error.ref.ref === "input" ||
      errorRef.error.ref.ref === "output"
    ) {
      return createEventRef({
        name: "error",
        data: {
          ref: {
            ref: errorRef.log.ref,
            id: errorRef.log.id,
            type: errorRef.error.ref.type,
          },
          error: {
            name: "NotFoundError",
            message: "Invalid type",
          },
        },
        processed: false,
      });
    } else if (errorRef.error.ref.ref === "action_call") {
      return createEventRef({
        name: "error",
        data: {
          ref: {
            ref: errorRef.log.ref,
            id: errorRef.log.id,
            name: errorRef.error.ref.name,
          },
          error: {
            name: "NotFoundError",
            message: "Invalid action name",
          },
        },
        processed: false,
      });
    }
  }

  if (errorRef.error instanceof ParsingError) {
    return createEventRef({
      name: "error",
      data: {
        ref: {
          ref: errorRef.log.ref,
          id: errorRef.log.id,
          data: errorRef.error.ref.content,
        },
        error: {
          name: "ParsingError",
          message:
            errorRef.error.parsingError instanceof ZodError
              ? prettifyZodError(errorRef.error.parsingError)
              : JSON.stringify(errorRef.error.parsingError),
        },
      },
      processed: false,
    });
  }

  return createEventRef({
    name: "error",
    data: {
      ref: {
        type: errorRef.log.ref,
        id: errorRef.log.id,
      },
      error: formatError(errorRef.error),
    },
    processed: false,
  });
}

--- End File: packages/core/src/engine.ts ---

--- File: packages/core/src/formatters.ts ---
import zodToJsonSchema from "zod-to-json-schema";
import type {
  AnyAction,
  ContextState,
  InputRef,
  Log,
  Output,
  OutputRef,
  TemplateVariables,
  XMLElement,
} from "./types";
import { z } from "zod";
import { type Schema } from "@ai-sdk/ui-utils";

export function xml(
  tag: string,
  params?: Record<string, any>,
  children?: string | XMLElement[] | any
): XMLElement {
  const el: XMLElement = {
    tag,
  };

  if (params) el.params = params;
  if (children) el.children = children;

  return el;
}

/**
 * Formats an XML element into a string representation
 * @param tag - The XML tag name
 * @param params - Optional parameters/attributes for the XML tag
 * @param content - The content of the XML element (string or nested elements)
 * @returns Formatted XML string
 */
export function formatXml(el: XMLElement): string {
  const params = el.params
    ? Object.entries(el.params)
        .map(([k, v]) => ` ${k}="${v}"`)
        .join("")
    : "";

  let children = Array.isArray(el.children)
    ? el.children.filter((t) => !!t)
    : el.children;

  if (Array.isArray(children) && children.length === 0) {
    children = "";
  }

  children =
    typeof children === "string"
      ? children
      : Array.isArray(children) && children.length > 0
        ? "\n" +
          children
            .map((el) =>
              typeof el === "string"
                ? el
                : "tag" in el
                  ? formatXml(el)
                  : formatValue(el)
            )
            .join("\n") +
          "\n"
        : formatValue(children);

  try {
    if (children === "") return `<${el.tag}${params} />`;
    return `<${el.tag}${params}>${children}</${el.tag}>`;
  } catch (error) {
    console.log("failed to format", el);
    throw error;
  }
}

/**
 * Formats an input reference into XML format
 * @param input - The input reference to format
 * @returns XML string representation of the input
 */
export function formatInput(input: InputRef) {
  return xml(
    "input",
    { name: input.type, timestamp: input.timestamp, ...input.params },
    input.data
  );
}

/**
 * Formats an output reference into XML format
 * @param output - The output reference to format
 * @returns XML string representation of the output
 */
export function formatOutput(output: OutputRef) {
  return xml(
    "output",
    { name: output.type, timestamp: output.timestamp, ...output.params },
    output.data ?? output.content
  );
}

export function formatSchema(schema: any, key: string = "schema") {
  return "_type" in schema
    ? (schema as Schema).jsonSchema
    : zodToJsonSchema("parse" in schema ? schema : z.object(schema), key)
        .definitions![key];
}

/**
 * Formats an output interface definition into XML format
 * @param output - The output interface to format
 * @returns XML string representation of the output interface
 */
export function formatOutputInterface(output: Output<any>) {
  const params: Record<string, string> = {
    type: output.type,
  };

  if (output.required) {
    params.required = "true";
  }

  return xml("output", params, [
    output.description
      ? { tag: "description", children: output.description }
      : null,
    output.instructions
      ? { tag: "instructions", children: output.instructions }
      : null,
    {
      tag: "attributes_schema",
      children: output.attributes
        ? formatSchema(output.attributes, "attributes")
        : {},
    },
    {
      tag: "content_schema",
      children: formatSchema(output.schema ?? z.string(), "content"),
    },
    output.examples
      ? {
          tag: "examples",
          children: output.examples,
        }
      : null,
  ]);
}

export function formatAction(action: AnyAction) {
  return xml("action", { name: action.name }, [
    action.description
      ? {
          tag: "description",
          children: action.description,
        }
      : null,
    action.instructions
      ? {
          tag: "instructions",
          children: action.instructions,
        }
      : null,
    {
      tag: "format",
      children: action.callFormat?.toUpperCase() ?? "JSON",
    },
    action.schema
      ? {
          tag: "schema",
          children: formatSchema(action.schema, "schema"),
        }
      : null,
    action.returns
      ? {
          tag: "returns",
          children: formatSchema(action.returns, "returns"),
        }
      : null,
    action.examples
      ? {
          tag: "examples",
          children: action.examples,
        }
      : null,
  ]);
}

export function formatContextState(state: ContextState) {
  const { context, key } = state;
  const params: Record<string, string> = { type: context.type };

  if (key) {
    params.key = key;
  }

  return xml(
    "context",
    params,
    [
      context.description
        ? {
            tag: "description",
            children:
              typeof context.description === "function"
                ? context.description(state)
                : context.description,
          }
        : null,
      context.instructions
        ? {
            tag: "instructions",
            children:
              typeof context.instructions === "function"
                ? context.instructions(state)
                : context.instructions,
          }
        : null,
      {
        tag: "state",
        children: context.render ? context.render(state) : state.memory,
      },
    ].flat()
  );
}

export type Msg =
  | {
      role: "user";
      user: string;
      content: string;
    }
  | {
      role: "assistant";
      content: string;
    };

export function formatMsg(msg: Msg): XMLElement {
  return {
    tag: "msg",
    params:
      msg.role === "user"
        ? {
            role: "user",
            user: msg.user,
          }
        : { role: "assistant" },
    children: msg.content,
  };
}

export function formatContextLog(i: Log) {
  switch (i.ref) {
    case "input":
      return i.formatted ?? formatInput(i);
    case "output":
      return i.formatted ?? formatOutput(i);
    case "thought":
      return xml("reasoning", {}, i.content);
    case "action_call":
      return xml(
        "action_call",
        { id: i.id, name: i.name, timestamp: i.timestamp },
        i.data ?? i.content
      );
    case "action_result":
      return xml(
        "action_result",
        { callId: i.callId, name: i.name, timestamp: i.timestamp },
        i.formatted ?? i.data
      );
    case "event":
      return xml("event", { name: i.name, ...i.params }, i.formatted ?? i.data);
    default:
      throw new Error("invalid context");
  }
}

/**
 * Formats a value for template rendering
 * @param value - The value to format
 * @returns Formatted string representation of the value
 */
export function formatValue(value: any): string {
  if (typeof value !== "string")
    return JSON.stringify(value, (_, value) => {
      if (typeof value === "bigint") return value.toString();
      return value;
    });
  return value.trim();
}

/**
 * Renders a template string by replacing variables with provided values
 * @template Template - The template string type containing variables in {{var}} format
 * @param str - The template string to render
 * @param data - Object containing values for template variables
 * @returns The rendered string with variables replaced
 */
export function render<Template extends string>(
  str: Template,
  data: TemplateVariables<Template>
) {
  return str.trim().replace(/\{\{(\w+)\}\}/g, (match, key: string) => {
    const value: any = data[key as keyof typeof data] ?? "";

    if (typeof value === "object") {
      if (value && "tag" in value) return formatXml(value as XMLElement);
      if (value) formatValue(value);
    }

    if (Array.isArray(value)) {
      return value
        .map((v) => {
          if (typeof v === "object" && v && "tag" in v) {
            return formatXml(v);
          }
          return formatValue(v);
        })
        .join("\n");
    }

    return value ?? "";
  });
}

--- End File: packages/core/src/formatters.ts ---

--- File: packages/core/src/handlers.ts ---
import { z, ZodSchema } from "zod";
import type { Logger } from "./logger";
import type { TaskRunner } from "./task";
import { runAction } from "./tasks";
import type {
  ActionCall,
  ActionCallContext,
  ActionCtxRef,
  ActionResult,
  AnyAction,
  AnyAgent,
  AnyContext,
  AnyOutput,
  Context,
  ContextRef,
  ContextState,
  ContextStateApi,
  Input,
  InputConfig,
  InputRef,
  MaybePromise,
  Memory,
  Output,
  OutputCtxRef,
  OutputRef,
  Resolver,
  TemplateResolver,
  WorkingMemory,
} from "./types";
import { randomUUIDv7 } from "./utils";
import { parse } from "./xml";
import { jsonPath } from "./jsonpath";
import { jsonSchema } from "ai";

export class NotFoundError extends Error {
  name = "NotFoundError";
  constructor(public ref: ActionCall | OutputRef | InputRef) {
    super();
  }
}

export class ParsingError extends Error {
  name = "ParsingError";
  constructor(
    public ref: ActionCall | OutputRef | InputRef,
    public parsingError: unknown
  ) {
    super();
  }
}

function parseJSONContent(content: string) {
  if (content.startsWith("```json")) {
    content = content.slice("```json".length, -3);
  }

  return JSON.parse(content);
}

function parseXMLContent(content: string) {
  const nodes = parse(content, (node) => {
    return node;
  });

  const data = nodes.reduce(
    (data, node) => {
      if (node.type === "element") {
        data[node.name] = node.content;
      }
      return data;
    },
    {} as Record<string, string>
  );

  return data;
}

export interface TemplateInfo {
  path: (string | number)[];
  template_string: string;
  expression: string;
  primary_key: string | null;
}

export function detectTemplates(obj: unknown): TemplateInfo[] {
  const foundTemplates: TemplateInfo[] = [];
  const templatePattern = /^\{\{(.*)\}\}$/; // Matches strings that *only* contain {{...}}
  const primaryKeyPattern = /^([a-zA-Z_][a-zA-Z0-9_]*)/; // Extracts the first identifier (simple version)

  function traverse(
    currentObj: unknown,
    currentPath: (string | number)[]
  ): void {
    if (typeof currentObj === "object" && currentObj !== null) {
      if (Array.isArray(currentObj)) {
        currentObj.forEach((item, index) => {
          traverse(item, [...currentPath, index]);
        });
      } else {
        // Handle non-array objects (assuming Record<string, unknown> or similar)
        for (const key in currentObj) {
          if (Object.prototype.hasOwnProperty.call(currentObj, key)) {
            // Use type assertion if necessary, depending on your exact object types
            traverse((currentObj as Record<string, unknown>)[key], [
              ...currentPath,
              key,
            ]);
          }
        }
      }
    } else if (typeof currentObj === "string") {
      const match = currentObj.match(templatePattern);
      if (match) {
        const expression = match[1].trim();
        const primaryKeyMatch = expression.match(primaryKeyPattern);
        const primaryKey = primaryKeyMatch ? primaryKeyMatch[1] : null;

        foundTemplates.push({
          path: currentPath,
          template_string: currentObj,
          expression: expression,
          primary_key: primaryKey,
        });
      }
    }
  }

  traverse(obj, []);
  return foundTemplates;
}

export function getPathSegments(pathString: string) {
  const segments = pathString.split(/[.\[\]]+/).filter(Boolean);
  return segments;
}

export function resolvePathSegments<T = any>(
  source: any,
  segments: string[]
): T | undefined {
  let current: any = source;

  for (const segment of segments) {
    if (current === null || current === undefined) {
      return undefined;
    }

    // Check if segment is an array index
    const index = parseInt(segment, 10);
    if (!isNaN(index) && Array.isArray(current)) {
      current = current[index];
    } else if (typeof current === "object") {
      current = current[segment];
    } else {
      return undefined; // Cannot access property on non-object/non-array
    }
  }

  return current;
}

/**
 * Native implementation to safely get a nested value from an object/array
 * using a string path like 'a.b[0].c'.
 */
export function getValueByPath(source: any, pathString: string): any {
  if (!pathString) {
    return source; // Return the source itself if path is empty
  }

  // Basic path segment splitting (handles dot notation and array indices)
  // More robust parsing might be needed for complex cases (e.g., keys with dots/brackets)
  const segments = getPathSegments(pathString);

  return resolvePathSegments(source, segments);
}

/**
 * Native implementation to safely set a nested value in an object/array
 * using a path array (like the one from detectTemplates).
 * Creates nested structures if they don't exist.
 */
function setValueByPath(
  target: any,
  path: (string | number)[],
  value: any
): void {
  let current: any = target;
  const lastIndex = path.length - 1;

  for (let i = 0; i < lastIndex; i++) {
    const key = path[i];
    const nextKey = path[i + 1];

    if (current[key] === null || current[key] === undefined) {
      // If the next key looks like an array index, create an array, otherwise an object
      current[key] = typeof nextKey === "number" ? [] : {};
    }
    current = current[key];

    // Safety check: if current is not an object/array, we can't proceed
    if (typeof current !== "object" || current === null) {
      console.error(
        `Cannot set path beyond non-object at segment ${i} ('${key}') for path ${path.join(".")}`
      );
      return;
    }
  }

  // Set the final value
  const finalKey = path[lastIndex];
  if (typeof current === "object" && current !== null) {
    current[finalKey] = value;
  } else {
    console.error(
      `Cannot set final value, parent at path ${path.slice(0, -1).join(".")} is not an object.`
    );
  }
}

/**
 * Resolves detected templates in an arguments object using provided data sources.
 * Modifies the input object directly. Uses native helper functions.
 */
export async function resolveTemplates(
  argsObject: any, // The object containing templates (will be mutated)
  detectedTemplates: TemplateInfo[],
  resolver: (primary_key: string, path: string) => Promise<any>
): Promise<void> {
  for (const templateInfo of detectedTemplates) {
    let resolvedValue: any = undefined;

    if (!templateInfo.primary_key) {
      console.warn(
        `Template at path ${templateInfo.path.join(".")} has no primary key: ${templateInfo.template_string}`
      );
      continue;
    }

    const valuePath = templateInfo.expression
      .substring(templateInfo.primary_key.length)
      .replace(/^\./, "");

    try {
      resolvedValue = await resolver(templateInfo.primary_key, valuePath);
    } catch (error) {
      console.error(
        `Error resolving template at path ${templateInfo.path.join(".")}: ${error}`
      );
    }

    if (resolvedValue === undefined) {
      console.warn(
        `Could not resolve template "${templateInfo.template_string}" at path ${templateInfo.path.join(".")}. Path or source might be invalid.`
      );
      throw new Error(
        `Could not resolve template "${templateInfo.template_string}" at path ${templateInfo.path.join(".")}. Path or source might be invalid.`
      );
    }

    // Use the native setValueByPath function
    setValueByPath(argsObject, templateInfo.path, resolvedValue);
  }
}

export async function templateResultsResolver(
  arr: MaybePromise<ActionResult>[],
  path: string
) {
  const [index, ...resultPath] = getPathSegments(path);
  const actionResult = arr[Number(index)];

  if (!actionResult) throw new Error("invalid index");
  const result = await actionResult;

  if (resultPath.length === 0) {
    return result.data;
  }
  return jsonPath(result.data, resultPath.join("."));
}

export function createResultsTemplateResolver(
  arr: Array<MaybePromise<any>>
): TemplateResolver {
  return (path) => templateResultsResolver(arr, path);
}

export function createObjectTemplateResolver(obj: object): TemplateResolver {
  return async function templateObjectResolver(path) {
    const res = jsonPath(obj, path);
    if (!res) throw new Error("invalid path: " + path);
    return res.length > 1 ? res : res[0];
  };
}

export function parseActionCallContent({
  call,
  action,
}: {
  call: ActionCall;
  action: AnyAction;
}) {
  try {
    const content = call.content.trim();

    let data: any;

    if (action.parser) {
      data = action.parser(call);
    } else if (action.schema && action.schema?._def?.typeName !== "ZodString") {
      if (action.callFormat === "xml") {
        data = parseXMLContent(content);
      } else {
        data = parseJSONContent(content);
      }
    } else {
      data = content;
    }

    return data;
  } catch (error) {
    throw new ParsingError(call, error);
  }
}

export function resolveActionCall({
  call,
  actions,
  logger,
}: {
  call: ActionCall;
  actions: ActionCtxRef[];
  logger: Logger;
}) {
  const contextKey = call.params?.contextKey;

  const action = actions.find(
    (a) =>
      (contextKey ? contextKey === a.ctxRef.key : true) && a.name === call.name
  );

  if (!action) {
    logger.error("agent:action", "ACTION_MISMATCH", {
      name: call.name,
      data: call.content,
      contextKey,
    });

    throw new NotFoundError(call);
  }

  return action;
}

export async function prepareActionCall({
  call,
  action,
  logger,
  templateResolver,
  state,
  api,
  workingMemory,
  agent,
  agentState,
  abortSignal,
}: {
  agent: AnyAgent;
  state: ContextState<AnyContext>;
  api: ContextStateApi<AnyContext>;
  workingMemory: WorkingMemory;
  agentState?: ContextState;
  call: ActionCall;
  action: ActionCtxRef;
  logger: Logger;
  templateResolver: (
    primary_key: string,
    path: string,
    callCtx: ActionCallContext
  ) => MaybePromise<any>;
  abortSignal?: AbortSignal;
}) {
  let actionMemory: Memory<any> | undefined = undefined;

  if (action.memory) {
    actionMemory =
      (await agent.memory.store.get(action.memory.key)) ??
      action.memory.create();
  }

  const callCtx: ActionCallContext = {
    ...state,
    ...api,
    workingMemory,
    actionMemory,
    agentMemory: agentState?.memory,
    abortSignal,
    call,
  };

  const data = call.data ?? parseActionCallContent({ call, action });

  const templates: TemplateInfo[] = [];

  if (action.templateResolver !== false) {
    templates.push(...detectTemplates(data));

    const actionTemplateResolver =
      typeof action.templateResolver === "function"
        ? action.templateResolver
        : templateResolver;

    if (templates.length > 0)
      await resolveTemplates(data, templates, (key, path) =>
        actionTemplateResolver(key, path, callCtx)
      );
  }

  if (action.schema) {
    try {
      const schema =
        "parse" in action.schema || "validate" in action.schema
          ? action.schema
          : "$schema" in action.schema
            ? jsonSchema(action.schema)
            : z.object(action.schema);

      call.data =
        "parse" in schema
          ? (schema as ZodSchema).parse(data)
          : schema.validate
            ? schema.validate(data)
            : data;
    } catch (error) {
      throw new ParsingError(call, error);
    }
  } else {
    call.data = data;
  }

  return callCtx;
}

export async function handleActionCall({
  action,
  logger,
  call,
  taskRunner,
  agent,
  abortSignal,
  callCtx,
  queueKey,
}: {
  callCtx: ActionCallContext;
  call: ActionCall;
  action: AnyAction;
  logger: Logger;
  taskRunner: TaskRunner;
  agent: AnyAgent;
  abortSignal?: AbortSignal;
  queueKey?: string;
}): Promise<ActionResult> {
  queueKey =
    queueKey ??
    (action.queueKey
      ? typeof action.queueKey === "function"
        ? action.queueKey(callCtx)
        : action.queueKey
      : undefined);

  const data = await taskRunner.enqueueTask(
    runAction,
    {
      action,
      agent,
      logger,
      ctx: callCtx,
    },
    {
      retry: action.retry,
      abortSignal,
      queueKey,
    }
  );

  const result: ActionResult = {
    ref: "action_result",
    id: randomUUIDv7(),
    callId: call.id,
    data,
    name: call.name,
    timestamp: Date.now(),
    processed: false,
  };

  if (action.format) result.formatted = action.format(result);

  if (callCtx.actionMemory) {
    await agent.memory.store.set(action.memory.key, callCtx.actionMemory);
  }

  if (action.onSuccess) {
    await Promise.try(action.onSuccess, result, callCtx, agent);
  }

  return result;
}

export function prepareOutputRef({
  outputRef,
  outputs,
  logger,
}: {
  outputRef: OutputRef;
  outputs: OutputCtxRef[];
  logger: Logger;
}) {
  const output = outputs.find((output) => output.type === outputRef.type);

  if (!output) {
    throw new NotFoundError(outputRef);
  }

  logger.debug("agent:output", outputRef.type, outputRef.data);

  if (output.schema) {
    const schema = (
      "parse" in output.schema ? output.schema : z.object(output.schema)
    ) as z.AnyZodObject | z.ZodString;

    let parsedContent = outputRef.content;

    try {
      if (typeof parsedContent === "string") {
        if (schema._def.typeName !== "ZodString") {
          parsedContent = JSON.parse(parsedContent.trim());
        }
      }

      outputRef.data = schema.parse(parsedContent);
    } catch (error) {
      throw new ParsingError(outputRef, error);
    }
  }

  return { output };
}

export async function handleOutput({
  outputRef,
  output,
  logger,
  state,
  workingMemory,
  agent,
}: {
  output: OutputCtxRef;
  outputRef: OutputRef;
  logger: Logger;
  workingMemory: WorkingMemory;
  state: ContextState;
  agent: AnyAgent;
}): Promise<OutputRef | OutputRef[]> {
  if (output.handler) {
    const response = await Promise.try(
      output.handler,
      outputRef.data,
      {
        ...state,
        workingMemory,
        outputRef,
      },
      agent
    );

    if (Array.isArray(response)) {
      const refs: OutputRef[] = [];
      for (const res of response) {
        const ref: OutputRef = {
          ...outputRef,
          id: randomUUIDv7(),
          processed: res.processed ?? true,
          ...res,
        };

        ref.formatted = output.format ? output.format(ref) : undefined;
        refs.push(ref);
      }
      return refs;
    } else if (response) {
      const ref: OutputRef = {
        ...outputRef,
        ...response,
        processed: response.processed ?? true,
      };

      ref.formatted = output.format ? output.format(ref) : undefined;

      return ref;
    }
  }

  return {
    ...outputRef,
    formatted: output.format ? output.format(outputRef.data) : undefined,
    processed: true,
  };
}

export async function prepareContextActions(params: {
  context: Context;
  state: ContextState<AnyContext>;
  workingMemory: WorkingMemory;
  agent: AnyAgent;
  agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<ActionCtxRef[]> {
  const { context, state } = params;
  const actions =
    typeof context.actions === "function"
      ? await Promise.try(context.actions, state)
      : (context.actions ?? []);

  return Promise.all(
    actions.map((action) =>
      prepareAction({
        action,
        ...params,
      })
    )
  ).then((t) => t.filter((t) => !!t));
}

async function prepareOutput({
  output,
  context,
  state,
}: {
  output: AnyOutput;
  context: AnyContext;
  state: ContextState<AnyContext>;
}): Promise<OutputCtxRef | undefined> {
  if (output.context && output.context.type !== context.type) return undefined;

  const enabled = output.enabled ? output.enabled(state) : true;

  return enabled
    ? {
        ...output,
        ctxRef: {
          type: state.context.type,
          id: state.id,
          key: state.key,
        },
      }
    : undefined;
}

export async function prepareContextOutputs(params: {
  context: Context;
  state: ContextState<AnyContext>;
  workingMemory: WorkingMemory;
  agent: AnyAgent;
  agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<OutputCtxRef[]> {
  return params.context.outputs
    ? Promise.all(
        Object.entries(params.context.outputs).map(([type, output]) =>
          prepareOutput({
            output: {
              type,
              ...output,
            },
            ...params,
          })
        )
      ).then((t) => t.filter((t) => !!t))
    : [];
}

export async function prepareAction({
  action,
  context,
  state,
  workingMemory,
  agent,
  agentCtxState,
}: {
  action: AnyAction;
  context: AnyContext;
  state: ContextState<AnyContext>;
  workingMemory: WorkingMemory;
  agent: AnyAgent;
  agentCtxState: ContextState<AnyContext> | undefined;
}): Promise<ActionCtxRef | undefined> {
  if (action.context && action.context.type !== context.type) return undefined;

  let actionMemory: Memory | undefined = undefined;

  if (action.memory) {
    actionMemory =
      (await agent.memory.store.get(action.memory.key)) ??
      action.memory.create();
  }

  const enabled = action.enabled
    ? action.enabled({
        ...state,
        context,
        workingMemory,
        actionMemory,
        agentMemory: agentCtxState?.memory,
      })
    : true;

  if (action.enabled && actionMemory) {
    await agent.memory.store.set(actionMemory.key, actionMemory);
  }

  return enabled
    ? {
        ...action,
        ctxRef: {
          type: state.context.type,
          id: state.id,
          key: state.key,
        },
      }
    : undefined;
}

function resolve<Value = any, Ctx = any>(
  value: Value,
  ctx: Ctx
): Promise<Value extends (ctx: Ctx) => infer R ? R : Value> {
  return typeof value === "function" ? value(ctx) : (value as any);
}

export async function prepareContext(
  {
    agent,
    ctxState,
    workingMemory,
    agentCtxState,
  }: {
    agent: AnyAgent;
    ctxState: ContextState;
    workingMemory: WorkingMemory;
    agentCtxState?: ContextState;
  },
  state: {
    inputs: Input[];
    outputs: OutputCtxRef[];
    actions: ActionCtxRef[];
    contexts: ContextState[];
  }
) {
  state.contexts.push(ctxState);

  await ctxState.context.loader?.(ctxState, agent);

  const inputs: Input[] = ctxState.context.inputs
    ? Object.entries(ctxState.context.inputs).map(([type, input]) => ({
        type,
        ...input,
      }))
    : [];

  state.inputs.push(...inputs);

  const outputs: OutputCtxRef[] = ctxState.context.outputs
    ? await Promise.all(
        Object.entries(await resolve(ctxState.context.outputs, ctxState)).map(
          ([type, output]) =>
            prepareOutput({
              output: {
                type,
                ...output,
              },
              context: ctxState.context,
              state: ctxState,
            })
        )
      ).then((r) => r.filter((a) => !!a))
    : [];

  state.outputs.push(...outputs);

  const actions = await prepareContextActions({
    agent,
    agentCtxState,
    context: ctxState.context,
    state: ctxState,
    workingMemory,
  });

  state.actions.push(...actions);

  const ctxRefs: ContextRef[] = [];

  if (ctxState.context.__composers) {
    for (const composer of ctxState.context.__composers) {
      ctxRefs.push(...composer(ctxState));
    }
  }

  for (const { context, args } of ctxRefs) {
    await prepareContext(
      {
        agent,
        ctxState: await agent.getContext({ context, args }),
        workingMemory,
        agentCtxState,
      },
      state
    );
  }

  return state;
}

export async function prepareContexts({
  agent,
  ctxState,
  agentCtxState,
  workingMemory,
  params,
}: {
  agent: AnyAgent;
  ctxState: ContextState;
  agentCtxState?: ContextState;
  workingMemory: WorkingMemory;
  params?: {
    outputs?: Record<string, Omit<Output, "type">>;
    inputs?: Record<string, InputConfig>;
    actions?: AnyAction[];
    contexts?: ContextRef[];
  };
}) {
  await agentCtxState?.context.loader?.(agentCtxState, agent);

  const inputs: Input[] = Object.entries({
    ...agent.inputs,
    ...(params?.inputs ?? {}),
  }).map(([type, input]) => ({
    type,
    ...input,
  }));

  const outputs: OutputCtxRef[] = await Promise.all(
    Object.entries({
      ...agent.outputs,
      ...(params?.outputs ?? {}),
    }).map(([type, output]) =>
      prepareOutput({
        output: {
          type,
          ...output,
        },
        context: ctxState.context,
        state: ctxState,
      })
    )
  ).then((r) => r.filter((a) => !!a));

  const actions = await Promise.all(
    [agent.actions, params?.actions]
      .filter((t) => !!t)
      .flat()
      .map((action: AnyAction) =>
        prepareAction({
          action,
          agent,
          agentCtxState,
          context: ctxState.context,
          state: ctxState,
          workingMemory,
        })
      )
  ).then((r) => r.filter((a) => !!a));

  const contexts: ContextState[] = agentCtxState ? [agentCtxState] : [];

  const state = {
    inputs,
    outputs,
    actions,
    contexts,
  };

  await prepareContext(
    { agent, ctxState, workingMemory, agentCtxState },
    state
  );

  if (params?.contexts) {
    for (const ctxRef of params?.contexts) {
      await prepareContext(
        {
          agent,
          ctxState: await agent.getContext(ctxRef),
          workingMemory,
          agentCtxState,
        },
        state
      );
    }
  }

  return state;
}

export async function handleInput({
  inputs,
  inputRef,
  logger,
  ctxState,
  workingMemory,
  agent,
}: {
  inputs: Input[];
  inputRef: InputRef;
  logger: Logger;
  workingMemory: WorkingMemory;
  ctxState: ContextState;
  agent: AnyAgent;
}) {
  const input = inputs.find((input) => input.type === inputRef.type);

  if (!input) {
    throw new NotFoundError(inputRef);
  }

  try {
    if (input.schema) {
      const schema = (
        "parse" in input.schema ? input.schema : z.object(input.schema)
      ) as z.AnyZodObject | z.ZodString;
      inputRef.data = schema.parse(inputRef.content);
    } else {
      inputRef.data = z.string().parse(inputRef.content);
    }
  } catch (error) {
    throw new ParsingError(inputRef, error);
  }

  logger.debug("agent:send", "Querying episodic memory");

  const episodicMemory = await agent.memory.vector.query(
    `${ctxState.id}`,
    JSON.stringify(inputRef.data)
  );

  logger.trace("agent:send", "Episodic memory retrieved", {
    episodesCount: episodicMemory.length,
  });

  workingMemory.episodicMemory = {
    episodes: episodicMemory,
  };

  if (input.handler) {
    logger.debug("agent:send", "Using custom input handler", {
      type: inputRef.type,
    });

    const { data, params } = await Promise.try(
      input.handler,
      inputRef.data,
      {
        ...ctxState,
        workingMemory,
      },
      agent
    );

    inputRef.data = data;

    if (params) {
      inputRef.params = {
        ...inputRef.params,
        ...params,
      };
    }
  }

  inputRef.formatted = input.format ? input.format(inputRef) : undefined;
}

--- End File: packages/core/src/handlers.ts ---

--- File: packages/core/src/http.ts ---
let nextRpcRequestId = 1;

type QueryParams =
  | Record<string, string | number | boolean | null | undefined>
  | URLSearchParams;

interface RetryOptions {
  maxRetries?: number;
  initialDelay?: number;
  maxDelay?: number;
  backoffFactor?: number;
  retryableStatuses?: number[];
}

interface RequestOptions extends RequestInit {
  retryOptions?: RetryOptions;
  params?: QueryParams;
}

const DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {
  maxRetries: 3,
  initialDelay: 1000,
  maxDelay: 30000,
  backoffFactor: 2,
  retryableStatuses: [408, 429, 500, 502, 503, 504],
};

class RequestError extends Error {
  constructor(
    message: string,
    public response?: Response
  ) {
    super(message);
    this.name = "RequestError";
  }
}

const sleep = (ms: number): Promise<void> =>
  new Promise((resolve) => setTimeout(resolve, ms));

const calculateDelay = (
  attempt: number,
  options: Required<RetryOptions>
): number => {
  const delay =
    options.initialDelay * Math.pow(options.backoffFactor, attempt - 1);
  return Math.min(delay, options.maxDelay);
};

const isRetryableError = (error: any): boolean =>
  error.name === "TypeError" ||
  error.name === "AbortError" ||
  error instanceof RequestError;

const buildUrl = (url: string, params?: QueryParams): string => {
  if (!params) return url;

  const searchParams =
    params instanceof URLSearchParams
      ? params
      : new URLSearchParams(
          Object.entries(params)
            .filter(([_, value]) => value != null)
            .map(([key, value]) => [key, String(value)])
        );

  const separator = url.includes("?") ? "&" : "?";
  const queryString = searchParams.toString();

  return queryString ? `${url}${separator}${queryString}` : url;
};

export const http = {
  async request(url: string, options?: RequestOptions): Promise<Response> {
    const { params, ...fetchOptions } = options || {};
    const fullUrl = buildUrl(url, params);

    const retryOptions: Required<RetryOptions> = {
      ...DEFAULT_RETRY_OPTIONS,
      ...options?.retryOptions,
    };

    let attempt = 1;

    while (true) {
      try {
        const res = await fetch(fullUrl, fetchOptions);

        if (!res.ok) {
          const errorText = await res.text();
          throw new RequestError(
            `Request failed with status ${res.status}: ${errorText}`,
            res
          );
        }

        return res;
      } catch (error: any) {
        if (isRetryableError(error) && attempt < retryOptions.maxRetries) {
          const delay = calculateDelay(attempt, retryOptions);
          console.warn(
            `Request failed with error: ${error.message}. ` +
              `Retrying in ${delay}ms (attempt ${attempt}/${retryOptions.maxRetries})`
          );
          await sleep(delay);
          attempt++;
          continue;
        }

        throw error;
      }
    }
  },

  async json<T = any>(url: string, options?: RequestOptions) {
    const res = await this.request(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
      },
    });
    return (await res.json()) as T;
  },

  get: {
    async request(url: string, params?: QueryParams, options?: RequestInit) {
      return http.request(url, {
        ...options,
        method: "GET",
        params,
      });
    },
    async json<T = any>(
      url: string,
      params?: QueryParams,
      options?: RequestInit
    ) {
      return http.json<T>(url, {
        ...options,
        method: "GET",
        params,
      });
    },
  },

  post: {
    async request(url: string, body: object, options?: RequestOptions) {
      return http.request(url, {
        ...options,
        method: "POST",
        body: JSON.stringify(body),
      });
    },

    async json<ReturnType = any, Body extends object = object>(
      url: string,
      body: Body,
      options?: RequestOptions
    ) {
      return http.json<ReturnType>(url, {
        ...options,
        method: "POST",
        body: JSON.stringify(body),
      });
    },
  },

  async jsonrpc<ReturnType = any, Params extends object = object>(
    url: string,
    method: string,
    params: Params,
    headers?: HeadersInit
  ) {
    return http.post.json<ReturnType>(
      url,
      {
        jsonrpc: "2.0",
        id: nextRpcRequestId++,
        method,
        params,
      },
      { headers }
    );
  },

  async graphql<ReturnType = any, Variables extends object = object>(
    url: string,
    query: string,
    variables: Variables,
    headers?: HeadersInit
  ) {
    return http.post.json<ReturnType>(
      url,
      {
        query,
        variables,
      },
      { headers }
    );
  },
};

--- End File: packages/core/src/http.ts ---

--- File: packages/core/src/index.ts ---
export * from "./dreams";
export * from "./types";
export * from "./utils";
export * from "./xml";
export * from "./logger";
export * from "./formatters";
export * from "./memory";
export * from "./prompt";
export * from "./task";
export * from "./context";
export * from "./container";
export * from "./serviceProvider";
export * from "./handlers";
export * from "./providers";
export * from "./http";
export * from "./prompts/main";
export * from "./tasks/index";

--- End File: packages/core/src/index.ts ---

--- File: packages/core/src/jsonpath.ts ---
/* JSONPath 0.8.0 - XPath for JSON
 *
 * Copyright (c) 2007 Stefan Goessner (goessner.net)
 * Licensed under the MIT (MIT-LICENSE.txt) licence.
 * Converted to TypeScript.
 */

interface JsonPathArgs {
  resultType?: "VALUE" | "PATH";
}

interface JsonPathInternal {
  resultType: "VALUE" | "PATH";
  result: any[];
  normalize: (expr: string) => string;
  asPath: (path: string) => string;
  store: (p: string, v: any) => boolean;
  trace: (expr: string, val: any, path: string) => void;
  walk: (
    loc: string,
    expr: string,
    val: any,
    path: string,
    f: (m: string | number, l: string, x: string, v: any, p: string) => void
  ) => void;
  slice: (loc: string, expr: string, val: any, path: string) => void;
  eval: (x: string, _v: any, _vname: string | number) => any;
}

export function jsonPath(
  obj: any,
  expr: string,
  arg?: JsonPathArgs
): any[] | false {
  const P: JsonPathInternal = {
    resultType: arg?.resultType || "VALUE",
    result: [],
    normalize: function (expr: string): string {
      const subx: string[] = [];
      return expr
        .replace(/[\['](\??\(.*?\))[\]']/g, function ($0, $1) {
          return "[#" + (subx.push($1) - 1) + "]";
        })
        .replace(/'?\.'?|\['?/g, ";")
        .replace(/;;;|;;/g, ";..;")
        .replace(/;$|'?\]|'$/g, "")
        .replace(/#([0-9]+)/g, function ($0, $1) {
          return subx[parseInt($1, 10)];
        });
    },
    asPath: function (path: string): string {
      const x: string[] = path.split(";");
      let p: string = "$";
      for (let i = 1, n = x.length; i < n; i++)
        p += /^[0-9*]+$/.test(x[i]) ? "[" + x[i] + "]" : "['" + x[i] + "']";
      return p;
    },
    store: function (p: string, v: any): boolean {
      if (p)
        P.result[P.result.length] = P.resultType === "PATH" ? P.asPath(p) : v;
      return !!p;
    },
    trace: function (expr: string, val: any, path: string): void {
      if (expr) {
        let x: string[] = expr.split(";");
        const loc: string = x.shift()!;
        let remainingExpr: string = x.join(";");

        if (
          val &&
          typeof val === "object" &&
          val !== null &&
          Object.prototype.hasOwnProperty.call(val, loc)
        ) {
          P.trace(remainingExpr, val[loc], path + ";" + loc);
        } else if (loc === "*") {
          P.walk(loc, remainingExpr, val, path, function (m, l, x, v, p) {
            P.trace(m + ";" + x, v, p);
          });
        } else if (loc === "..") {
          P.trace(remainingExpr, val, path);
          P.walk(loc, remainingExpr, val, path, function (m, l, x, v, p) {
            if (typeof v[m] === "object" && v[m] !== null) {
              P.trace("..;" + x, v[m], p + ";" + m);
            }
          });
        } else if (/,/.test(loc)) {
          // [name1,name2,...]
          const s: string[] = loc.split(/'?,'?/);
          for (let i = 0, n = s.length; i < n; i++) {
            P.trace(s[i] + ";" + remainingExpr, val, path);
          }
        } else if (/^\(.*?\)$/.test(loc)) {
          // [(expr)]
          P.trace(
            P.eval(loc, val, path.substring(path.lastIndexOf(";") + 1)) +
              ";" +
              remainingExpr,
            val,
            path
          );
        } else if (/^\?\(.*?\)$/.test(loc)) {
          // [?(expr)]
          P.walk(loc, remainingExpr, val, path, function (m, l, x, v, p) {
            if (P.eval(l.replace(/^\?\((.*?)\)$/, "$1"), v[m], m)) {
              P.trace(m + ";" + x, v, p);
            }
          });
        } else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) {
          // [start:end:step] python slice syntax
          P.slice(loc, remainingExpr, val, path);
        }
      } else {
        P.store(path, val);
      }
    },
    walk: function (
      loc: string,
      expr: string,
      val: any,
      path: string,
      f: (m: string | number, l: string, x: string, v: any, p: string) => void
    ): void {
      if (Array.isArray(val)) {
        for (let i = 0, n = val.length; i < n; i++) {
          if (i in val) {
            f(i, loc, expr, val, path);
          }
        }
      } else if (typeof val === "object" && val !== null) {
        for (const m in val) {
          if (Object.prototype.hasOwnProperty.call(val, m)) {
            f(m, loc, expr, val, path);
          }
        }
      }
    },
    slice: function (loc: string, expr: string, val: any, path: string): void {
      if (Array.isArray(val)) {
        const len: number = val.length;
        let start: number = 0;
        let end: number = len;
        let step: number = 1;
        loc.replace(
          /^(-?[0-9]*):(-?[0-9]*):?(-?[0-9]*)$/g,
          function ($0, $1, $2, $3) {
            start = parseInt($1 || start.toString(), 10);
            end = parseInt($2 || end.toString(), 10);
            step = parseInt($3 || step.toString(), 10);
            return ""; // Required by TS replace signature
          }
        );
        start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
        end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
        for (let i = start; i < end; i += step) {
          P.trace(i + ";" + expr, val, path);
        }
      }
    },
    eval: function (x: string, _v: any, _vname: string | number): any {
      // Using Function constructor instead of eval for slightly better isolation,
      // but still carries security risks if 'x' is untrusted.
      // Consider safer alternatives if 'x' can contain arbitrary user input.
      try {
        // @ts-ignore - Allows using _v and _vname in the Function scope
        return new Function(
          "_v",
          "_vname",
          `return (${x.replace(/@/g, "_v")})`
        )(_v, _vname);
      } catch (e: any) {
        throw new SyntaxError(
          "jsonPath: " + e.message + ": " + x.replace(/@/g, "_v")
        );
      }
    },
  };

  const $ = obj; // Alias for the object
  if (expr && obj && (P.resultType === "VALUE" || P.resultType === "PATH")) {
    P.trace(P.normalize(expr).replace(/^\$;/, ""), obj, "$");
    return P.result.length ? P.result : false;
  }
  return false; // Default return if conditions aren't met
}

--- End File: packages/core/src/jsonpath.ts ---

--- File: packages/core/src/logger.ts ---
import { LogLevel } from "./types"; // Assuming LogLevel is defined elsewhere

// --- Interfaces ---

export interface LogEntry {
  level: LogLevel;
  timestamp: Date;
  context: string;
  message: string;
  data?: any;
}

export interface LogFormatter {
  format(entry: LogEntry): string;
}

export interface Transport {
  log(formattedMessage: string, entry: LogEntry): void;
  init?(): Promise<void> | void; // Optional initialization (e.g., open file stream)
  close?(): Promise<void> | void; // Optional cleanup
}

export interface LoggerConfig {
  level: LogLevel;
  transports: Transport[];
  formatter: LogFormatter;
}

// --- Default Implementations ---

export class DefaultFormatter implements LogFormatter {
  private enableTimestamp: boolean;

  constructor(options: { enableTimestamp?: boolean } = {}) {
    this.enableTimestamp = options.enableTimestamp ?? true;
  }

  format(entry: LogEntry): string {
    const parts: string[] = [];

    if (this.enableTimestamp) {
      parts.push(`[${entry.timestamp.toISOString()}]`);
    }

    parts.push(`[${LogLevel[entry.level]}]`); // Assumes LogLevel is an enum
    parts.push(`[${entry.context}]`);
    parts.push(entry.message);

    // Note: Default formatter now DOES NOT stringify data,
    // as transports might want to handle it differently.
    // if (entry.data) {
    //   try {
    //     parts.push(`\n${JSON.stringify(entry.data, null, 2)}`);
    //   } catch (error) {
    //     parts.push("[Unserializable data]");
    //   }
    // }

    return parts.join(" ");
  }
}

const colors: { [key in LogLevel]?: string } = {
  [LogLevel.ERROR]: "\x1b[31m", // Red
  [LogLevel.WARN]: "\x1b[33m", // Yellow
  [LogLevel.INFO]: "\x1b[36m", // Cyan
  [LogLevel.DEBUG]: "\x1b[32m", // Green
  [LogLevel.TRACE]: "\x1b[90m", // Gray
};

const colorReset = "\x1b[0m";

function colorize(message: string, level: LogLevel): string {
  const color = colors[level] || "";
  return `${color}${message}${colorReset}`;
}

// --- UPDATED ConsoleTransport ---
export class ConsoleTransport implements Transport {
  private enableColors: boolean;

  constructor(options: { enableColors?: boolean } = {}) {
    this.enableColors = options.enableColors ?? true;
  }

  log(formattedMessage: string, entry: LogEntry): void {
    const messageParts: any[] = []; // Use array to pass multiple args to console.log

    if (this.enableColors) {
      messageParts.push(colorize(formattedMessage, entry.level));
    } else {
      messageParts.push(formattedMessage);
    }

    // If data exists, log it as a separate argument to console.log
    // This allows the browser/Node console to display it interactively.
    if (entry.data !== undefined) {
      messageParts.push(entry.data);
    }

    // Use appropriate console method based on level
    switch (entry.level) {
      case LogLevel.ERROR:
        console.error(...messageParts);
        break;
      case LogLevel.WARN:
        console.warn(...messageParts);
        break;
      case LogLevel.INFO:
        console.info(...messageParts);
        break;
      case LogLevel.DEBUG:
      case LogLevel.TRACE: // console.debug and console.trace might behave differently
        console.debug(...messageParts); // Or console.log(...messageParts)
        break;
      default:
        console.log(...messageParts);
    }
  }
}

export class Logger {
  private config: LoggerConfig;

  constructor(config: Partial<LoggerConfig>) {
    // Provide defaults if necessary
    const transports =
      !config.transports || config.transports.length === 0
        ? [new ConsoleTransport()]
        : config.transports;

    const formatter = config.formatter ?? new DefaultFormatter();

    this.config = {
      level: config.level ?? LogLevel.INFO,
      transports: transports,
      formatter: formatter,
    };

    // Initialize transports
    this.config.transports.forEach((transport) => {
      if (typeof transport.init === "function") {
        Promise.try(transport.init).catch((err) =>
          console.error("Error initializing transport:", err)
        );
      }
    });
  }

  configure(config: Pick<LoggerConfig, "level">) {
    this.config.level = config.level;
  }

  error(context: string, message: string, data?: any) {
    this.log(LogLevel.ERROR, context, message, data);
  }

  warn(context: string, message: string, data?: any) {
    this.log(LogLevel.WARN, context, message, data);
  }

  info(context: string, message: string, data?: any) {
    this.log(LogLevel.INFO, context, message, data);
  }

  debug(context: string, message: string, data?: any) {
    this.log(LogLevel.DEBUG, context, message, data);
  }

  trace(context: string, message: string, data?: any) {
    this.log(LogLevel.TRACE, context, message, data);
  }

  private log(level: LogLevel, context: string, message: string, data?: any) {
    if (level > this.config.level) return;

    const entry: LogEntry = {
      level,
      timestamp: new Date(),
      context,
      message,
      data,
    };

    const formattedMessage = this.config.formatter.format(entry); // Format the core message

    // Send to all transports (passing both formatted string and raw entry)
    this.config.transports.forEach((transport) => {
      try {
        transport.log(formattedMessage, entry);
      } catch (error) {
        console.error(
          `Error logging to transport ${transport.constructor.name}:`,
          error
        );
      }
    });
  }

  // Method to gracefully close transports
  async close(): Promise<void> {
    for (const transport of this.config.transports) {
      if (typeof transport.close === "function") {
        try {
          await Promise.try(transport.close);
        } catch (err) {
          console.error(
            `Error closing transport ${transport.constructor.name}:`,
            err
          );
        }
      }
    }
  }
}

--- End File: packages/core/src/logger.ts ---

--- File: packages/core/src/memory/base.ts ---
import type { MemoryStore, VectorStore, WorkingMemory } from "../types";
import type { LanguageModelV1 } from "ai";
/**
 * Base memory implementation providing storage and vector capabilities
 */
export type BaseMemory = {
  /** Store for conversation memory data */
  store: MemoryStore;
  /** Store for vector embeddings and similarity search */
  vector: VectorStore;
  vectorModel?: LanguageModelV1;
  generateMemories?: boolean;
};

/**
 * Creates a new BaseMemory instance
 * @param store - Memory store implementation for conversation data
 * @param vector - Vector store implementation for embeddings
 * @param vectorModel - Vector model implementation for embeddings
 * @returns A new BaseMemory instance
 */
export function createMemory(
  store: MemoryStore,
  vector: VectorStore,
  vectorModel?: LanguageModelV1
): BaseMemory {
  return { store, vector, vectorModel };
}

/**
 * Creates a new in-memory store for conversation data
 * @returns A MemoryStore implementation using a Map for storage
 */
export function createMemoryStore(): MemoryStore {
  const data = new Map<string, any>();
  return {
    async keys(base) {
      const keys = Array.from(data.keys());

      if (base) {
        return keys.filter((key) => key.startsWith(base));
      }

      return keys;
    },

    /**
     * Retrieves a value from the store
     * @param key - Key to look up
     * @returns The stored value or null if not found
     */
    async get(key: string) {
      return data.get(key) ?? null;
    },

    /**
     * Removes all entries from the store
     */
    async clear() {
      data.clear();
    },

    /**
     * Removes a specific entry from the store
     * @param key - Key to remove
     */
    async delete(key: string) {
      data.delete(key);
    },

    /**
     * Stores a value in the store
     * @param key - Key to store under
     * @param value - Value to store
     */
    async set(key: string, value: any) {
      data.set(key, value);
    },
  };
}

/**
 * Creates a no-op vector store implementation
 * @returns A VectorStore implementation that performs no operations
 */
export function createVectorStore(): VectorStore {
  return {
    /**
     * No-op implementation of vector store upsert
     * @param contextId - Context ID (unused)
     * @param data - Data to store (unused)
     */
    upsert(contextId: string, data: any[]) {
      return Promise.resolve();
    },

    /**
     * No-op implementation of vector store query
     * @param contextId - Context ID (unused)
     * @param query - Query string (unused)
     * @returns Empty array
     */
    query(contextId: string, query: string) {
      return Promise.resolve([]);
    },

    /**
     * No-op implementation of index creation
     * @param indexName - Name of index to create (unused)
     */
    createIndex(indexName: string) {
      return Promise.resolve();
    },

    /**
     * No-op implementation of index deletion
     * @param indexName - Name of index to delete (unused)
     */
    deleteIndex(indexName: string) {
      return Promise.resolve();
    },
  };
}

--- End File: packages/core/src/memory/base.ts ---

--- File: packages/core/src/memory/index.ts ---
export * from "./base";

--- End File: packages/core/src/memory/index.ts ---

--- File: packages/core/src/memory/utils.ts ---
import { generateObject } from "ai";
import { openai } from "@ai-sdk/openai";
import type {
  AnyAgent,
  Episode,
  ActionResult,
  Action,
  Thought,
  ActionCall,
  AnyAction,
} from "../types";
import { z } from "zod";
import { v7 as randomUUIDv7 } from "uuid";

// Check if we're in a browser environment
const isBrowser =
  typeof window !== "undefined" && typeof window.document !== "undefined";

// Conditionally import Node.js modules
let fs: any;
let path: any;

if (!isBrowser) {
  // Only import in Node.js environment
  // Using dynamic import to avoid browser errors
  try {
    fs = require("fs");
    path = require("path");
  } catch (e) {
    console.warn("File system modules not available in this environment");
  }
}

export const generateEpisodicMemory = async (
  agent: AnyAgent,
  thoughts: Thought[],
  actions: Action[],
  results: ActionResult[]
): Promise<{
  observation: string;
  thoughts: string;
  result: string;
}> => {
  const extractEpisode = await generateObject({
    model: agent.memory.vectorModel || openai("gpt-4-turbo"),
    schema: z.object({
      observation: z.string().describe("The context and setup - what happened"),
      thoughts: z
        .string()
        .describe(
          "Internal reasoning process and observations of the agent in the episode that let it arrive at the correct action and result. 'I ...'"
        ),
      result: z
        .string()
        .describe(
          "Outcome and retrospective. What did you do well? What could you do better next time? I ..."
        ),
    }),
    prompt: `
    You are creating an episodic memory for an AI agent to help it recall and learn from past experiences.
    
    Your task is to analyze the agent's thoughts, actions, and the results of those actions to create a structured memory that can be used for future reference and learning.

    ## Context
    <thoughts>
    ${JSON.stringify(thoughts)}
    </thoughts>

    ## Actions Taken
    <actions>
    ${JSON.stringify(actions)}
    </actions>

    ## Results & Outcomes
    <results>
    ${JSON.stringify(results)}
    </results>
    
    ## Instructions
    Create a comprehensive episodic memory with these components:
    
    1. OBSERVATION: Provide a clear, concise description of the situation, context, and key elements. Include:
       - What was the environment or scenario?
       - What was the agent trying to accomplish?
       - What were the initial conditions or constraints?
    
    2. THOUGHTS: Capture the agent's internal reasoning process that led to its actions:
       - What was the agent's understanding of the situation?
       - What strategies or approaches did it consider?
       - What key insights or realizations occurred during the process?
       - Use first-person perspective ("I realized...", "I considered...")
    
    3. RESULT: Summarize the outcomes and provide a retrospective analysis:
       - What was accomplished or not accomplished?
       - What worked well and what didn't?
       - What lessons can be learned for future similar situations?
       - What would be done differently next time?
       - Use first-person perspective ("I succeeded in...", "Next time I would...")
    
    Make the memory detailed enough to be useful for future recall, but concise enough to be quickly processed. Focus on capturing the essence of the experience, key decision points, and lessons learned.`,
  });

  return {
    observation: extractEpisode.object.observation,
    thoughts: extractEpisode.object.thoughts,
    result: extractEpisode.object.result,
  };
};

/**
 * Creates a training data pair from episodic memory
 * @param episodicMemory The episodic memory generated
 * @returns A prompt-completion pair for training data
 */
export function createTrainingDataPair(episodicMemory: {
  observation: string;
  thoughts: string;
  result: string;
}): {
  prompt: string;
  completion: string;
} {
  // Create a simple prompt with the observation
  const prompt = episodicMemory.observation;

  // Create a simple completion with thoughts and result
  const completion = `${episodicMemory.thoughts}\n\n${episodicMemory.result}`;

  return {
    prompt,
    completion,
  };
}

/**
 * Saves training data to a JSON lines file
 * @param trainingData Array of prompt-completion pairs
 * @param filePath Path to save the file
 */
export async function saveTrainingData(
  trainingData: Array<{ prompt: string; completion: string }>,
  filePath: string
): Promise<void> {
  // Skip in browser environment
  if (isBrowser) {
    console.warn("saveTrainingData is not supported in browser environments");
    return;
  }

  try {
    // Ensure fs is available
    if (!fs) {
      console.warn("File system module not available");
      return;
    }

    // Ensure directory exists
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Convert each object to a JSON string and join with newlines
    const jsonLines = trainingData
      .map((item) => JSON.stringify(item))
      .join("\n");

    // Write to file
    fs.writeFileSync(filePath, jsonLines, "utf8");
  } catch (error) {
    console.error("Error saving training data:", error);
    throw error;
  }
}

/**
 * Creates an episode from working memory components
 * @param thoughts The thoughts that led to the actions
 * @param actions The actions taken
 * @param results The results of the actions
 * @param agent The agent that generated the episode
 * @param options Optional configuration for exporting training data
 * @param options.exportTrainingData Whether to export this episode as training data
 * @param options.trainingDataPath Path to save the training data
 * @returns A new Episode object
 */
export async function createEpisodeFromWorkingMemory(
  thoughts: Thought[],
  actions: Action[],
  results: ActionResult[],
  agent: AnyAgent,
  options?: {
    exportTrainingData?: boolean;
    trainingDataPath?: string;
  }
): Promise<Episode> {
  const episodicMemory = await generateEpisodicMemory(
    agent,
    thoughts,
    actions,
    results
  );

  // If exportTrainingData is true and not in browser, create and save training data
  if (options?.exportTrainingData && !isBrowser && fs) {
    const trainingDataPair = createTrainingDataPair(episodicMemory);

    // Default path if not provided
    const filePath = options.trainingDataPath || "./training-data.jsonl";

    // Check if file exists to append or create new
    let existingData: Array<{ prompt: string; completion: string }> = [];
    if (fs.existsSync(filePath)) {
      const fileContent = fs.readFileSync(filePath, "utf8");
      existingData = fileContent
        .split("\n")
        .filter((line: string) => line.trim() !== "")
        .map((line: string) => JSON.parse(line));
    }

    // Add new training data pair
    existingData.push(trainingDataPair);

    // Save updated training data
    await saveTrainingData(existingData, filePath);
  }

  return {
    id: randomUUIDv7(),
    timestamp: Date.now(),
    observation: episodicMemory.observation,
    result: episodicMemory.result,
    thoughts: episodicMemory.thoughts,
  };
}

/**
 * Exports all episodes as training data
 * @param episodes Array of episodes to export
 * @param filePath Path to save the training data
 */
export async function exportEpisodesAsTrainingData(
  episodes: Episode[],
  filePath: string = "./training-data.jsonl"
): Promise<void> {
  // Skip in browser environment
  if (isBrowser) {
    console.warn(
      "exportEpisodesAsTrainingData is not supported in browser environments"
    );
    return;
  }

  // Ensure fs is available
  if (!fs) {
    console.warn("File system module not available");
    return;
  }

  const trainingData = episodes.map((episode) => ({
    prompt: episode.observation,
    completion: `${episode.thoughts}\n\n${episode.result}`,
  }));

  await saveTrainingData(trainingData, filePath);
}

export async function generateEpisode(
  thought: Thought,
  actionCall: ActionCall,
  result: ActionResult,
  agent: AnyAgent,
  contextId: string,
  actions: AnyAction[]
) {
  // Find the corresponding Action for the ActionCall
  const action = actions.find((a) => a.name === actionCall.name);

  if (!action) {
    return;
  }

  const thoughts = [thought];
  const actionsArray = [action];
  const results = [result];

  const episode = await createEpisodeFromWorkingMemory(
    thoughts,
    actionsArray,
    results,
    agent,
    {
      exportTrainingData: agent.exportTrainingData === true,
      trainingDataPath: agent.trainingDataPath || "./training-data.jsonl",
    }
  );

  await agent.memory.vector.upsert(`${contextId}`, [
    {
      id: episode.id,
      text: episode.observation,
      metadata: episode,
    },
  ]);
}

--- End File: packages/core/src/memory/utils.ts ---

--- File: packages/core/src/prompt.ts ---
import { ZodType } from "zod";
import zodToJsonSchema from "zod-to-json-schema";
import type { Node, ElementNode } from "./xml";
import { parse as parseXML } from "./xml";
import type { TemplateVariables } from "./types";
import { render } from "./formatters";

export type Formatter<
  Variables extends Record<string, any> = Record<string, any>,
  Data = any,
> = (data: Data) => Record<keyof Variables, any>;

export type InferFormatter<TPrompt extends AnyPrompt> =
  TPrompt extends Prompt<infer Data, infer Variables>
    ? Formatter<Variables, Data>
    : never;

export type PromptVisitor<
  Output = any,
  Attributes extends Record<string, any> = Record<string, any>,
> = (
  output: Output,
  node: ElementNode<Attributes>,
  parse: () => Node[]
) => void;

export type GetVisitors<
  Output = any,
  T extends Record<string, Record<string, any>> = Record<
    string,
    Record<string, any>
  >,
> = {
  [K in keyof T]?: PromptVisitor<Output, T[K]>;
} & {
  [key: string]: PromptVisitor<Output, any>;
};

export type Prompt<
  Data = any,
  Variables extends Record<string, any> = Record<string, any>,
> = <TData extends Data>(
  data: TData,
  formatter?: Formatter<Variables, TData>
) => string;

export type AnyPrompt = Prompt<any, any>;

export type InferPromptVariables<TPrompt extends AnyPrompt> =
  TPrompt extends Prompt<any, infer Vars> ? Vars : never;

export type InferPromptData<TPrompt extends AnyPrompt> =
  TPrompt extends Prompt<infer Data> ? Data : never;

export type GeneratePromptConfig<
  TPrompt extends AnyPrompt | string = any,
  Variables extends Record<string, any> = any,
  Data = Record<string, any>,
  TFormatter extends Formatter<Variables, Data> = Formatter<Variables, Data>,
> = {
  template: TPrompt;
  variables: Variables;
  data: Data;
  formatter?: TFormatter;
};

export type InferGeneratePromptConfig<TPrompt extends AnyPrompt | string> =
  | (TPrompt extends Prompt<infer Data, infer Variables>
      ? GeneratePromptConfig<TPrompt, Variables, Data>
      : never)
  | (TPrompt extends string
      ? GeneratePromptConfig<TPrompt, TemplateVariables<TPrompt>>
      : never);

export type InferPromptComponents<TPrompt extends AnyPrompt | string> =
  TPrompt extends Prompt<any, infer Components> ? Components : never;

export function getZodJsonSchema(schema: ZodType<any>) {
  return zodToJsonSchema(schema, "schema").definitions!.schema;
}

export function createPrompt<
  Template extends string = string,
  Variables extends TemplateVariables<Template> = TemplateVariables<Template>,
  Data extends Record<string, any> = Record<string, any>,
>(
  prompt: Template,
  formatter?: Formatter<Variables, Data>
): Prompt<Data, Variables> {
  return (data, customFormatter) => {
    return render(
      prompt,
      customFormatter
        ? customFormatter(data)
        : formatter
          ? formatter(data)
          : data
    );
  };
}

export type Parser<Output> = (content: string) => Output;

export function createParser<
  Output = any,
  Components extends Record<string, Record<string, any>> = Record<
    string,
    Record<string, any>
  >,
  Visitors extends GetVisitors<Output, Components> = GetVisitors<
    Output,
    Components
  >,
>(getOutput: () => Output, visitors: Visitors): Parser<Output> {
  return (content) => {
    const validTags = new Set(Object.keys(visitors));

    // fix for bad outputs;

    content = content
      .split("\n")
      .map((line) => {
        // Check if line starts with '/'
        if (line.startsWith("/")) {
          // Extract the tag name using regex
          const match = line.match(/^\/([^ >]+)/);

          if (match && match[1]) {
            const tagName = match[1];

            // Check if this is a valid tag
            if (validTags.has(tagName)) {
              console.log("fixing line:\n" + line);
              // Replace the leading '/' with '<'
              return line.replace("/", "<");
            }
          }
        }

        // Return original line if no fix needed
        return line;
      })
      .join("\n");

    const state = getOutput();

    parseXML(content, (node, parse) => {
      if (node.type === "element" && node.name in visitors) {
        visitors[node.name](state, node as ElementNode<any>, parse);
      }
      return node;
    });

    return state;
  };
}

--- End File: packages/core/src/prompt.ts ---

--- File: packages/core/src/prompts/main.ts ---
import { formatWorkingMemory } from "../context";
import {
  formatAction,
  formatContextLog,
  formatContextState,
  formatOutputInterface,
  render,
  xml,
} from "../formatters";
import type { Prompt } from "../prompt";
import type {
  AnyAction,
  AnyContext,
  ContextState,
  Output,
  WorkingMemory,
} from "../types";
/*

## Instructions
- If asked for something - never do a summary unless you are asked to do a summary. Always respond with the exact information requested.
- You must use the available actions and outputs to respond to the context.
- You must reason about the context, think, and planned actions.
- IMPORTANT: If you state that you will perform an action, you MUST issue the corresponding action call. Do not say you will do something without actually issuing the action call.
- IMPORTANT: Never end your response with a plan to do something without actually doing it. Always follow through with action calls.
- When you determine that no further actions or outputs are needed and the flow should end, use the <finalize/> tag to indicate completion.
*/

export const templateSections = {
  intro: `\
  You are tasked with analyzing inputs, formulating outputs, and initiating actions based on the given contexts. 
  You will be provided with a set of available actions, outputs, and contexts. 
  Your instructions are to analyze the situation and respond appropriately.`,
  instructions: `\
Follow these steps to process the updates:

1. Analyze the updates and available data:
   Wrap your reasoning process in <reasoning> tags. Consider:

   - Check the available data to avoid redundant action calls
   - The availabe contexts and their state
   - The available actions and their asynchronous nature
   - The content of the new updates
   - Potential dependencies between actions

   Response determination guidelines:

   a) First check if required state exists in the available contexts
   b) Respond to direct questions or requests for information

2. Plan actions:
   Before formulating a response, consider:

   - What data is already available
   - Which actions need to be initiated
   - The order of dependencies between actions
   - How to handle potential action failures
   - What information to provide while actions are processing

3. Formulate a output (if needed):
   If you decide to respond to the message, use <output> tags to enclose your output.
   Consider:

   - Using available data when possible
   - Acknowledging that certain information may not be immediately available
   - Setting appropriate expectations about action processing time
   - Indicating what will happen after actions complete
   - You can only use outputs listed in the <available_outputs> section
   - Follow the schemas provided for each output
  
4. Initiate actions (if needed):
   Use <action_call> tags to initiate actions. Remember:

   - Actions are processed asynchronously after your response
   - Results will not be immediately available
   - You can only use actions listed in the <available_actions> section
   - Follow the schemas provided for each action
   - Actions should be used when necessary to fulfill requests or provide information that cannot be conveyed through a simple response
   - If action belongs to a context and there is many instances of the context use <action_call contextKey="[Context key]">

5. No output or action:
   If you determine that no output or action is necessary, don't respond to that message.`,
  /*
   */
  /*

Configuration: Access pre-defined configuration values using {{config.key.name}} (e.g., {{config.default_user_id}}). (Assumption: Configuration is structured)

 (e.g., {{shortTermMemory.current_project_file}}).

*/
  content: `\
Here are the available actions you can initiate:
{{actions}}

Here are the available outputs you can use:
{{outputs}}

Here is the current contexts:
{{contexts}}

<template-engine>
Purpose: Utilize the template engine ({{...}} syntax) primarily to streamline workflows by transferring data between different components within the same turn. This includes passing outputs from actions into subsequent action arguments, or embedding data from various sources directly into response outputs. This enhances efficiency and reduces interaction latency.

Data Referencing: You can reference data from:
Action Results: Use {{calls[index].path.to.value}} to access outputs from preceding actions in the current turn (e.g., {{calls[0].sandboxId}}). Ensure the index correctly points to the intended action call.
Short-Term Memory: Retrieve values stored in short-term memory using {{shortTermMemory.key}}

When to Use:
Data Injection: Apply templating when an action argument or a response output requires specific data (like an ID, filename, status, or content) from an action result, configuration, or short-term memory available within the current turn.
Direct Dependencies: Particularly useful when an action requires a specific result from an action called immediately before it in the same turn.
</template-engine>

Here is the current working memory:
{{workingMemory}}

Now, analyze the following updates:
{{updates}}`,
  response: `\
Here's how you structure your response:
<response>
<reasoning>
[Your reasoning of the context, think, messages, and planned actions]
</reasoning>

[List of async action calls to be initiated, if applicable]
<action_call name="[Action name]">[action arguments using the schema and format]</action_call>

[List of outputs, if applicable]
<output type="[Output type]" {...output attributes using the attributes_schema}>
[output content using the content_schema]
</output>
</response>`,

  footer: `\
Remember:
- Always correlate results with their original actions using callId
- Never repeat your outputs
- Consider the complete chain of events when formulating responses
- Address any failures or unexpected results explicitly
- Initiate follow-up actions only when necessary
- Provide clear, actionable insights based on the combined results
- Maintain context awareness between original request and final results

IMPORTANT: 
Always include the 'type' attribute in the output tag and ensure it matches one of the available output types listed above.
Remember to include the other attribute in the output tag and ensure it matches the output attributes schema.
If you say you will perform an action, you MUST issue the corresponding action call here
Always check the correct format for each action: JSON or XML
`,
} as const;

export const promptTemplate = `\
{{intro}}

{{instructions}}

{{content}}

{{response}}

{{footer}}
`;

export function formatPromptSections({
  contexts,
  outputs,
  actions,
  workingMemory,
  maxWorkingMemorySize,
  chainOfThoughtSize,
}: {
  contexts: ContextState<AnyContext>[];
  outputs: Output[];
  actions: AnyAction[];
  workingMemory: WorkingMemory;
  maxWorkingMemorySize?: number;
  chainOfThoughtSize?: number;
}) {
  return {
    actions: xml("available-actions", undefined, actions.map(formatAction)),
    outputs: xml(
      "available-outputs",
      undefined,
      outputs.map(formatOutputInterface)
    ),
    contexts: xml("contexts", undefined, contexts.map(formatContextState)),
    workingMemory: xml(
      "working-memory",
      undefined,
      formatWorkingMemory({
        memory: workingMemory,
        size: maxWorkingMemorySize,
        processed: true,
      })
    ),
    thoughts: xml(
      "thoughts",
      undefined,
      workingMemory.thoughts
        .map((log) => formatContextLog(log))
        .slice(-(chainOfThoughtSize ?? 5))
    ),
    updates: xml(
      "updates",
      undefined,
      formatWorkingMemory({
        memory: workingMemory,
        processed: false,
      })
    ),
  };
}

// WIP
export const mainPrompt = {
  name: "main",
  template: promptTemplate,
  sections: templateSections,
  render: (data: ReturnType<typeof formatPromptSections>) => {
    const sections = Object.fromEntries(
      Object.entries(mainPrompt.sections).map(([key, templateSection]) => [
        key,
        render(templateSection, data as any),
      ])
    ) as Record<keyof typeof templateSections, string>;
    return render(mainPrompt.template, sections);
  },
  formatter: formatPromptSections,
} as const;

export type PromptConfig = typeof mainPrompt;

--- End File: packages/core/src/prompts/main.ts ---

--- File: packages/core/src/providers/api.ts ---
/**
 * A generic response shape for GraphQL queries.
 */
interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{
    message: string;
    locations?: Array<{
      line: number;
      column: number;
    }>;
    path?: string[];
  }>;
}

/**
 * A generalized error type for convenience.
 */
class ApiError extends Error {
  constructor(
    public message: string,
    public details?: unknown
  ) {
    super(message);
  }
}

/**
 * A helper function to perform generic REST requests.
 * - `url`: full endpoint (including protocol, domain, path)
 * - `options`: standard `fetch` options such as method, headers, body, etc.
 */
export async function fetchRest<ResponseType = unknown>(
  url: string,
  options: RequestInit = {}
): Promise<ResponseType> {
  try {
    const res = await fetch(url, options);
    if (!res.ok) {
      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {
        status: res.status,
        statusText: res.statusText,
      });
    }
    return (await res.json()) as ResponseType;
  } catch (error) {
    throw error instanceof ApiError
      ? error
      : new ApiError("Unknown error during REST fetch", error);
  }
}

/**
 * A helper function to perform GraphQL queries.
 * - `endpoint`: the GraphQL endpoint URL.
 * - `query`: the GraphQL query string.
 * - `variables`: an optional variables object for the query.
 */
export async function fetchGraphQL<DataType = unknown>(
  endpoint: string,
  query: string,
  variables?: Record<string, unknown>
): Promise<DataType | Error> {
  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        query,
        variables,
      }),
    });

    if (!res.ok) {
      throw new ApiError(`HTTP Error: ${res.status} ${res.statusText}`, {
        status: res.status,
        statusText: res.statusText,
      });
    }

    const result = (await res.json()) as GraphQLResponse<DataType>;

    if (result.errors && result.errors.length > 0) {
      return new ApiError(result.errors[0].message, result.errors);
    }

    if (!result.data) {
      return new ApiError("No data returned from GraphQL query");
    }

    return result.data;
  } catch (error) {
    return error instanceof ApiError
      ? error
      : new ApiError("Unknown error during GraphQL fetch", error);
  }
}

--- End File: packages/core/src/providers/api.ts ---

--- File: packages/core/src/providers/index.ts ---
export { fetchGraphQL } from "./api";

--- End File: packages/core/src/providers/index.ts ---

--- File: packages/core/src/serviceProvider.ts ---
import type { Container } from "./container";

type ServiceProvider = {
  register?: (container: Container) => void;
  boot?: (container: Container) => void | Promise<void>;
};

type ServiceState = {
  providers: ServiceProvider[];
  booted: Set<ServiceProvider>;
  registered: Set<ServiceProvider>;
};

type ServiceManager = {
  register: (provider: ServiceProvider) => void;
  bootAll: () => Promise<void>;
  isBooted: (provider: ServiceProvider) => boolean;
  isRegistered: (provider: ServiceProvider) => boolean;
};

const service = (config: ServiceProvider): ServiceProvider => config;

const createServiceManager = (container: Container): ServiceManager => {
  const state: ServiceState = {
    providers: [],
    booted: new Set(),
    registered: new Set(),
  };

  const registerProvider = (
    container: Container,
    provider: ServiceProvider
  ): void => {
    if (state.registered.has(provider)) return;
    state.registered.add(provider);
    if (provider.register) provider.register(container);
  };

  const bootProvider = async (
    container: Container,
    provider: ServiceProvider
  ): Promise<void> => {
    if (state.booted.has(provider)) return;
    state.booted.add(provider);
    if (provider.boot) await provider.boot(container);
  };

  return {
    register: (provider: ServiceProvider): void => {
      if (!state.providers.includes(provider)) {
        state.providers.push(provider);
        registerProvider(container, provider);
      }
    },

    bootAll: async (): Promise<void> => {
      // First register all providers
      for (const provider of state.providers) {
        registerProvider(container, provider);
      }

      // Then boot them
      for (const provider of state.providers) {
        await bootProvider(container, provider);
      }
    },

    isBooted: (provider: ServiceProvider): boolean =>
      state.booted.has(provider),

    isRegistered: (provider: ServiceProvider): boolean =>
      state.registered.has(provider),
  };
};

export {
  createServiceManager,
  service,
  type ServiceProvider,
  type ServiceManager,
};

--- End File: packages/core/src/serviceProvider.ts ---

--- File: packages/core/src/streaming.ts ---
import type { Log, LogChunk } from "./types";
import { randomUUIDv7 } from "./utils";
import { xmlStreamParser } from "./xml";

type PartialLog = Partial<Log> &
  Pick<Log, "ref" | "id" | "timestamp" | "processed">;

export type StackElement = {
  index: number;
  tag: string;
  attributes: Record<string, any>;
  content: string;
  done: boolean;
  _depth: number;
};

export type StackElementChunk =
  | { type: "el"; el: StackElement }
  | { type: "content"; index: number; content: string }
  | { type: "end"; index: number };

export async function handleStream(
  textStream: AsyncGenerator<string>,
  initialIndex: number,
  tags: Set<string>,
  push: (el: StackElement) => void,
  __pushChunk?: (chunk: StackElementChunk) => void
) {
  let current: StackElement | undefined = undefined;
  let stack: StackElement[] = [];

  let index = initialIndex;

  const parser = xmlStreamParser(tags, (tag, isClosingTag) => {
    if (current?.tag === tag && !isClosingTag && tag === "think") {
      return false;
    }

    if (current?.tag === tag && !isClosingTag && tag === "response") {
      return false;
    }

    if (current?.tag === tag && !isClosingTag && tag === "reasoning") {
      return false;
    }

    if (current?.tag === tag && !isClosingTag) {
      current._depth++;
      return false;
    }

    if (current?.tag === tag && isClosingTag) {
      if (current._depth > 0) {
        current._depth--;
        return false;
      }

      return true;
    }

    if (current === undefined || current?.tag === "response") return true;

    if (isClosingTag && stack.length > 0) {
      const stackIndex = stack.findIndex((el) => el.tag === tag);
      if (stackIndex === -1) return false;

      if (current) {
        push({
          ...current,
          done: true,
        });

        __pushChunk?.({ type: "end", index: current.index });

        current = undefined;
      }

      const closed = stack.splice(stackIndex + 1).reverse();

      for (const el of closed) {
        push({
          ...el,
          done: true,
        });

        __pushChunk?.({ type: "end", index: el.index });
      }

      current = stack.pop();

      return true;
    }

    return false;
  });

  parser.next();

  function handleChunk(chunk: string) {
    let result = parser.next(chunk);
    while (!result.done && result.value) {
      if (result.value.type === "start") {
        if (current) stack.push(current);
        current = {
          index: index++,
          tag: result.value.name,
          attributes: result.value.attributes,
          content: "",
          done: false,
          _depth: 0,
        };

        push(current);

        __pushChunk?.({ type: "el", el: structuredClone(current) });
      }

      if (result.value.type === "end") {
        if (current) {
          push({
            ...current,
            done: true,
          });

          __pushChunk?.({ type: "end", index: current.index });

          current = stack.pop();
        }
      }

      if (result.value.type === "text") {
        if (current) {
          __pushChunk?.({
            type: "content",
            index: current.index,
            content: result.value.content,
          });

          current.content += result.value.content;
          push(current);
        }

        // todo: we need to handle text when !current to a default output?
      }

      if (result.value.type === "self-closing") {
        const el = {
          index: index++,
          tag: result.value.name,
          attributes: result.value.attributes,
          content: "",
          done: true,
          _depth: 0,
        };

        push(el);

        __pushChunk?.({ type: "el", el });
      }
      result = parser.next();
    }
  }

  for await (const chunk of textStream) {
    handleChunk(chunk);
  }

  parser.return?.();
}

export async function* wrapStream(
  stream: AsyncIterable<string>,
  prefix: string,
  suffix: string
) {
  yield prefix;
  yield* stream;
  yield suffix;
}

const defaultTags = new Set([
  "think",
  "thinking",
  "response",
  "output",
  "action_call",
  "reasoning",
]);

export function createContextStreamHandler({
  abortSignal,
  pushLog,
  __pushLogChunk,
}: {
  abortSignal?: AbortSignal;
  pushLog: (log: Log, done: boolean) => void;
  __pushLogChunk?: (chunk: LogChunk) => void;
}) {
  const streamState = {
    index: 0,
    logsByIndex: new Map<number, PartialLog>(),
  };

  function getOrCreateRef<
    TLog extends Omit<PartialLog, "id" | "timestamp" | "processed">,
  >(
    index: number,
    ref: TLog
  ): TLog & Pick<PartialLog, "id" | "timestamp" | "processed"> {
    if (!streamState.logsByIndex.has(index)) {
      streamState.logsByIndex.set(index, {
        id: randomUUIDv7(),
        timestamp: Date.now(),
        processed: false,
        ...ref,
      });
    }

    streamState.index = Math.max(index, streamState.index);

    return streamState.logsByIndex.get(index)! as TLog &
      Pick<PartialLog, "id" | "timestamp" | "processed">;
  }

  function __streamChunkHandler(chunk: StackElementChunk) {
    if (abortSignal?.aborted) return;

    switch (chunk.type) {
      case "el": {
        const { el } = chunk;

        switch (el.tag) {
          case "think":
          case "thinking":
          case "reasoning": {
            const ref = getOrCreateRef(el.index, {
              ref: "thought",
            });

            __pushLogChunk?.({
              type: "log",
              log: {
                ...ref,
                content: "",
              },
              done: el.done,
            });

            break;
          }

          case "action_call": {
            const ref = getOrCreateRef(el.index, {
              ref: "action_call",
            });

            const { name, ...params } = el.attributes;

            __pushLogChunk?.({
              type: "log",
              log: {
                ...ref,
                name,
                params,
                content: "",
                data: undefined,
                processed: false,
              },
              done: el.done,
            });

            break;
          }

          case "output": {
            const ref = getOrCreateRef(el.index, {
              ref: "output",
            });

            const { type, ...params } = el.attributes;

            __pushLogChunk?.({
              type: "log",
              log: {
                ...ref,
                type,
                params,
                content: "",
                data: undefined,
              },
              done: el.done,
            });

            break;
          }

          default:
            break;
        }

        break;
      }
      case "content": {
        const log = streamState.logsByIndex.get(chunk.index);
        if (log) {
          __pushLogChunk?.({
            type: "content",
            id: log.id,
            content: chunk.content,
          });
        }
        break;
      }

      case "end": {
        const log = streamState.logsByIndex.get(chunk.index);
        if (log) {
          __pushLogChunk?.({
            type: "done",
            id: log.id,
          });
        }
        break;
      }
    }
  }

  function streamHandler(el: StackElement) {
    if (abortSignal?.aborted) return;
    switch (el.tag) {
      case "think":
      case "thinking":
      case "reasoning": {
        const ref = getOrCreateRef(el.index, {
          ref: "thought",
        });
        pushLog(
          {
            ...ref,
            content: el.content,
          },
          el.done
        );
        break;
      }
      case "action_call": {
        const ref = getOrCreateRef(el.index, {
          ref: "action_call",
        });
        const { name, ...params } = el.attributes;
        pushLog(
          {
            ...ref,
            name,
            params,
            content: el.content,
            data: undefined,
            processed: false,
          },
          el.done
        );
        break;
      }
      case "output": {
        const ref = getOrCreateRef(el.index, {
          ref: "output",
        });
        const { type, ...params } = el.attributes;
        pushLog(
          {
            ...ref,
            type,
            params,
            content: el.content,
            data: undefined,
          },
          el.done
        );
        break;
      }
      default:
        break;
    }
  }

  return {
    streamState,
    streamHandler,
    tags: defaultTags,
    __streamChunkHandler,
  };
}

--- End File: packages/core/src/streaming.ts ---

--- File: packages/core/src/task.ts ---
import { v7 as randomUUIDv7 } from "uuid";
import type { MaybePromise } from "./types";
import pDefer, { type DeferredPromise } from "p-defer";

type TaskContext = {
  taskId: string;
  abortSignal: AbortSignal;
};

type TaskOptions = {
  concurrency?: number;
  retry?: number | boolean | ((failureCount: number, err: unknown) => boolean);
  priority?: number;
  queueKey?: string;
  timeoutMs?: number;
};

export type Task<Params = any, Result = any, TError = any> = {
  key: string;
  handler: (params: Params, ctx: TaskContext) => MaybePromise<Result>;
  concurrency?: number;
  retry?: boolean | number | ((failureCount: number, error: TError) => boolean);
  priority?: number;
  queueKey?: string;
  timeoutMs?: number;
};

type InferTaskParams<T extends Task<any, any>> =
  T extends Task<infer Params, any> ? Params : unknown;
type InferTaskResult<T extends Task<any, any>> =
  T extends Task<any, infer Result> ? Result : unknown;

type TaskInstance<TTask extends Task<any, any> = Task<any, any>> = {
  id: string;
  task: TTask;
  params: InferTaskParams<TTask>;
  options: Omit<TaskOptions, "concurrency">;
  createdAt: Date;
  attempts: number;
  controller: AbortController;
  promise: DeferredPromise<InferTaskResult<TTask>>;
  lastError?: unknown;
};

type Queue = {
  concurrency: number;
  tasks: TaskInstance[];
  running: Set<string>;
};

export class TaskRunner {
  queues = new Map<string, Queue>();
  processing = new Set<string>();

  constructor(concurrency: number) {
    this.queues.set("main", { concurrency, tasks: [], running: new Set() });
  }

  setQueue(queueKey: string, concurrency: number) {
    const queue = this.queues.get(queueKey);

    this.queues.set(queueKey, {
      tasks: queue?.tasks ?? [],
      running: queue?.running ?? new Set(),
      concurrency,
    });
  }

  private processQueue(queueKey: string) {
    if (this.processing.has(queueKey)) return;

    const queue = this.queues.get(queueKey);
    if (!queue) return;

    this.processing.add(queueKey);

    try {
      while (queue.tasks.length > 0 && queue.running.size < queue.concurrency) {
        queue.tasks.sort(
          (a, b) => (b.options.priority ?? 0) - (a.options.priority ?? 0)
        );
        const instance = queue.tasks.shift();

        if (!instance) break;

        queue.running.add(instance.id);

        this.processTask(instance)
          .then((res) => {
            instance.promise.resolve(res);
          })
          .catch((err) => {
            instance.promise.reject(err);
          })
          .finally(() => {
            queue.running.delete(instance.id);
            this.processQueue(queueKey);
          });
      }
    } finally {
      this.processing.delete(queueKey);
    }
  }

  private async processTask(instance: TaskInstance) {
    while (true) {
      instance.attempts++;

      if (instance.attempts > 1) {
        await new Promise<void>((resolve) =>
          setTimeout(resolve, 250 * instance.attempts)
        );
      }

      instance.controller.signal.throwIfAborted();

      try {
        const result = await instance.task.handler(instance.params, {
          taskId: instance.id,
          abortSignal: instance.controller.signal,
        });

        return result;
      } catch (error) {
        const retry = instance.options.retry;

        if (retry) {
          if (typeof retry === "boolean" && retry) continue;
          if (typeof retry === "number" && retry >= instance.attempts) continue;
          if (typeof retry === "function" && retry(instance.attempts, error))
            continue;
        }

        throw error;
      }
    }
  }

  async enqueueTask<TTask extends Task<any, any, any>>(
    task: TTask,
    params: InferTaskParams<TTask>,
    options?: Omit<TaskOptions, "concurrency"> & { abortSignal?: AbortSignal }
  ): Promise<InferTaskResult<TTask>> {
    const queueKey = options?.queueKey ?? "main";

    if (!this.queues.has(queueKey)) {
      throw new Error("Invalid queue");
    }

    const { key, handler, ...defaultTaskToptions } = task;

    const controller = new AbortController();
    const deferPromise = pDefer<InferTaskResult<TTask>>();

    const instance: TaskInstance<TTask> = {
      id: randomUUIDv7(),
      task,
      params,
      options: {
        ...defaultTaskToptions,
        ...options,
      },
      controller,
      attempts: 0,
      createdAt: new Date(),
      promise: deferPromise,
    };

    if (instance.options?.timeoutMs) {
      const timeoutSignal = AbortSignal.timeout(instance.options.timeoutMs);

      timeoutSignal.addEventListener(
        "abort",
        () => {
          controller.abort(timeoutSignal.reason);
        },
        {
          once: true,
          signal: controller.signal,
        }
      );
    }

    if (options?.abortSignal) {
      function signalListener() {
        controller.abort(options!.abortSignal!.reason);
      }

      options.abortSignal.addEventListener("abort", signalListener, {
        once: true,
        signal: controller.signal,
      });
    }

    controller.signal.addEventListener(
      "abort",
      () => {
        deferPromise.reject(controller.signal.reason);
      },
      {
        once: true,
      }
    );

    this.queues.get(queueKey)!.tasks.push(instance);

    setTimeout(() => this.processQueue(queueKey), 0);

    return deferPromise.promise;
  }
}

export function task<Params = any, Result = any>(
  definition: Task<Params, Result>
) {
  return definition;
}

--- End File: packages/core/src/task.ts ---

--- File: packages/core/src/tasks/index.ts ---
import {
  streamText,
  type CoreMessage,
  type LanguageModelV1,
  type StreamTextResult,
  type ToolSet,
} from "ai";
import { task } from "../task";
import type {
  Action,
  ActionCallContext,
  AnyAction,
  AnyAgent,
  AnyContext,
  WorkingMemory,
} from "../types";
import type { Logger } from "../logger";
import { wrapStream } from "../streaming";
import { modelsResponseConfig, reasoningModels } from "../configs";

/**
 * Prepares a stream response by handling the stream result and parsing it.
 *
 * @param options - Configuration options
 * @param options.contextId - The ID of the context
 * @param options.step - The current step in the process
 * @param options.stream - The stream result to process
 * @param options.logger - The logger instance
 * @param options.task - The task context containing callId and debug function
 * @returns An object containing the parsed response promise and wrapped text stream
 */
function prepareStreamResponse({
  model,
  stream,
  isReasoningModel,
}: {
  model: LanguageModelV1;
  stream: StreamTextResult<ToolSet, never>;
  isReasoningModel: boolean;
}) {
  const prefix =
    modelsResponseConfig[model.modelId]?.prefix ??
    (isReasoningModel
      ? (modelsResponseConfig[model.modelId]?.thinkTag ?? "<think>")
      : "<response>");
  const suffix = "</response>";
  return {
    getTextResponse: async () => {
      const result = await stream.text;
      const text = prefix + result + suffix;
      return text;
    },
    stream: wrapStream(stream.textStream, prefix, suffix),
  };
}

type GenerateOptions = {
  prompt: string;
  workingMemory: WorkingMemory;
  logger: Logger;
  model: LanguageModelV1;
  onError: (error: unknown) => void;
};

export const runGenerate = task({
  key: "agent:run:generate",
  handler: async (
    { prompt, workingMemory, model, onError }: GenerateOptions,
    { abortSignal }
  ) => {
    const isReasoningModel = reasoningModels.includes(model.modelId);

    const messages: CoreMessage[] = [
      {
        role: "user",
        content: [
          {
            type: "text",
            text: prompt,
          },
        ],
      },
    ];

    if (modelsResponseConfig[model.modelId]?.assist !== false)
      messages.push({
        role: "assistant",
        content: isReasoningModel
          ? (modelsResponseConfig[model.modelId]?.thinkTag ?? "<think>")
          : "<response>",
      });

    if (workingMemory.currentImage) {
      messages[0].content = [
        ...messages[0].content,
        {
          type: "image",
          image: workingMemory.currentImage,
        },
      ] as CoreMessage["content"];
    }

    const stream = streamText({
      model,
      messages,
      stopSequences: ["\n</response>"],
      temperature: 0.6,
      abortSignal,
      onError: (event) => {
        onError(event.error);
      },
    });

    return prepareStreamResponse({
      model,
      stream,
      isReasoningModel,
    });
  },
});

/**
 * Task that executes an action with the given context and parameters.
 *
 * @param options - Configuration options
 * @param options.ctx - The agent context with memory
 * @param options.action - The action to execute
 * @param options.call - The action call details
 * @param options.agent - The agent instance
 * @param options.logger - The logger instance
 * @returns The result of the action execution
 * @throws Will throw an error if the action execution fails
 */
export const runAction = task({
  key: "agent:run:action",
  handler: async <TContext extends AnyContext>({
    ctx,
    action,
    agent,
    logger,
  }: {
    ctx: ActionCallContext<any, TContext>;
    action: AnyAction;
    agent: AnyAgent;
    logger: Logger;
  }) => {
    logger.info(
      "agent:action_call:" + ctx.call.id,
      ctx.call.name,
      JSON.stringify(ctx.call.data)
    );

    try {
      const result =
        action.schema === undefined
          ? await Promise.try((action as Action<undefined>).handler, ctx, agent)
          : await Promise.try(action.handler as any, ctx.call.data, ctx, agent);

      logger.debug("agent:action_result:" + ctx.call.id, ctx.call.name, result);

      return result;
    } catch (error) {
      logger.error("agent:action", "ACTION_FAILED", { error });

      if (action.onError) {
        return await Promise.try(action.onError, error, ctx, agent);
      } else {
        throw error;
      }
    }
  },
});

--- End File: packages/core/src/tasks/index.ts ---

--- File: packages/core/src/types.ts ---
import { type LanguageModelV1, type Schema } from "ai";
import { z, ZodObject, ZodType, type ZodRawShape } from "zod";
import type { Container } from "./container";
import type { ServiceProvider } from "./serviceProvider";
import type { BaseMemory } from "./memory";
import type { TaskRunner } from "./task";
import type { Logger } from "./logger";

export { type LanguageModelV1, type Schema } from "ai";

export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export type MaybePromise<T = any> = T | Promise<T>;

/**
 * Represents a memory configuration for storing data
 * @template Data - Type of data stored in memory
 */
export type Memory<Data = any> = {
  /** Unique identifier for this memory */
  key: string;
  /** Function to initialize memory data */
  create: () => Promise<Data> | Data;
};

/**
 * Extracts the data type from a Memory type
 * @template TMemory - Memory type to extract data from
 */
export type InferMemoryData<TMemory extends Memory<any>> =
  TMemory extends Memory<infer Data> ? Data : never;

/**
 * Represents an execution chain with experts and metadata
 */
export type Chain = {
  /** Unique identifier for the chain */
  id: string;
  /** Current thinking/reasoning state */
  thinking: string;
  /** Goal or purpose of this chain */
  purpose: string;
  /** List of experts involved in the chain */
  experts: { name: string; data: string }[];
};

/**
 * Interface for storing and retrieving memory data
 */
export interface MemoryStore {
  /**
   * Retrieves data from memory
   * @template T - Type of data to retrieve
   * @param key - Key to lookup
   * @returns Promise resolving to data or null if not found
   */
  get<T>(key: string): Promise<T | null>;

  /**
   * Stores data in memory
   * @template T - Type of data to store
   * @param key - Key to store under
   * @param value - Data to store
   */
  set<T>(key: string, value: T): Promise<void>;

  /**
   * Removes data from memory
   * @param key - Key to remove
   */
  delete(key: string): Promise<void>;

  /**
   * Removes all data from memory
   */
  clear(): Promise<void>;

  keys(base?: string): Promise<string[]>;
}
/**
 * Interface for storing and retrieving vector data
 */
export interface VectorStore {
  /** Optional connection string for the vector store */
  connection?: string;

  /**
   * Adds or updates data in the vector store
   * @param contextId - Unique identifier for the context
   * @param data - Data to add or update
   */
  upsert(contextId: string, data: any): Promise<void>;

  /**
   * Searches the vector store for similar data
   * @param contextId - Context to search within
   * @param query - Query text to search for
   * @returns Array of matching documents
   */
  query(contextId: string, query: string): Promise<any[]>;

  /**
   * Creates a new index in the vector store
   * @param indexName - Name of the index to create
   */
  createIndex(indexName: string): Promise<void>;

  /**
   * Deletes an existing index from the vector store
   * @param indexName - Name of the index to delete
   */
  deleteIndex(indexName: string): Promise<void>;
}

/**
 * Represents the working memory state during execution
 */
export interface WorkingMemory {
  /** List of input references */
  inputs: InputRef[];
  /** List of output references */
  outputs: OutputRef[];
  /** List of thought records */
  thoughts: Thought[];
  /** List of action calls */
  calls: ActionCall[];
  /** List of action results */
  results: ActionResult[];
  // chains: Chain[];
  episodicMemory?: EpisodicMemory;
  /** Current image URL for multimodal context */
  currentImage?: URL;

  runs: RunRef[];

  steps: StepRef[];

  events: EventRef[];
}

export type InferSchema<T> = T extends {
  schema?: infer S extends z.AnyZodObject;
}
  ? z.infer<S>
  : unknown;

export type InferAgentContext<TAgent extends AnyAgent> =
  TAgent extends Agent<infer Content> ? Content : never;

export type InferAgentMemory<TAgent extends AnyAgent> = InferContextMemory<
  InferAgentContext<TAgent>
>;

/**
 * Represents an evaluator that can validate action/output results
 * @template Data - Type of data being evaluated
 * @template Context - Context type for the evaluation
 */
export type Evaluator<
  Data = any,
  Context extends AgentContext<any> = AgentContext<any>,
  TAgent extends AnyAgent = AnyAgent,
> = {
  name: string;
  description?: string;
  /** Schema for the evaluation result */
  schema?: z.ZodType<any>;
  /** Custom prompt template for LLM-based evaluation */
  prompt?: string;
  /** Custom handler for evaluation logic */
  handler?: (
    data: Data,
    ctx: Context,
    agent: TAgent
  ) => Promise<boolean> | boolean;
  /** Optional callback when evaluation fails */
  onFailure?: (ctx: Context, agent: TAgent) => Promise<void> | void;
};

export type ActionSchema =
  | ZodRawShape
  | z.AnyZodObject
  | Schema<any>
  | undefined;

export type InferActionArguments<TSchema = undefined> =
  TSchema extends ZodRawShape
    ? z.infer<ZodObject<TSchema>>
    : TSchema extends z.AnyZodObject
      ? z.infer<TSchema>
      : TSchema extends Schema
        ? TSchema["_type"]
        : undefined;

export interface ActionContext<
  TContext extends AnyContext = AnyContext,
  AContext extends AnyContext = AnyContext,
  ActionMemory extends Memory<any> = Memory<any>,
> extends AgentContext<TContext> {
  actionMemory: InferMemoryData<ActionMemory>;
  agentMemory: InferContextMemory<AContext> | undefined;
  abortSignal?: AbortSignal;
}

export interface ActionCallContext<
  Schema extends ActionSchema = undefined,
  TContext extends AnyContext = AnyContext,
  AContext extends AnyContext = AnyContext,
  ActionMemory extends Memory<any> = Memory<any>,
> extends ActionContext<TContext, AContext, ActionMemory>,
    ContextStateApi<TContext> {
  call: ActionCall<InferActionArguments<Schema>>;
}

type InferActionResult<Result> = Result extends ZodRawShape
  ? z.infer<ZodObject<Result>>
  : Result extends ZodType
    ? z.infer<Result>
    : Result extends Schema
      ? Result["_type"]
      : Result;

export type ActionHandler<
  Schema extends ActionSchema = undefined,
  Result = any,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
  TMemory extends Memory<any> = Memory<any>,
> = Schema extends undefined
  ? (
      ctx: ActionCallContext<
        Schema,
        TContext,
        InferAgentContext<TAgent>,
        TMemory
      >,
      agent: TAgent
    ) => MaybePromise<Result>
  : (
      args: InferActionArguments<Schema>,
      ctx: ActionCallContext<
        Schema,
        TContext,
        InferAgentContext<TAgent>,
        TMemory
      >,
      agent: TAgent
    ) => MaybePromise<Result>;

/**
 * Represents an action that can be executed with typed parameters
 * @template Schema - Zod schema defining parameter types
 * @template Result - Return type of the action
 * @template Context - Context type for the action execution
 */
export interface Action<
  Schema extends ActionSchema = ActionSchema,
  Result = any,
  TError = unknown,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
  TMemory extends Memory<any> = Memory<any>,
> {
  name: string;
  description?: string;
  instructions?: string;

  schema: Schema;

  attributes?: ActionSchema;

  memory?: TMemory;

  install?: (agent: TAgent) => Promise<void> | void;

  enabled?: (
    ctx: ActionContext<TContext, InferAgentContext<TAgent>, TMemory>
  ) => boolean;

  handler: ActionHandler<Schema, Result, TContext, TAgent, TMemory>;

  returns?: ActionSchema;

  format?: (result: ActionResult<Result>) => string | string[];
  /** Optional evaluator for this specific action */
  evaluator?: Evaluator<Result, AgentContext<TContext>, TAgent>;

  context?: TContext;

  onSuccess?: (
    result: ActionResult<Result>,
    ctx: ActionCallContext<
      Schema,
      TContext,
      InferAgentContext<TAgent>,
      TMemory
    >,
    agent: TAgent
  ) => Promise<void> | void;

  retry?: boolean | number | ((failureCount: number, error: TError) => boolean);

  onError?: (
    err: TError,
    ctx: ActionCallContext<
      Schema,
      TContext,
      InferAgentContext<TAgent>,
      TMemory
    >,
    agent: TAgent
  ) => MaybePromise<any>;

  queueKey?:
    | string
    | ((
        ctx: ActionCallContext<
          Schema,
          TContext,
          InferAgentContext<TAgent>,
          TMemory
        >
      ) => string);

  examples?: string[];

  parser?: (ref: ActionCall) => InferActionArguments<Schema>;

  callFormat?: "json" | "xml";

  templateResolver?:
    | boolean
    | ((
        key: string,
        path: string,
        ctx: ActionCallContext<
          Schema,
          TContext,
          InferAgentContext<TAgent>,
          TMemory
        >
      ) => MaybePromise<string>);
}

export type ActionCtxRef = AnyAction & {
  ctxRef: {
    type: string;
    id: string;
    key?: string;
  };
};

export type OutputCtxRef = AnyOutput & {
  ctxRef: {
    type: string;
    id: string;
    key?: string;
  };
};

export type OutputSchema = z.AnyZodObject | z.ZodString | ZodRawShape;

type InferOutputSchemaParams<Schema extends OutputSchema> =
  Schema extends ZodRawShape
    ? z.infer<ZodObject<Schema>>
    : Schema extends z.AnyZodObject | z.ZodString
      ? z.infer<Schema>
      : never;

export type OutputRefResponse = Pick<OutputRef, "data" | "params"> & {
  processed?: boolean;
};

export type OutputResponse =
  | OutputRefResponse
  | OutputRefResponse[]
  | undefined
  | void;

export type Output<
  Schema extends OutputSchema = OutputSchema,
  Response extends OutputRefResponse = OutputRefResponse,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = {
  type: string;
  description?: string;
  instructions?: string;
  required?: boolean;
  schema?: Schema;
  attributes?: OutputSchema;
  context?: TContext;
  install?: (agent: TAgent) => MaybePromise<void>;
  enabled?: (ctx: ContextState<TContext>) => boolean;
  handler?: (
    data: InferOutputSchemaParams<Schema>,
    ctx: ContextState<TContext> & {
      outputRef: OutputRef<InferOutputSchemaParams<Schema>>;
    },
    agent: TAgent
  ) => MaybePromise<Response | Response[]>;
  format?: (res: OutputRef<Response["data"]>) => string | string[] | XMLElement;
  /** Optional evaluator for this specific output */
  evaluator?: Evaluator<OutputResponse, AgentContext<Context>, TAgent>;

  examples?: string[];
};

export type AnyOutput = Output<any, any, any, AnyAgent>;

export type AnyAction = Action<any, any, any, any, AnyAgent, any>;

export type AnyActionWithContext<Ctx extends Context<any, any, any, any, any>> =
  Action<any, any, any, Ctx, AnyAgent, any>;

/**
 * Represents an input handler with validation and subscription capability
 * @template Schema - Zod schema for input parameters
 * @template Context - Context type for input handling
 */
export type Input<
  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape =
    | z.AnyZodObject
    | z.ZodString
    | z.ZodRawShape,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = {
  type: string;
  description?: string;
  schema?: Schema;
  context?: TContext;

  install?: (agent: TAgent) => MaybePromise<void>;
  enabled?: (state: AgentContext<TContext>) => Promise<boolean> | boolean;
  handler?: (
    data: InferSchemaArguments<Schema>,
    ctx: AgentContext<TContext>,
    agent: TAgent
  ) => MaybePromise<Pick<InputRef, "params" | "data">>;
  format?: (
    ref: InputRef<InferSchemaArguments<Schema>>
  ) => string | string[] | XMLElement;
  subscribe?: (
    send: <TContext extends AnyContext>(
      context: TContext,
      args: InferSchemaArguments<TContext["schema"]>,
      data: InferSchemaArguments<Schema>
    ) => MaybePromise<void>,
    agent: TAgent
  ) => (() => void) | void | Promise<void | (() => void)>;
};

export type RunRef = {
  id: string;
  ref: "run";
  type: string;
  data: any;
  // metrics: {
  //   duration: number;
  //   steps: number;
  //   inputs: number;
  //   thoughts: number;
  //   calls: number;
  //   results: number;
  //   outputs: number;
  // };
  // metadata: any;
  timestamp: number;
  processed: boolean;
  stopReason?: string;
};

export type StepRef = {
  id: string;
  ref: "step";
  type: string;
  step: number;
  data: {
    prompt?: string;
    response?: string;
  };
  timestamp: number;
  processed: boolean;
};

/** Reference to an input event in the system */
export type InputRef<Data = any> = {
  id: string;
  ref: "input";
  type: string;
  content: any;
  data: Data;
  params?: Record<string, string>;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
};

/** Reference to an output event in the system */
export type OutputRef<Data = any> = {
  id: string;
  ref: "output";
  type: string;
  params?: Record<string, string>;
  content: string;
  data: Data;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
  error?: unknown;
};

/** Represents a call to an action */
export type ActionCall<Data = any> = {
  ref: "action_call";
  id: string;
  name: string;
  content: string;
  data: Data;
  params?: Record<string, string>;
  timestamp: number;
  processed: boolean;
};

/** Represents the result of an action execution */
export type ActionResult<Data = any> = {
  ref: "action_result";
  id: string;
  callId: string;
  name: string;
  data: Data;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
};

/** Represents a thought or reasoning step */
export type Thought = {
  ref: "thought";
  id: string;
  content: string;
  timestamp: number;
  processed: boolean;
};

/** Represents a event */
export type EventRef<Data = any> = {
  ref: "event";
  id: string;
  name: string;
  params?: Record<string, string>;
  data: Data;
  timestamp: number;
  processed: boolean;
  formatted?: string | string[] | XMLElement;
};

export type Log =
  | InputRef
  | OutputRef
  | Thought
  | ActionCall
  | ActionResult
  | EventRef;

export type AnyRef =
  | InputRef
  | OutputRef
  | Thought
  | ActionCall
  | ActionResult
  | EventRef
  | StepRef
  | RunRef;

/** Properties required for Chain-of-Thought execution */
export type COTProps = {
  model: LanguageModelV1;
  plan: string;
  inputs: InputRef[];
  actions: Action[];
  outputs: Output[];
  logs: Log[];
};

/** Response structure from Chain-of-Thought execution */
export type COTResponse = {
  plan: string[];
  actions: ActionCall[];
  outputs: OutputRef[];
  thinking: Thought[];
};

/** Represents an XML element structure */
export type XMLElement = {
  tag: string;
  params?: Record<string, string>;
  children?: string | (XMLElement | string)[];
};

/** Utility type to preserve type information */
export type Pretty<type> = { [key in keyof type]: type[key] } & unknown;

/**
 * Extracts variable names from a template string
 * @template T - Template string type
 */
export type ExtractTemplateVariables<T extends string> =
  T extends `${infer Start}{{${infer Var}}}${infer Rest}`
    ? Var | ExtractTemplateVariables<Rest>
    : never;

/**
 * Converts a dot-separated path into a nested object type
 * @template P - Path string
 * @template V - Value type at the leaf
 */
type PathToObject<
  P extends string,
  V = string,
> = P extends `${infer Key}.${infer Rest}`
  ? { [K in Key]: PathToObject<Rest, V> }
  : { [K in P]: V };

/**
 * Merges a union of paths into a single nested object type
 * @template T - Union of path strings
 * @template V - Value type at the leaf
 */
type UnionToObject<T, V = string> = T extends string
  ? PathToObject<T, V>
  : never;

/**
 * Merges multiple object types into one (handles union overlap)
 */
type Merge<T> = { [K in keyof T]: T[K] extends object ? Merge<T[K]> : T[K] };

type Prettify<T> = T extends object ? { [K in keyof T]: Prettify<T[K]> } : T;
/**
 * Creates a type mapping template variables (including nested paths) to values
 * @template T - Template string type
 * @template V - Value type at the leaf (defaults to string)
 */
export type TemplateVariables<T extends string, V = any> = {
  [K in ExtractTemplateVariables<T>]: any;
};

/** Represents an expert system with instructions and actions */
export type Expert = {
  type: string;
  description: string;
  instructions: string;
  model?: LanguageModelV1;
  actions?: AnyAction[];
};

export interface AgentContext<TContext extends AnyContext = AnyContext> {
  id: string;
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
  options: InferContextOptions<TContext>;
  settings: ContextSettings;
  memory: InferContextMemory<TContext>;
  workingMemory: WorkingMemory;
}

export type AnyAgent = Agent<any>;

export interface Handlers {
  onLogStream: (log: AnyRef, done: boolean) => void;
  onThinking: (thought: Thought) => void;
}

export type Registry = {
  contexts: Map<string, AnyContext>;
  actions: Map<string, AnyAction>;
  inputs: Map<string, Input>;
  outputs: Map<string, Output>;
  extensions: Map<string, Extension>;
  prompts: Map<string, string>;
  models: Map<string, LanguageModelV1>;
};

interface AgentDef<TContext extends AnyContext = AnyContext> {
  logger: Logger;

  /**
   * The memory store and vector store used by the agent.
   */
  memory: BaseMemory;

  /**
   * The current context of the agent.
   */
  context?: TContext;

  /**
   * Debugger function for the agent.
   */
  debugger: Debugger;

  /**
   * The container used by the agent.
   */
  container: Container;

  /**
   * The task runner used by the agent.
   */
  taskRunner: TaskRunner;

  /**
   * The primary language model used by the agent.
   */
  model?: LanguageModelV1;

  /**
   * The reasoning model used by the agent, if any.
   */
  reasoningModel?: LanguageModelV1;

  /**
   * The vector model used by the agent, if any.
   */
  vectorModel?: LanguageModelV1;

  /**
   * A record of input configurations for the agent.
   */
  inputs: Record<string, InputConfig<any, AnyContext, Agent<TContext>>>;

  /**
   * A record of output configurations for the agent.
   */
  outputs: Record<string, Omit<Output<any, any, TContext, any>, "type">>;

  /**
   * A record of event schemas for the agent.
   */
  events: Record<string, z.AnyZodObject>;

  /**
   * A record of expert configurations for the agent.
   */
  experts: Record<string, ExpertConfig>;

  /**
   * An array of actions available to the agent.
   */
  actions: Action<
    any,
    any,
    unknown,
    AnyContext,
    Agent<TContext>,
    Memory<any>
  >[];

  /**
   * Whether to export training data for episodes
   */
  exportTrainingData?: boolean;

  /**
   * Path to save training data
   */
  trainingDataPath?: string;
}

export type LogChunk =
  | { type: "log"; log: AnyRef; done: boolean }
  | { type: "content"; id: string; content: string }
  | { type: "data"; id: string; data: any }
  | { type: "done"; id: string };

/**
 * Represents an agent with various configurations and methods for handling contexts, inputs, outputs, and more.
 * @template Memory - The type of memory used by the agent.
 * @template TContext - The type of context used by the agent.
 */
export interface Agent<TContext extends AnyContext = AnyContext>
  extends AgentDef<TContext> {
  registry: Registry;

  isBooted(): boolean;

  /**
   * Exports all episodes as training data
   * @param filePath Optional path to save the training data
   */
  exportAllTrainingData?: (filePath?: string) => Promise<void>;

  /**
   * Emits an event with the provided arguments.
   * @param args - Arguments to pass to the event handler.
   */
  emit: (...args: any[]) => void;

  /**
   * Runs the agent with the provided options.
   * @param opts - Options for running the agent.
   * @returns A promise that resolves to an array of logs.
   */
  run: <
    TContext extends AnyContext,
    SubContextRefs extends AnyContext[] = AnyContext[],
  >(opts: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
    model?: LanguageModelV1;
    contexts?: ContextRefArray<SubContextRefs>;
    outputs?: Record<string, Omit<Output<any, any, TContext, any>, "type">>;
    actions?: AnyAction[];
    handlers?: Partial<Handlers>;
    abortSignal?: AbortSignal;
    chain?: Log[];
  }) => Promise<AnyRef[]>;

  /**
   * Sends an input to the agent with the provided options.
   * @param opts - Options for sending input to the agent.
   * @returns A promise that resolves to an array of logs.
   */
  send: <
    SContext extends AnyContext,
    SubContextRefs extends AnyContext[] = AnyContext[],
  >(opts: {
    context: SContext;
    args: InferSchemaArguments<SContext["schema"]>;
    input: { type: string; data: any };
    model?: LanguageModelV1;
    contexts?: ContextRefArray<SubContextRefs>;
    outputs?: Record<string, Omit<Output<any, any, SContext, any>, "type">>;
    actions?: AnyAction[];
    handlers?: Partial<Handlers>;
    abortSignal?: AbortSignal;
    chain?: Log[];
  }) => Promise<AnyRef[]>;

  /**
   * Evaluates the provided context.
   * @param ctx - The context to evaluate.
   * @returns A promise that resolves when evaluation is complete.
   */
  evaluator<SContext extends AnyContext>(
    ctx: AgentContext<SContext>
  ): Promise<void>;

  /**
   * Starts the agent with the provided arguments.
   * @param args - Arguments to pass to the agent on start.
   * @returns A promise that resolves to the agent instance.
   */
  start(args?: InferSchemaArguments<TContext["schema"]>): Promise<this>;

  /**
   * Stops the agent.
   * @returns A promise that resolves when the agent is stopped.
   */
  stop(): Promise<void>;

  /**
   * Retrieves the contexts managed by the agent.
   * @returns A promise that resolves to an array of context objects.
   */
  getContexts(): Promise<
    { id: string; type: string; args?: any; settings?: ContextSettings }[]
  >;

  /**
   * Retrieves the ID for a given context and arguments.
   * @param params - Parameters for retrieving the context ID.
   * @returns The context ID.
   */
  getContextId<TContext extends AnyContext = AnyContext>(params: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
  }): string;

  getAgentContext(): Promise<ContextState<TContext> | undefined>;

  /**
   * Retrieves the state of a given context and arguments.
   * @param params - Parameters for retrieving the context state.
   * @returns A promise that resolves to the context state.
   */
  getContext<TContext extends AnyContext>(params: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
  }): Promise<ContextState<TContext>>;

  loadContext<TContext extends AnyContext>(params: {
    context: TContext;
    args: InferSchemaArguments<TContext["schema"]>;
  }): Promise<ContextState<TContext> | null>;

  saveContext(
    state: ContextState<AnyContext>,
    workingMemory?: WorkingMemory
  ): Promise<boolean>;

  getContextById<TContext extends AnyContext>(
    id: string
  ): Promise<ContextState<TContext> | null>;

  /**
   * Retrieves the working memory for a given context ID.
   * @param contextId - The ID of the context.
   * @returns A promise that resolves to the working memory.
   */
  getWorkingMemory(contextId: string): Promise<WorkingMemory>;

  deleteContext(contextId: string): Promise<void>;

  subscribeContext(
    contextId: string,
    handler: (log: AnyRef, done: boolean) => void
  ): () => void;

  __subscribeChunk(
    contextId: string,
    handler: (log: LogChunk) => void
  ): () => void;
}

export type Debugger = (contextId: string, keys: string[], data: any) => void;

export type Config<TContext extends AnyContext = AnyContext> = Partial<
  AgentDef<TContext>
> & {
  model?: Agent["model"];
  reasoningModel?: Agent["reasoningModel"];
  logLevel?: LogLevel;
  contexts?: AnyContext[];
  services?: ServiceProvider[];
  extensions?: Extension<TContext>[];
  /** Whether to export training data for episodes */
  exportTrainingData?: boolean;
  /** Path to save training data */
  trainingDataPath?: string;
};

/** Configuration type for inputs without type field */
export type InputConfig<
  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape =
    | z.AnyZodObject
    | z.ZodString
    | z.ZodRawShape,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = Omit<Input<Schema, TContext, TAgent>, "type">;

/** Configuration type for outputs without type field */
export type OutputConfig<
  Schema extends OutputSchema = OutputSchema,
  Response extends OutputRefResponse = OutputRefResponse,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
> = Omit<Output<Schema, Response, TContext, TAgent>, "type">;

/** Configuration type for experts without type field */
export type ExpertConfig = Omit<Expert, "type">;

/** Function type for subscription cleanup */
export type Subscription = () => void;

/** Enum defining available log levels */
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3,
  TRACE = 4,
}

/** Results from a research operation */
export interface ResearchResult {
  learnings: string[];
  visitedUrls: string[];
}

/** Configuration for research operations */
export interface ResearchConfig {
  query: string;
  breadth: number;
  depth: number;
  learnings?: string[];
  visitedUrls?: string[];
}

export interface IChain {
  /**
   * A unique identifier for the chain (e.g., "starknet", "ethereum", "solana", etc.)
   */
  chainId: string;

  /**
   * Read (call) a contract or perform a query on this chain.
   * The `call` parameter can be chain-specific data.
   */
  read(call: unknown): Promise<any>;

  /**
   * Write (execute a transaction) on this chain, typically requiring signatures, etc.
   */
  write(call: unknown): Promise<any>;
}
/** Type representing instructions that can be either a single string or array of strings */
export type Instruction = string | string[];

/** Type representing any Context with generic type parameters */
export type AnyContext = Context<any, any, any, any, any>;

/**
 * Extracts the Memory type from a Context type
 * @template TContext - The Context type to extract Memory from
 */
export type InferContextMemory<TContext extends AnyContext> =
  TContext extends Context<infer TMemory, any, any, any, any> ? TMemory : never;

/**
 * Extracts the Context type from a Context type
 * @template TContext - The Context type to extract Ctx from
 */
export type InferContextOptions<TContext extends AnyContext> =
  TContext extends Context<any, any, infer Options, any, any> ? Options : never;

/**
 * Configuration for a context that manages state and behavior
 * @template Memory - Type of memory for this context
 * @template Args - Zod schema type for context arguments
 * @template Ctx - Type of context data
 * @template Exports - Type of exported data
 */

export type InferSchemaArguments<
  Schema extends z.ZodTypeAny | ZodRawShape | undefined = z.ZodTypeAny,
> = Schema extends ZodRawShape
  ? z.infer<ZodObject<Schema>>
  : Schema extends z.ZodTypeAny
    ? z.infer<Schema>
    : never;

type ActionArray<T extends AnyAction[]> = {
  [K in keyof T]: T[K];
};

type MergeArrays<T extends Array<any>, C extends Array<any>> = T & C;

interface ContextConfigApi<
  TMemory = any,
  Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<
    string,
    z.ZodTypeAny | ZodRawShape
  >,
> {
  setActions<
    TActions extends AnyActionWithContext<
      Context<TMemory, Schema, Ctx, any, Events>
    >[],
  >(
    actions: TActions
  ): Context<TMemory, Schema, Ctx, TActions, Events>;
  setInputs<
    TSchemas extends Record<
      string,
      z.AnyZodObject | z.ZodString | z.ZodRawShape
    >,
  >(inputs: {
    [K in keyof TSchemas]: InputConfig<
      TSchemas[K],
      Context<TMemory, Schema, Ctx, Actions, Events>,
      AnyAgent
    >;
  }): Context<TMemory, Schema, Ctx, Actions, Events>;
  setOutputs<
    TSchemas extends Record<
      string,
      z.AnyZodObject | z.ZodString | z.ZodRawShape
    >,
  >(outputs: {
    [K in keyof TSchemas]: OutputConfig<
      TSchemas[K],
      any,
      Context<TMemory, Schema, Ctx, Actions, Events>,
      AnyAgent
    >;
  }): Context<TMemory, Schema, Ctx, Actions, Events>;

  use<Refs extends AnyContext[]>(
    composer: ContextComposer<
      Context<TMemory, Schema, Ctx, Actions, Events>,
      Refs
    >
  ): Context<TMemory, Schema, Ctx, Actions, Events>;
}

export type EventDef<Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny> =
  {
    name: string;
    schema: Schema;
    // description?: string;
  };

export type ContextsEventsRecord<T extends Record<string, EventDef>> = {
  [K in keyof T]: T[K]["schema"];
};

export type ContextConfig<
  TMemory = any,
  Args extends z.ZodTypeAny | ZodRawShape = any,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | z.ZodRawShape> = Record<
    string,
    z.ZodTypeAny | z.ZodRawShape
  >,
> = Optional<
  Omit<Context<TMemory, Args, Ctx, Actions, Events>, keyof ContextConfigApi>,
  "actions" | "events" | "inputs" | "outputs"
>;

type ContextComposer<
  TContext extends AnyContext,
  T extends AnyContext[] = AnyContext[],
> = (state: ContextState<TContext>) => ContextRefArray<T>;

type BaseContextComposer<TContext extends AnyContext> = (
  state: ContextState<TContext>
) => ContextRef[];

export type Resolver<Result, Ctx> = Result | ((ctx: Ctx) => Result);

export interface Context<
  TMemory = any,
  Schema extends z.ZodTypeAny | ZodRawShape = z.ZodTypeAny,
  Ctx = any,
  Actions extends AnyAction[] = AnyAction[],
  Events extends Record<string, z.ZodTypeAny | ZodRawShape> = Record<
    string,
    z.ZodTypeAny | ZodRawShape
  >,
> extends ContextConfigApi<TMemory, Schema, Ctx, Actions, Events> {
  /** Unique type identifier for this context */
  type: string;
  /** Zod schema for validating context arguments */
  schema?: Schema;
  /** Function to generate a unique key from context arguments */
  key?: (args: InferSchemaArguments<Schema>) => string;

  /** Setup function to initialize context data */
  setup?: (
    args: InferSchemaArguments<Schema>,
    settings: ContextSettings,
    agent: AnyAgent
  ) => Promise<Ctx> | Ctx;

  /** Optional function to create new memory for this context */
  create?: (
    params: {
      id: string;
      key?: string;
      args: InferSchemaArguments<Schema>;
      options: Ctx;
      settings: ContextSettings;
    },
    agent: AnyAgent
  ) => TMemory | Promise<TMemory>;

  /** Optional instructions for this context */
  instructions?: Resolver<Instruction, ContextState<this>>;

  /** Optional description of this context */
  description?: Resolver<string | string[], ContextState<this>>;

  /** Optional function to load existing memory */
  load?: (
    id: string,
    params: { options: Ctx; settings: ContextSettings }
  ) => Promise<TMemory | null>;
  /** Optional function to save memory state */
  save?: (state: ContextState<this>) => Promise<void>;

  /** Optional function to render memory state */
  render?: (
    state: ContextState<this>
  ) => string | string[] | XMLElement | XMLElement[] | (string | XMLElement)[];

  model?: LanguageModelV1;

  onRun?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;

  onStep?: (ctx: AgentContext<this>, agent: AnyAgent) => Promise<void>;

  shouldContinue?: (ctx: AgentContext<this>) => boolean;

  onError?: (
    error: unknown,
    ctx: AgentContext<this>,
    agent: AnyAgent
  ) => Promise<void>;

  loader?: (state: ContextState<this>, agent: AnyAgent) => Promise<void>;

  maxSteps?: number;

  maxWorkingMemorySize?: number;

  actions?: Resolver<Action[], ContextState<this>>;

  events?: Resolver<Events, ContextState<this>>;

  /**
   * A record of input configurations for the context.
   */
  inputs?: Resolver<
    Record<string, InputConfig<any, any, AnyAgent>>,
    ContextState<this>
  >;

  /**
   * A record of output configurations for the context.
   */
  outputs?: Resolver<
    Record<string, Omit<Output<any, any, AnyContext, any>, "type">>,
    ContextState<this>
  >;

  __composers?: BaseContextComposer<this>[];

  __templateResolvers?: Record<
    string,
    TemplateResolver<AgentContext<this> & ContextStateApi<this>>
  >;
}

export type ContextSettings = {
  model?: LanguageModelV1;
  maxSteps?: number;
  maxWorkingMemorySize?: number;
};

export type ContextRef<TContext extends AnyContext = AnyContext> = {
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
};

export type ContextsRefRecord<T extends Record<string, AnyContext>> = {
  [K in keyof T]: ContextRef<T[K]>;
};

export type ContextRefArray<T extends AnyContext[] = AnyContext[]> = {
  [K in keyof T]: ContextRef<T[K]>;
};

type InferContextEvents<TContext extends AnyContext> =
  TContext extends Context<any, any, any, any, infer Events> ? Events : never;

type ContextEventEmitter<TContext extends AnyContext> = <
  T extends keyof InferContextEvents<TContext>,
>(
  event: T,
  args: InferSchema<InferContextEvents<TContext>[T]>,
  options?: { processed?: boolean }
) => void;

//wip

export type TemplateResolver<Ctx = any> = (
  path: string,
  ctx: Ctx
) => MaybePromise<any>;

export interface ContextStateApi<TContext extends AnyContext> {
  emit: ContextEventEmitter<TContext>;
  push: (log: Log) => Promise<any>;

  callAction: (
    call: ActionCall,
    options?: Partial<{
      templateResolvers?: Record<string, TemplateResolver>;
      queueKey?: string;
    }>
  ) => Promise<ActionResult>;

  __getRunResults: () => Promise<ActionResult>[];
}

export type ContextState<TContext extends AnyContext = AnyContext> = {
  id: string;
  key?: string;
  context: TContext;
  args: InferSchemaArguments<TContext["schema"]>;
  options: InferContextOptions<TContext>;
  memory: InferContextMemory<TContext>;
  settings: ContextSettings;
  contexts: string[];
};

export type Extension<
  TContext extends AnyContext = AnyContext,
  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,
  Inputs extends Record<string, InputConfig<any, any>> = Record<
    string,
    InputConfig<any, any>
  >,
> = Pick<
  Config<TContext>,
  "inputs" | "outputs" | "actions" | "services" | "events"
> & {
  name: string;
  install?: (agent: AnyAgent) => Promise<void> | void;
  contexts?: Contexts;
  inputs: Inputs;
};

export interface Episode {
  id: string;
  timestamp: number;
  observation: string; // Context and setup
  result: string; // Outcomes of actions
  thoughts: string;
  metadata?: {
    success?: boolean;
    tags?: string[];
    [key: string]: any;
  };
}

export interface EpisodicMemory {
  episodes: Episode[];
  index?: number; // For vector store indexing
}

--- End File: packages/core/src/types.ts ---

--- File: packages/core/src/utils.ts ---
import { z } from "zod";
import type {
  Action,
  ActionCall,
  ActionSchema,
  AnyAgent,
  AnyContext,
  EventRef,
  ExpertConfig,
  Extension,
  InputConfig,
  InputRef,
  Memory,
  Optional,
  OutputConfig,
  OutputRef,
  OutputRefResponse,
  OutputSchema,
  WorkingMemory,
} from "./types";
import { v7 as randomUUIDv7 } from "uuid";

export { randomUUIDv7 };
/**
 * Creates an input configuration
 * @template Schema - Zod schema type for input validation
 * @template Context - Context type for input handling
 * @param config - Input configuration object
 * @returns Typed input configuration
 */
export function input<
  Schema extends z.AnyZodObject | z.ZodString | z.ZodRawShape = z.ZodString,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
>(config: InputConfig<Schema, TContext, TAgent>) {
  return config;
}

/**
 * Creates an action configuration
 * @template Schema - Zod schema type for action parameters
 * @template Result - Return type of the action
 * @template Context - Context type for action execution
 * @param action - Action configuration object
 * @returns Typed action configuration
 */
export function action<
  TSchema extends ActionSchema = undefined,
  Result = any,
  TError = any,
  TContext extends AnyContext = AnyContext,
  TAgent extends AnyAgent = AnyAgent,
  TMemory extends Memory<any> = Memory<any>,
>(
  action: Optional<
    Action<TSchema, Result, TError, TContext, TAgent, TMemory>,
    "schema"
  >
): Action<TSchema, Result, TError, TContext, TAgent, TMemory> {
  return {
    ...action,
    schema: action.schema ?? (undefined as TSchema),
  };
}

/**
 * Creates an output configuration
 * @template Schema - Zod schema type for output validation
 * @template Context - Context type for output handling
 * @param config - Output configuration object
 * @returns Typed output configuration
 */
export function output<
  Schema extends OutputSchema = OutputSchema,
  Response extends OutputRefResponse = OutputRefResponse,
  Context extends AnyContext = AnyContext,
>(config: OutputConfig<Schema, Response, Context>) {
  return config;
}

/**
 * Creates an expert configuration
 * @template Context - Context type for expert execution
 * @param config - Expert configuration object
 * @returns Typed expert configuration
 */
export function expert(config: ExpertConfig) {
  return config;
}

/**
 * Options for text chunking
 */
type ChunkOptions = {
  maxChunkSize: number;
};

/**
 * Splits text into chunks based on maximum chunk size
 * @param text - The text to split into chunks
 * @param options - Chunking options including maximum chunk size
 * @returns Array of text chunks
 */
export function splitTextIntoChunks(
  text: string,
  options: ChunkOptions
): string[] {
  const { maxChunkSize } = options;
  const lines = text.split("\n");
  const chunks: string[] = [];
  let currentChunk = "";

  for (const line of lines) {
    // If adding this line would exceed maxChunkSize, start a new chunk
    if (currentChunk.length + line.length + 1 > maxChunkSize) {
      if (currentChunk) {
        chunks.push(currentChunk.trim());
      }
      currentChunk = line;
    } else {
      // Add line to current chunk with a newline
      currentChunk = currentChunk ? currentChunk + "\n" + line : line;
    }
  }

  // Don't forget to add the last chunk
  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
}

/**
 * Creates a memory configuration
 * @template Data - Type of data stored in memory
 * @param memory - Memory configuration object
 * @returns Typed memory configuration
 */
export function memory<Data = any>(memory: Memory<Data>) {
  return memory;
}

export function extension<
  Contexts extends Record<string, AnyContext> = Record<string, AnyContext>,
  Inputs extends Record<string, InputConfig<any, any>> = Record<
    string,
    InputConfig<any, any>
  >,
>(
  config: Optional<Extension<AnyContext, Contexts, Inputs>, "inputs">
): Extension<AnyContext, Contexts, Inputs> {
  return {
    ...config,
    inputs: config.inputs ?? ({} as Inputs),
  };
}

/**
 * Validates environment variables against a Zod schema
 * @param schema The Zod schema to validate against
 * @param env The environment object to validate (defaults to process.env)
 * @returns The validated environment variables
 */
export function validateEnv<T extends z.ZodTypeAny>(
  schema: T,
  env = process.env
): z.infer<T> {
  try {
    return schema.parse(env);
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error("Environment validation failed:");
      error.errors.forEach((err) => {
        console.error(`- ${err.message}`);
      });
      process.exit(1);
    }
    throw error;
  }
}

type TrimWorkingMemoryOptions = {
  thoughts: number;
  inputs: number;
  outputs: number;
  actions: number;
};

const defaultTrimOptions: TrimWorkingMemoryOptions = {
  thoughts: 6,
  inputs: 20,
  outputs: 20,
  actions: 20,
};

export function trimWorkingMemory(
  workingMemory: WorkingMemory,
  options: TrimWorkingMemoryOptions = defaultTrimOptions
) {
  workingMemory.thoughts = workingMemory.thoughts.slice(-options.thoughts);
  workingMemory.inputs = workingMemory.inputs.slice(-options.inputs);
  workingMemory.outputs = workingMemory.outputs.slice(-options.outputs);
  workingMemory.calls = workingMemory.calls.slice(-options.actions);
  workingMemory.results = workingMemory.results.slice(-options.actions);
}

/**
 * Utility function to safely execute a function asynchronously
 * This is an implementation of the Promise.try pattern which isn't available in standard JS
 * @param fn The function to execute
 * @param ...args The arguments to pass to the function
 * @returns A promise that resolves with the result of the function
 */
export async function tryAsync<T>(fn: Function, ...args: any[]): Promise<T> {
  try {
    return await fn(...args);
  } catch (error) {
    return Promise.reject(error);
  }
}

export function createInputRef(
  ref: Pick<InputRef, "type" | "content" | "data" | "processed">
): InputRef {
  return {
    id: randomUUIDv7(),
    ref: "input",
    timestamp: Date.now(),
    ...ref,
  };
}

export function createOutputRef(
  ref: Pick<OutputRef, "type" | "content" | "data" | "processed">
): OutputRef {
  return {
    id: randomUUIDv7(),
    ref: "output",
    timestamp: Date.now(),
    ...ref,
  };
}

export function createEventRef(
  ref: Pick<EventRef, "name" | "data" | "processed">
): EventRef {
  return {
    id: randomUUIDv7(),
    ref: "event",
    timestamp: Date.now(),
    ...ref,
  };
}

export function createActionCall(
  ref: Pick<ActionCall, "name" | "content" | "data" | "processed" | "params">
): ActionCall {
  return {
    id: randomUUIDv7(),
    ref: "action_call",
    timestamp: Date.now(),
    ...ref,
  };
}

--- End File: packages/core/src/utils.ts ---

--- File: packages/core/src/xml.ts ---
/**
 * Creates a regular expression to match XML tags with a specific name
 * @param tagName - The name of the XML tag to match
 * @returns RegExp that matches the specified XML tag and captures its attributes and content
 */
export function createTagRegex(tagName: string) {
  return new RegExp(
    `(<${tagName}(?:\\s+[^>]*)?>)([\\s\\S]*?)<\/${tagName}>`,
    "gs"
  );
}

export function createTagParser<T = string>(
  tagName: string,
  contentParser?: (content: any) => T
) {
  const regex = createTagRegex(tagName);

  return (content: string) => {
    const matches = Array.from(content.matchAll(regex));
    try {
      return matches.map((t) => ({
        tag: tagName,
        params: t[1] ? parseAttributes(t[1]) : {},
        content: (contentParser
          ? contentParser(t[2]?.trim())
          : t[2]?.trim()) as T extends string ? string : T,
      }));
    } catch (error) {
      throw error;
    }
  };
}

// new parser
export type TextNode = {
  type: "text";
  content: string;
  parent?: Node;
  children?: never;
};

export type ElementNode<
  Attributes extends Record<string, string> = Record<string, any>,
> = {
  type: "element";
  name: string;
  attributes: Attributes;
  content: string;
  parent?: Node;
  children?: Node[];
  closed?: true;
};

export type Node = TextNode | ElementNode;

export type NodeVisitor = (node: Node, parse: () => Node[]) => Node;

export function parseAttributes(text: string): Record<string, string> {
  const attrs: Record<string, string> = {};
  if (text.length === 0) return attrs;
  const matches = text.matchAll(/(\w+)="([^"]*)"/g);
  for (const match of matches) {
    attrs[match[1]] = match[2];
  }
  return attrs;
}

export function parse(
  text: string,
  visitor: NodeVisitor,
  depth = 0,
  parent: Node | undefined = undefined
): Node[] {
  const nodes: Node[] = [];

  let workingText = text.trim();

  while (workingText.length > 0) {
    // Find first opening tag
    const tagStart = workingText.indexOf("<");
    if (tagStart === -1) {
      const textNode: TextNode = {
        type: "text",
        content: workingText.trim(),
      };
      nodes.push(visitor(textNode, () => []));
      break;
    }

    const tagEnd = workingText.indexOf(">", tagStart);

    if (tagStart > 0 || tagEnd === -1) {
      const textNode: TextNode = {
        type: "text",
        content: workingText.slice(0, tagEnd === -1 ? -1 : tagStart).trim(),
      };
      nodes.push(visitor(textNode, () => []));
    }

    // Find end of opening tag
    if (tagEnd === -1) break;

    // Parse tag and attributes
    let tagContent = workingText.slice(tagStart + 1, tagEnd);
    let closed = false;
    if (tagContent.at(-1) === "/") {
      closed = true;
      tagContent = tagContent.slice(0, -1);
    }

    const [name, ...attrParts] = tagContent.split(" ");
    const attributes = parseAttributes(attrParts.join(" ").trim());

    // Skip if it's a closing tag
    if (closed) {
      workingText = workingText.slice(tagEnd + 1).trim();
      nodes.push(
        visitor(
          {
            type: "element",
            name,
            attributes,
            content: "",
            closed,
          },
          () => []
        )
      );
      continue;
    }

    // Find last matching close tag
    const closeTag = `</${name}>`;
    const closePos = workingText.indexOf(closeTag);
    if (closePos === -1) break;

    // Extract content between tags
    const content = workingText.slice(tagEnd + 1, closePos).trim();

    const node: ElementNode = {
      type: "element",
      name,
      attributes,
      content,
    };

    if (parent) node.parent = parent;

    nodes.push(visitor(node, () => parse(content, visitor, depth + 1, node)));
    // Continue with remaining text before this tag
    workingText = workingText.slice(closePos + closeTag.length).trim();
  }
  return nodes;
}

export function isElement(node: Node): node is ElementNode {
  return node.type === "element";
}

export function isText(node: Node): node is TextNode {
  return node.type === "text";
}

type StartTag = {
  type: "start";
  name: string;
  attributes: Record<string, string>;
};

type EndTag = {
  type: "end";
  name: string;
};

type TextContent = {
  type: "text";
  content: string;
};

type SelfClosingTag = {
  type: "self-closing";
  name: string;
  attributes: Record<string, string>;
};

type XMLToken = StartTag | EndTag | TextContent | SelfClosingTag;

const alphaSlashRegex = /[a-zA-Z\/]/;

const wrappers = ["'", "`", "(", ")"];

// todo: maybe only allow new tags in new lines or immediatly after closing one
export function* xmlStreamParser(
  parseTags: Set<string>,
  shouldParse: (tagName: string, isClosingTag: boolean) => boolean
): Generator<XMLToken | void, void, string> {
  let buffer = "";
  let textContent = "";
  let cachedLastContent = "";

  while (true) {
    const chunk = yield;
    if (!chunk) continue;

    buffer += chunk;

    while (buffer.length > 0) {
      const tagStart = buffer.indexOf("<");
      // detect wrapped tags ex:'<tag> and skip it
      if (
        tagStart === 0 &&
        cachedLastContent &&
        wrappers.includes(cachedLastContent.at(-1)!)
      ) {
        textContent += buffer[0];
        buffer = buffer.slice(1);
        continue;
      }

      if (tagStart > 0) {
        if (wrappers.includes(buffer[tagStart - 1])) {
          textContent += buffer.slice(0, tagStart + 1);
          buffer = buffer.slice(tagStart + 1);
        } else {
          textContent += buffer.slice(0, tagStart);
          buffer = buffer.slice(tagStart);
        }

        if (textContent.length > 0) {
          yield { type: "text", content: textContent };
          cachedLastContent = textContent;
          textContent = "";
        }

        continue;
      }

      // todo: regex performance
      if (
        tagStart === -1 ||
        (buffer.length > 1 && !alphaSlashRegex.test(buffer[tagStart + 1]))
      ) {
        textContent += buffer;
        buffer = "";
        break;
      }

      const tagEnd = buffer.indexOf(">", tagStart);
      if (tagEnd === -1) {
        break;
      }

      // wait for more content to detect wrapper
      if (buffer.length === tagEnd) break;

      if (wrappers.includes(buffer[tagEnd + 1])) {
        textContent += buffer.slice(0, tagEnd + 1);
        buffer = buffer.slice(tagEnd + 1);
        if (textContent.length > 0) {
          yield { type: "text", content: textContent };
          cachedLastContent = textContent;
          textContent = "";
        }
        break;
      }

      let tagContent = buffer.slice(tagStart + 1, tagEnd);
      const isClosingTag = tagContent.startsWith("/");
      const tagName = isClosingTag
        ? tagContent.slice(1).trim().split(" ")[0]
        : tagContent.trim().split(" ")[0];

      if (parseTags.has(tagName) && shouldParse(tagName, isClosingTag)) {
        // Emit accumulated text if any
        if (textContent.length > 0) {
          yield { type: "text", content: textContent };
          cachedLastContent = textContent;
          textContent = "";
        }

        if (isClosingTag) {
          yield { type: "end", name: tagName };
        } else {
          const attributes = parseAttributes(tagContent.slice(tagName.length));

          if (tagContent.endsWith("/")) {
            yield { type: "self-closing", name: tagName, attributes };
          } else {
            yield { type: "start", name: tagName, attributes };
          }
        }
      } else {
        // Not a tag we care about, treat as text
        textContent += buffer.slice(0, tagEnd + 1);
      }

      buffer = buffer.slice(tagEnd + 1);
    }

    if (textContent.length > 0) {
      yield { type: "text", content: textContent };
      cachedLastContent = textContent;
      textContent = "";
    }
  }
}

--- End File: packages/core/src/xml.ts ---

--- File: packages/create-agent/README.md ---
# @daydreamsai/create-agent

A CLI tool to bootstrap Daydreams agents easily.

## Usage

```bash
# Using npx (recommended)
npx @daydreamsai/create-agent my-agent

# Or install globally
npm install -g @daydreamsai/create-agent
create-agent my-agent
```

## Options

You can specify extensions to include:

```bash
npx @daydreamsai/create-agent my-agent --twitter --discord --cli
```

Available extensions:

- `--cli`: Include CLI extension
- `--twitter`: Include Twitter extension
- `--discord`: Include Discord extension
- `--telegram`: Include Telegram extension
- `--all`: Include all extensions

If no extensions are specified, you will be prompted to select which ones to
include.

## What it does

This tool:

1. Creates a new directory for your agent (or uses the current directory)
2. Sets up a package.json with the necessary dependencies
3. Creates an index.js file with the selected extensions
4. Generates a basic .env.example file with required environment variables
5. Installs all dependencies

## Development

```bash
# Install dependencies
pnpm install

# Build the package
pnpm run build

# Test the CLI locally
pnpm run start
```

## Testing

The create-agent CLI is tested using Vitest. To run tests:

```bash
# Run all tests
pnpm run test

# Run tests in watch mode during development
pnpm run test:watch

# Run tests with coverage report
pnpm run test:coverage
```

### Test Structure

- `test/index.test.ts`: Main CLI integration tests
- `test/utils/utils.test.ts`: Unit tests for utility functions
- `test/template-generation.test.ts`: Tests for template generation
  functionality

### Adding New Tests

When adding new features to the CLI, make sure to:

1. Extract pure functions to the `src/utils.ts` file where possible
2. Add unit tests for those functions in `test/utils/utils.test.ts`
3. Add integration tests for CLI behavior in `test/index.test.ts`

--- End File: packages/create-agent/README.md ---

--- File: packages/create-agent/package.json ---
{
  "name": "@daydreamsai/create-agent",
  "version": "0.3.5",
  "description": "CLI to bootstrap Daydreams agents",
  "license": "MIT",
  "type": "module",
  "exports": {
    ".": "./dist/index.js"
  },
  "bin": {
    "create-agent": "./dist/index.js"
  },
  "files": [
    "dist",
    "templates"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "typecheck": "tsc --noEmit",
    "start": "node dist/index.js test-agent",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "chalk": "^5.3.0",
    "commander": "^12.0.0",
    "execa": "^8.0.1",
    "fs-extra": "^11.2.0",
    "ora": "^8.0.1",
    "prompts": "^2.4.2"
  },
  "devDependencies": {
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^20.11.16",
    "@types/prompts": "^2.4.9",
    "@vitest/coverage-v8": "^1.4.0",
    "memfs": "^4.9.0",
    "mock-stdin": "^1.0.0",
    "strip-ansi": "^7.1.0",
    "tsup": "^8.0.1",
    "typescript": "^5.3.3",
    "vitest": "^1.4.0",
    "vitest-mock-process": "^1.0.0"
  }
}

--- End File: packages/create-agent/package.json ---

--- File: packages/create-agent/src/index.ts ---
import path from "path";
import fs from "fs-extra";
import { Command } from "commander";
import chalk from "chalk";
import ora from "ora";
import { execa } from "execa";
import prompts from "prompts";
import { fileURLToPath } from "url";
import {
  generateTemplateContent,
  createEnvVariables,
  createReadme,
} from "./utils.js";

// Define __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define the CLI program
const program = new Command()
  .name("create-agent")
  .description("Bootstrap a new Daydreams agent")
  .version("0.1.0")
  .argument("[directory]", "Directory to create the agent in")
  .option("--twitter", "Include Twitter extension")
  .option("--discord", "Include Discord extension")
  .option("--cli", "Include CLI extension")
  .option("--telegram", "Include Telegram extension")
  .option("--all", "Include all extensions")
  .option(
    "--model <model>",
    "Specify the model to use (openai, groq, anthropic, google)",
    "groq"
  );

// Export the main function for testing purposes
export async function main(
  testArgs?: string[],
  testOpts?: Record<string, any>,
  testTemplateContent?: string // Add template content parameter for testing
) {
  // Parse arguments and options only if not in test mode
  if (!testArgs && !testOpts) {
    program.parse(process.argv);
  }

  const options = testOpts || program.opts();
  const targetDir = (testArgs && testArgs[0]) || program.args[0] || ".";
  const cwd = process.cwd();
  const targetPath = path.resolve(cwd, targetDir);

  // Check if target directory exists and is not empty
  if (fs.existsSync(targetPath)) {
    const files = await fs.readdir(targetPath);
    if (files.length > 0) {
      const { proceed } = await prompts({
        type: "confirm",
        name: "proceed",
        message: `Directory ${chalk.cyan(targetPath)} is not empty. Continue?`,
        initial: false,
      });

      if (!proceed) {
        console.log(chalk.red("Aborted."));
        return;
      }
    }
  } else {
    await fs.mkdir(targetPath, { recursive: true });
  }

  console.log();
  console.log(chalk.bold("Creating a new Daydreams agent..."));
  console.log();

  // Determine selected extensions
  const availableExtensions = ["cli", "twitter", "discord", "telegram"];
  let selectedExtensions = [];

  if (options.all) {
    selectedExtensions = [...availableExtensions];
  } else {
    // Collect extensions from command line options
    selectedExtensions = availableExtensions.filter((ext) => options[ext]);

    // If no extensions were selected via flags, prompt the user
    if (selectedExtensions.length === 0) {
      const { extensions } = await prompts({
        type: "multiselect",
        name: "extensions",
        message: "Select extensions to include",
        choices: [
          { title: "CLI", value: "cli" },
          { title: "Twitter", value: "twitter" },
          { title: "Discord", value: "discord" },
          { title: "Telegram", value: "telegram" },
        ],
      });

      if (!extensions || extensions.length === 0) {
        console.log(
          chalk.yellow(
            "No extensions selected. Including CLI extension by default."
          )
        );
        selectedExtensions = ["cli"];
      } else {
        selectedExtensions = extensions;
      }
    }
  }

  // Determine the model to use
  const validModels = ["openai", "groq", "anthropic", "google"];
  let selectedModel = options.model || "groq";

  if (!validModels.includes(selectedModel)) {
    const { model } = await prompts({
      type: "select",
      name: "model",
      message: "Select the model provider to use",
      choices: [
        { title: "Groq", value: "groq" },
        { title: "OpenAI", value: "openai" },
        { title: "Anthropic", value: "anthropic" },
        { title: "Google", value: "google" },
      ],
      initial: 0,
    });
    selectedModel = model;
  }

  // Create package.json
  const spinner = ora("Creating package.json").start();
  const packageJson: {
    name: string;
    version: string;
    type: string;
    scripts: Record<string, string>;
    dependencies: Record<string, string>;
  } = {
    name: path.basename(targetPath),
    version: "0.1.0",
    type: "module",
    scripts: {
      start: "bun run index.ts",
      build: "tsc",
    },
    dependencies: {
      "@daydreamsai/core": "^0.2.13",
      "@ai-sdk/anthropic": "^1.1.6",
      "@ai-sdk/google": "^1.1.16",
      "@ai-sdk/groq": "^1.1.7",
      "@ai-sdk/openai": "^1.1.14",
      "@openrouter/ai-sdk-provider": "^0.2.1",
      ai: "^4.1.25",
      chalk: "^5.4.1",
      "discord.js": "^14.17.3",
      telegraf: "^4.16.3",
      typescript: "^5.3.3",
      zod: "^3.24.1",
    },
  };

  // Add extension-specific dependencies
  if (selectedExtensions.includes("discord")) {
    packageJson.dependencies["discord.js"] = "^14.14.1";
  }

  await fs.writeFile(
    path.join(targetPath, "package.json"),
    JSON.stringify(packageJson, null, 2)
  );
  spinner.succeed("Created package.json");

  // Create tsconfig.json
  spinner.start("Creating tsconfig.json");
  const tsconfigJson = {
    compilerOptions: {
      target: "ES2020",
      module: "NodeNext",
      moduleResolution: "NodeNext",
      esModuleInterop: true,
      strict: true,
      skipLibCheck: true,
      outDir: "dist",
    },
    include: ["*.ts"],
    exclude: ["node_modules"],
  };

  await fs.writeFile(
    path.join(targetPath, "tsconfig.json"),
    JSON.stringify(tsconfigJson, null, 2)
  );
  spinner.succeed("Created tsconfig.json");

  // Copy template file based on selected model
  spinner.start(
    `Creating agent with ${selectedModel} model and selected extensions`
  );

  // Read template content - either from test parameter or from file
  let templateContent: string;

  if (testTemplateContent) {
    // Use the provided test template content
    templateContent = testTemplateContent;
  } else {
    // Get the template file path
    const templateFile = path.join(
      __dirname,
      "..",
      "templates",
      "basic",
      "template.ts"
    );

    if (!fs.existsSync(templateFile)) {
      spinner.fail(`Template file not found: ${templateFile}`);
      console.error(
        chalk.red(
          `Error: Template file not found. Please check your installation.`
        )
      );
      return;
    }

    // Read the template file
    templateContent = await fs.readFile(templateFile, "utf-8");
  }

  // Define model-specific replacements
  const modelConfig = {
    groq: {
      MODEL_NAME: "Groq",
      MODEL_IMPORT_FUNCTION: "createGroq",
      MODEL_IMPORT_PATH: "@ai-sdk/groq",
      ENV_VAR_KEY: "GROQ_API_KEY",
      MODEL_VARIABLE: "groq",
      MODEL_VERSION: "deepseek-r1-distill-llama-70b",
    },
    openai: {
      MODEL_NAME: "OpenAI",
      MODEL_IMPORT_FUNCTION: "createOpenAI",
      MODEL_IMPORT_PATH: "@ai-sdk/openai",
      ENV_VAR_KEY: "OPENAI_API_KEY",
      MODEL_VARIABLE: "openai",
      MODEL_VERSION: "gpt-4o",
    },
    anthropic: {
      MODEL_NAME: "Anthropic",
      MODEL_IMPORT_FUNCTION: "createAnthropic",
      MODEL_IMPORT_PATH: "@ai-sdk/anthropic",
      ENV_VAR_KEY: "ANTHROPIC_API_KEY",
      MODEL_VARIABLE: "anthropic",
      MODEL_VERSION: "claude-3-opus-20240229",
    },
    google: {
      MODEL_NAME: "Google",
      MODEL_IMPORT_FUNCTION: "createGoogle",
      MODEL_IMPORT_PATH: "@ai-sdk/google",
      ENV_VAR_KEY: "GOOGLE_API_KEY",
      MODEL_VARIABLE: "google",
      MODEL_VERSION: "gemini-1.5-pro",
    },
  };

  // Replace placeholders with model-specific values
  const config = modelConfig[selectedModel as keyof typeof modelConfig];

  // Prepare extension imports and extension list for template generation
  const extensionImports: string[] = [];
  const extensionsList: string[] = [];

  for (const ext of selectedExtensions) {
    if (ext === "cli") {
      extensionImports.push(
        `import { cli } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("cli");
    } else if (ext === "twitter") {
      extensionImports.push(
        `import { twitter } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("twitter");
    } else if (ext === "discord") {
      extensionImports.push(
        `import { discord } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("discord");
    } else if (ext === "telegram") {
      extensionImports.push(
        `import { telegram } from "@daydreamsai/core/extensions";`
      );
      extensionsList.push("telegram");
    }
  }

  // Generate the template content with all replacements
  const processedContent = generateTemplateContent(
    templateContent,
    config,
    extensionImports,
    extensionsList
  );

  // Write the modified template to the target directory
  await fs.writeFile(path.join(targetPath, "index.ts"), processedContent);
  spinner.succeed(
    `Created agent with ${selectedModel} model and extensions: ${selectedExtensions.join(", ")}`
  );

  // Create .env file with required environment variables
  spinner.start("Creating .env file");
  const envContent = createEnvVariables(selectedModel, selectedExtensions);
  await fs.writeFile(path.join(targetPath, ".env.example"), envContent);
  spinner.succeed("Created .env.example file");

  // Create README
  spinner.start("Creating README");
  const readmeContent = createReadme(
    path.basename(targetPath),
    selectedExtensions,
    selectedModel
  );
  await fs.writeFile(path.join(targetPath, "README.md"), readmeContent);
  spinner.succeed("Created README");

  // Install dependencies - simplified to directly use pnpm
  spinner.start("Installing dependencies with pnpm");
  try {
    await execa("pnpm", ["install"], { cwd: targetPath });

    // Verify node_modules exists
    const nodeModulesPath = path.join(targetPath, "node_modules");
    const nodeModulesExists = await fs.pathExists(nodeModulesPath);

    if (nodeModulesExists) {
      spinner.succeed("Installed dependencies using pnpm");
    } else {
      spinner.fail(
        "Dependencies installed but node_modules directory wasn't found"
      );
      console.log(
        chalk.yellow(
          "You can install dependencies manually by running 'pnpm install' in the project directory."
        )
      );
    }
  } catch (error: unknown) {
    spinner.fail("Failed to install dependencies");
    console.error(
      chalk.red(
        `Error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
    console.log(
      chalk.yellow(
        "You can install dependencies manually by running 'pnpm install' in the project directory."
      )
    );
  }

  console.log();
  console.log(
    chalk.green("✅ Your Daydreams agent has been created successfully!")
  );
  console.log();
  console.log(`To get started, run the following commands:`);

  if (targetDir !== ".") {
    console.log(`  cd ${targetDir}`);
  }

  console.log(`  cp .env.example .env`);
  console.log(`  # Fill in the required environment variables in .env`);
  console.log(`  npm start`);
  console.log();
}

// Directly run the main function when this file is executed directly
if (
  import.meta.url &&
  process.argv[1] &&
  (import.meta.url.endsWith(process.argv[1]) ||
    process.argv[1].endsWith("index.js") ||
    process.argv[1].endsWith("create-agent"))
) {
  main().catch((error) => {
    console.error(
      chalk.red(
        `Error: ${error instanceof Error ? error.message : String(error)}`
      )
    );
    process.exit(1);
  });
}

--- End File: packages/create-agent/src/index.ts ---

--- File: packages/create-agent/src/utils.ts ---
import { execa } from "execa";
import fs from "fs-extra";
import path from "path";
import chalk from "chalk";

/**
 * Generates the content for an agent template by replacing placeholders
 * @param templateContent The original template content with placeholders
 * @param modelConfig The model-specific configuration values
 * @param extensionImports Array of extension import statements
 * @param extensionsList Array of extension variable names
 * @returns The processed template content
 */
export function generateTemplateContent(
  templateContent: string,
  modelConfig: Record<string, string>,
  extensionImports: string[] = [],
  extensionsList: string[] = []
): string {
  // Replace model-specific placeholders
  let processedContent = templateContent;

  // Replace placeholders with model-specific values
  Object.entries(modelConfig).forEach(([key, value]) => {
    const placeholder = new RegExp(`{{${key}}}`, "g");
    processedContent = processedContent.replace(placeholder, value);
  });

  // Replace extension imports if specified
  if (extensionImports.length > 0) {
    processedContent = processedContent.replace(
      `import { cli } from "@daydreamsai/core/extensions";`,
      extensionImports.join("\n")
    );
  }

  // Replace extensions list in createDreams if specified
  if (extensionsList.length > 0) {
    processedContent = processedContent.replace(
      "extensions: [cli]",
      `extensions: [${extensionsList.join(", ")}]`
    );
  }

  // Add header comment
  const headerComment = `/**
 * Daydreams agent with ${extensionsList.join(", ")} extension(s)
 * Using ${modelConfig.MODEL_NAME} as the model provider
 */`;

  processedContent = processedContent.replace(
    /\/\*\*[\s\S]*?\*\//,
    headerComment
  );

  return processedContent;
}

/**
 * Creates environment variables content for the .env.example file
 * @param selectedModel The selected model provider
 * @param selectedExtensions Array of selected extensions
 * @returns The content for the .env.example file
 */
export function createEnvVariables(
  selectedModel: string,
  selectedExtensions: string[]
): string {
  const envVariables = ["# Daydreams Environment Variables\n"];

  // Model configurations
  envVariables.push("# Model Configurations");
  if (selectedModel === "groq") {
    envVariables.push("GROQ_API_KEY=your_groq_api_key");
  } else if (selectedModel === "openai") {
    envVariables.push("OPENAI_API_KEY=your_openai_api_key");
  } else if (selectedModel === "anthropic") {
    envVariables.push("ANTHROPIC_API_KEY=your_anthropic_api_key");
  } else if (selectedModel === "google") {
    envVariables.push("GOOGLE_API_KEY=your_google_api_key");
  }

  // Add OpenRouter API key regardless of selected model
  envVariables.push("OPENROUTER_API_KEY=your_openrouter_api_key\n");

  // Twitter Configuration
  if (selectedExtensions.includes("twitter")) {
    envVariables.push("# Twitter Configuration");
    // Add both authentication methods
    envVariables.push("# Method 1: Username/Password");
    envVariables.push("TWITTER_USERNAME=your_twitter_username");
    envVariables.push("TWITTER_PASSWORD=your_twitter_password");
    envVariables.push("TWITTER_EMAIL=your_twitter_email");

    envVariables.push("# Method 2: API Keys");
    envVariables.push("TWITTER_CONSUMER_KEY=your_consumer_key");
    envVariables.push("TWITTER_CONSUMER_SECRET=your_consumer_secret");
    envVariables.push("TWITTER_ACCESS_TOKEN=your_access_token");
    envVariables.push("TWITTER_ACCESS_TOKEN_SECRET=your_access_token_secret\n");
  }

  // Discord Configuration
  if (selectedExtensions.includes("discord")) {
    envVariables.push("# Discord Configuration");
    envVariables.push(
      "# Discord Bot Token (https://discord.com/developers/applications)"
    );
    envVariables.push(
      "# Required Gateway Intents: Server Members, Message Content, Presence"
    );
    envVariables.push("DISCORD_TOKEN=your_discord_token");
    envVariables.push("DISCORD_BOT_NAME=your_bot_name\n");
  }

  // Telegram Configuration
  if (selectedExtensions.includes("telegram")) {
    envVariables.push("# Telegram Configuration");
    envVariables.push(
      "# TELEGRAM_STARTUP_CHAT_ID: Chat ID where startup notifications will be sent"
    );
    envVariables.push("TELEGRAM_STARTUP_CHAT_ID=your_startup_chat_id");

    envVariables.push(
      "# GramJS Configuration (required for both bot and user clients)"
    );
    envVariables.push(
      "# TELEGRAM_TOKEN: Bot token from @BotFather (required for bot mode)"
    );
    envVariables.push("TELEGRAM_TOKEN=your_telegram_token");

    envVariables.push("# Get these from https://my.telegram.org/apps");
    envVariables.push("TELEGRAM_API_ID=your_api_id");
    envVariables.push("TELEGRAM_API_HASH=your_api_hash");

    envVariables.push("# Optional: Session string for user authentication");
    envVariables.push(
      "# After first successful interactive login, the app will provide a session string"
    );
    envVariables.push(
      "# Save it here to avoid interactive login in subsequent runs"
    );
    envVariables.push("TELEGRAM_USER_SESSION=your_session_string\n");
  }

  // Add common configurations regardless of extensions
  envVariables.push("# General Configuration");
  envVariables.push("DRY_RUN=1");
  envVariables.push(
    "GRAPHQL_URL=https://api.cartridge.gg/x/sepolia-rc-18/torii\n"
  );

  // Add blockchain configurations
  envVariables.push("# Blockchain Configurations");

  envVariables.push("# Starknet Configuration");
  envVariables.push("STARKNET_RPC_URL=your_starknet_rpc_url");
  envVariables.push("STARKNET_ADDRESS=your_starknet_address");
  envVariables.push("STARKNET_PRIVATE_KEY=your_starknet_private_key\n");

  envVariables.push("# Hyperliquid Trading Configuration");
  envVariables.push(
    "# HYPERLIQUID_MAIN_ADDRESS: Your main Hyperliquid address (format: 0x...)"
  );
  envVariables.push(
    "# HYPERLIQUID_WALLET_ADDRESS: Your wallet address for trading (format: 0x...)"
  );
  envVariables.push(
    "# HYPERLIQUID_PRIVATE_KEY: Your private key (Keep this secure!)"
  );
  envVariables.push("HYPERLIQUID_MAIN_ADDRESS=your_main_address");
  envVariables.push("HYPERLIQUID_WALLET_ADDRESS=your_wallet_address");
  envVariables.push("HYPERLIQUID_PRIVATE_KEY=your_private_key\n");

  envVariables.push("# Sui Configuration");
  envVariables.push(
    "# Sui Mnemonic Seed Phrase (`sui keytool generate ed25519`), Also support `suiprivatekeyxxxx` (sui keytool export --key-identity 0x63)"
  );
  envVariables.push("SUI_PRIVATE_KEY=your_sui_private_key");
  envVariables.push(
    "SUI_NETWORK=mainnet   # must be one of mainnet, testnet, devnet, localnet\n"
  );

  return envVariables.join("\n");
}

/**
 * Creates a README file content for the agent
 * @param projectName The name of the project
 * @param selectedExtensions Array of selected extensions
 * @param selectedModel The selected model provider
 * @returns The content for the README.md file
 */
export function createReadme(
  projectName: string,
  selectedExtensions: string[],
  selectedModel: string
): string {
  return `# ${projectName}

A Daydreams agent with the following extensions:
${selectedExtensions.map((ext) => `- ${ext}`).join("\n")}

## Features

- Uses ${selectedModel} as the model provider
- Includes context for managing goals and tasks
- Provides actions for adding and completing tasks

## Getting Started

1. Copy \`.env.example\` to \`.env\` and fill in the required values.
2. Install dependencies:

\`\`\`
bun install
\`\`\`

3. Run the agent:

\`\`\`
bun start
\`\`\`

## Customizing Your Agent

You can modify the \`index.ts\` file to add more contexts, actions, or change the model configuration.
`;
}

--- End File: packages/create-agent/src/utils.ts ---

--- File: packages/create-agent/templates/basic/template.ts ---
/**
 * {{MODEL_NAME}} template for a Daydreams agent
 * This template includes context for goals and tasks, and actions for managing them
 */
import { {{MODEL_IMPORT_FUNCTION}} } from "{{MODEL_IMPORT_PATH}}";
import {
    createDreams,
    context,
    render,
    action,
    validateEnv,
} from "@daydreamsai/core";
import { cli } from "@daydreamsai/core/extensions";
import { string, z } from "zod";

const env = validateEnv(
    z.object({
        {{ENV_VAR_KEY}}: z.string().min(1, "{{ENV_VAR_KEY}} is required"),
    })
);

// Initialize {{MODEL_NAME}} client
const {{MODEL_VARIABLE}} = {{MODEL_IMPORT_FUNCTION}}({
    apiKey: env.{{ENV_VAR_KEY}}!,
});

const template = `
Goal: {{goal}} 
Tasks: {{tasks}}
Current Task: {{currentTask}}
`;

type GoalMemory = {
    goal: string;
    tasks: string[];
    currentTask: string;
};

const goalContexts = context({
    type: "goal",
    schema: z.object({
        id: string(),
        initialGoal: z.string(),
        initialTasks: z.array(z.string()),
    }),

    key({ id }: { id: string }) {
        return id;
    },

    create(state: { args: { initialGoal: string; initialTasks: string[] } }) {
        return {
            goal: state.args.initialGoal,
            tasks: state.args.initialTasks ?? [],
            currentTask: state.args.initialTasks?.[0],
        };
    },

    render({ memory }: { memory: GoalMemory }) {
        return render(template, {
            goal: memory.goal,
            tasks: memory.tasks.join("\n"),
            currentTask: memory.currentTask ?? "NONE",
        });
    },
});

createDreams({
    model: {{MODEL_VARIABLE}}("{{MODEL_VERSION}}"),
    extensions: [cli],
    context: goalContexts,
    actions: [
        action({
            name: "addTask",
            description: "Add a task to the goal",
            schema: z.object({ task: z.string() }),
            handler(
                call: { data: { task: string } },
                ctx: { agentMemory: any },
                _agent: any
            ) {
                const agentMemory = ctx.agentMemory as GoalMemory;
                agentMemory.tasks.push(call.data.task);
                return {};
            },
        }),
        action({
            name: "completeTask",
            description: "Complete a task",
            schema: z.object({ task: z.string() }),
            handler(
                call: { data: { task: string } },
                ctx: { agentMemory: any },
                _agent: any
            ) {
                const agentMemory = ctx.agentMemory as GoalMemory;
                agentMemory.tasks = agentMemory.tasks.filter(
                    (task) => task !== call.data.task
                );
                return {};
            },
        }),
    ],
}).start({ id: "test", initialGoal: "", initialTasks: [] });

--- End File: packages/create-agent/templates/basic/template.ts ---

--- File: packages/create-agent/vitest.config.ts ---
import { defineConfig } from "vitest/config";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export default defineConfig({
  test: {
    environment: "node",
    include: ["test/**/*.test.ts"],
    exclude: ["**/node_modules/**", "**/dist/**"],
    globals: true,
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: ["node_modules/", "test/"],
    },
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});

--- End File: packages/create-agent/vitest.config.ts ---

--- File: packages/defai/package.json ---
{
  "name": "@daydreamsai/defai",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.8.2"
  },
  "dependencies": {
    "@cetusprotocol/aggregator-sdk": "^0.3.32",
    "@daydreamsai/core": "workspace:*",
    "@mysten/sui": "1.7.0",
    "@solana/web3.js": "^1.98.0",
    "bignumber.js": "^9.1.2",
    "bs58": "^6.0.0",
    "discord.js": "^14.18.0",
    "ethers": "^6.13.5",
    "starknet": "^6.24.1",
    "zod": "^3.24.2"
  }
}

--- End File: packages/defai/package.json ---

--- File: packages/defai/src/evm.ts ---
import { ethers } from "ethers";
import type { IChain } from "@daydreamsai/core";

/**
 * Configuration options for initializing an EVM chain connection
 */
export interface EvmChainConfig {
  /**
   * A name or descriptive label for this EVM chain (e.g. "ethereum", "polygon", "bsc", etc.)
   */
  chainName: string;

  /**
   * The RPC endpoint URL (e.g., Infura, Alchemy, local node, etc.)
   */
  rpcUrl: string;

  /**
   * A private key for signing transactions. In production, manage keys securely!
   */
  privateKey: string;

  /**
   * (Optional) Chain ID (e.g. 1 for mainnet, 5 for Goerli). Not strictly required,
   * but can help with certain ethers.js checks.
   */
  chainId?: number;
}

/**
 * Implementation of the IChain interface for Ethereum Virtual Machine (EVM) compatible chains.
 * Provides methods for reading from and writing to EVM-based blockchains.
 *
 * @example
 * ```typescript
 * const evmChain = new EvmChain({
 *   chainName: "ethereum",
 *   rpcUrl: process.env.ETH_RPC_URL,
 *   privateKey: process.env.ETH_PRIVATE_KEY,
 *   chainId: 1
 * });
 * ```
 */
export class EvmChain implements IChain {
  /**
   * Unique identifier for this chain implementation.
   * Matches the IChain interface.
   * This could be "ethereum", "polygon", etc.
   */
  public chainId: string;

  /**
   * JSON-RPC provider instance for connecting to the blockchain
   */
  private provider: ethers.JsonRpcProvider;

  /**
   * Wallet instance for signing transactions
   */
  private signer: ethers.Wallet;

  /**
   * Creates a new EVM chain instance
   * @param config - Configuration options for the chain connection
   */
  constructor(private config: EvmChainConfig) {
    this.chainId = config.chainName;
    // 1) Create a provider for this chain
    this.provider = new ethers.JsonRpcProvider(config.rpcUrl, {
      chainId: config.chainId,
      name: config.chainName,
    });

    // 2) Create a signer from the private key
    this.signer = new ethers.Wallet(config.privateKey, this.provider);
  }

  /**
   * Performs a read operation on the blockchain, typically calling a view/pure contract function
   * that doesn't modify state.
   *
   * @param call - The call parameters
   * @param call.contractAddress - Address of the contract to call
   * @param call.abi - Contract ABI (interface)
   * @param call.functionName - Name of the function to call
   * @param call.args - Arguments to pass to the function
   * @returns The result of the contract call
   * @throws Error if the call fails
   */
  public async read(call: unknown): Promise<any> {
    try {
      // In a real implementation, you might use a Zod schema or TS check here:
      const {
        contractAddress,
        abi,
        functionName,
        args = [],
      } = call as {
        contractAddress: string;
        abi: any;
        functionName: string;
        args?: any[];
      };

      // 1) Create a contract object with the provider
      const contract = new ethers.Contract(contractAddress, abi, this.provider);

      // 2) Call the function
      return await contract[functionName](...args);
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred in read()");
    }
  }

  /**
   * Performs a write operation on the blockchain by sending a transaction that modifies state.
   * Examples include transferring tokens or updating contract storage.
   *
   * @param call - The transaction parameters
   * @param call.contractAddress - Address of the contract to interact with
   * @param call.abi - Contract ABI (interface)
   * @param call.functionName - Name of the function to call
   * @param call.args - Arguments to pass to the function
   * @param call.overrides - Optional transaction overrides (gas limit, gas price, etc)
   * @returns The transaction receipt after confirmation
   * @throws Error if the transaction fails
   */
  public async write(call: unknown): Promise<any> {
    try {
      const {
        contractAddress,
        abi,
        functionName,
        args = [],
        overrides = {},
      } = call as {
        contractAddress: string;
        abi: any;
        functionName: string;
        args?: any[];
        overrides?: ethers.Overrides;
      };

      // 1) Create a contract object connected to the signer
      const contract = new ethers.Contract(contractAddress, abi, this.signer);

      // 2) Send the transaction
      const tx = await contract[functionName](...args, overrides);

      // 3) Optionally wait for it to confirm
      const receipt = await tx.wait();
      return receipt; // or return { tx, receipt } if you want both
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred in write()");
    }
  }
}

--- End File: packages/defai/src/evm.ts ---

--- File: packages/defai/src/index.ts ---
export * from "./starknet";
export * from "./solana";
export * from "./evm";
export * from "./sui";

--- End File: packages/defai/src/index.ts ---

--- File: packages/defai/src/solana.ts ---
import {
  Connection,
  Keypair,
  PublicKey,
  Transaction,
  sendAndConfirmTransaction,
} from "@solana/web3.js";
import type { IChain } from "@daydreamsai/core";
import bs58 from "bs58";

export interface SolanaChainConfig {
  /**
   * A descriptive chain name or environment (e.g., "solana-mainnet", "solana-devnet").
   */
  chainName: string;

  /**
   * RPC endpoint for Solana (e.g. https://api.devnet.solana.com).
   */
  rpcUrl: string;

  /**
   * Base-58 encoded private key or some format from which you can construct a Keypair.
   * In a real scenario, handle keys more securely (e.g., using a keystore or external vault).
   */
  privateKey: string;
}

export class SolanaChain implements IChain {
  public chainId: string; // e.g. "solana-mainnet" or "solana-devnet"
  private connection: Connection;
  private keypair: Keypair;

  constructor(private config: SolanaChainConfig) {
    this.chainId = config.chainName;

    // 1) Create a Connection to the Solana cluster
    this.connection = new Connection(config.rpcUrl);

    // 2) Create a Keypair from the private key
    //    - We assume it's a base-58 encoded private key (64- or 32-byte).
    //    - Another approach is if config.privateKey is a JSON array of 64 ints, etc.
    this.keypair = this.createKeypairFromBase58(config.privateKey);
  }

  /**
   * Example "read" method. Because Solana doesn't have a direct "contract read" by default,
   * we might interpret read calls as:
   *  - "getAccountInfo" or
   *  - "getBalance", or
   *  - "getProgramAccounts"
   *
   * So let's define a simple structure we can parse to do the relevant read.
   *
   * read({ type: "getBalance", address: "..." })
   * read({ type: "getAccountInfo", address: "..." })
   */
  public async read(call: unknown): Promise<any> {
    try {
      const { type, address } = call as {
        type: string;
        address: string;
      };

      switch (type) {
        case "getBalance": {
          const pubKey = new PublicKey(address);
          const lamports = await this.connection.getBalance(pubKey);
          return lamports; // in lamports
        }
        case "getAccountInfo": {
          const pubKey = new PublicKey(address);
          const accountInfo = await this.connection.getAccountInfo(pubKey);
          return accountInfo; // can be null if not found
        }
        case "getBlockHeight": {
          const blockHeight = await this.connection.getBlockHeight();
          return blockHeight;
        }
        // Extend with more read patterns as needed
        default:
          throw new Error(`Unknown read type: ${type}`);
      }
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred in Solana read()");
    }
  }

  /**
   * Example "write" method. We'll treat this as "send a Solana transaction."
   * A typical transaction might have multiple instructions.
   *
   * We'll define a structure for the `call` param:
   * {
   *   instructions: TransactionInstruction[];
   *   signers?: Keypair[];
   * }
   * where "instructions" is an array of instructions you want to execute.
   *
   * The agent or caller is responsible for constructing those instructions (e.g. for
   * token transfers or program interactions).
   */
  public async write(call: unknown): Promise<any> {
    try {
      const { instructions, signers = [] } = call as {
        instructions: any[]; // or TransactionInstruction[]
        signers: Keypair[];
      };

      // 1) Build a Transaction object
      const transaction = new Transaction().add(...instructions);

      // 2) We'll sign with the primary keypair + any additional signers
      // Typically, the main Keypair is the fee payer
      transaction.feePayer = this.keypair.publicKey;

      // 3) Send and confirm the transaction
      const txSig = await sendAndConfirmTransaction(
        this.connection,
        transaction,
        [this.keypair, ...signers]
      );

      return txSig; // transaction signature
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error in Solana write()");
    }
  }

  /**
   * Helper method: Convert a base-58 string private key into a Keypair.
   * Implementation depends on how your private key is stored.
   */
  private createKeypairFromBase58(secretBase58: string): Keypair {
    const secretKeyBytes = Buffer.from(bs58.decode(secretBase58));
    // For Solana, a 64-byte secret is typical.
    // Another approach is if you have a 32-byte seed, etc.
    return Keypair.fromSecretKey(secretKeyBytes);
  }
}

--- End File: packages/defai/src/solana.ts ---

--- File: packages/defai/src/starknet.ts ---
import { RpcProvider, Account, type Call, CallData } from "starknet";
import type { IChain } from "@daydreamsai/core";

/**
 * Configuration options for initializing a Starknet chain connection
 */
export interface StarknetChainConfig {
  /** The RPC endpoint URL for connecting to Starknet */
  rpcUrl: string;
  /** The Starknet account contract address */
  address: string;
  /** Private key for signing transactions. Should be managed securely! */
  privateKey: string;
}

/**
 * Implementation of the IChain interface for interacting with the Starknet L2 blockchain
 *
 * @example
 * ```ts
 * const starknet = new StarknetChain({
 *   rpcUrl: process.env.STARKNET_RPC_URL,
 *   address: process.env.STARKNET_ADDRESS,
 *   privateKey: process.env.STARKNET_PRIVATE_KEY
 * });
 * ```
 */
export class StarknetChain implements IChain {
  /** Unique identifier for this chain implementation */
  public chainId = "starknet";
  /** RPC provider instance for connecting to Starknet */
  private provider: RpcProvider;
  /** Account instance for transaction signing */
  private account: Account;

  /**
   * Creates a new StarknetChain instance
   * @param config - Configuration options for the Starknet connection
   */
  constructor(config: StarknetChainConfig) {
    this.provider = new RpcProvider({ nodeUrl: config.rpcUrl });
    this.account = new Account(
      this.provider,
      config.address,
      config.privateKey
    );
  }

  /**
   * Performs a read-only call to a Starknet contract
   * @param call - The contract call parameters
   * @returns The result of the contract call
   * @throws Error if the call fails
   */
  public async read(call: Call): Promise<any> {
    try {
      call.calldata = CallData.compile(call.calldata || []);
      return this.provider.callContract(call);
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred");
    }
  }

  /**
   * Executes a state-changing transaction on Starknet
   * @param call - The transaction parameters
   * @returns The transaction receipt after confirmation
   * @throws Error if the transaction fails
   */
  public async write(call: Call): Promise<any> {
    try {
      call.calldata = CallData.compile(call.calldata || []);
      const { transaction_hash } = await this.account.execute(call);
      return this.account.waitForTransaction(transaction_hash, {
        retryInterval: 1000,
      });
    } catch (error) {
      return error instanceof Error
        ? error
        : new Error("Unknown error occurred");
    }
  }
}

--- End File: packages/defai/src/starknet.ts ---

--- File: packages/defai/src/sui.ts ---
import {
  getFullnodeUrl,
  SuiClient,
  type SuiTransactionBlockResponse,
} from "@mysten/sui/client";
import { getFaucetHost, requestSuiFromFaucetV0 } from "@mysten/sui/faucet";
import type { Signer } from "@mysten/sui/cryptography";
import { Ed25519Keypair } from "@mysten/sui/keypairs/ed25519";
import { Secp256k1Keypair } from "@mysten/sui/keypairs/secp256k1";
import { Secp256r1Keypair } from "@mysten/sui/keypairs/secp256r1";
import {
  Transaction,
  type TransactionObjectArgument,
} from "@mysten/sui/transactions";
import { SUI_DECIMALS } from "@mysten/sui/utils";
import { AggregatorClient, Env } from "@cetusprotocol/aggregator-sdk";
import BN from "bignumber.js";
import type { IChain } from "@daydreamsai/core";

interface SwapResult {
  success: boolean;
  tx: string;
  message: string;
}

interface TokenMetadata {
  symbol: string;
  decimals: number;
  tokenAddress: string;
}

const parseAccount = (privateKey: string): Signer => {
  if (privateKey.startsWith("suiprivkey")) {
    return loadFromSecretKey(privateKey);
  }
  return loadFromMnemonics(privateKey);
};
const loadFromSecretKey = (privateKey: string) => {
  // Remove the "suiprivkey" prefix if present
  const cleanedKey = privateKey.startsWith("suiprivkey")
    ? privateKey.substring("suiprivkey".length)
    : privateKey;

  // Convert the string to Uint8Array as required by the keypair classes
  const privateKeyBytes = new Uint8Array(Buffer.from(cleanedKey, "base64"));

  const keypairClasses = [Ed25519Keypair, Secp256k1Keypair, Secp256r1Keypair];
  for (const KeypairClass of keypairClasses) {
    try {
      return KeypairClass.fromSecretKey(privateKeyBytes);
    } catch {}
  }
  throw new Error("Failed to initialize keypair from secret key");
};

const loadFromMnemonics = (mnemonics: string) => {
  const keypairMethods = [
    { Class: Ed25519Keypair, method: "deriveKeypairFromSeed" },
    { Class: Secp256k1Keypair, method: "deriveKeypair" },
    { Class: Secp256r1Keypair, method: "deriveKeypair" },
  ];
  for (const { Class, method } of keypairMethods) {
    try {
      return (Class as any)[method](mnemonics);
    } catch {}
  }
  throw new Error("Failed to derive keypair from mnemonics");
};

export type SuiNetwork = "mainnet" | "testnet" | "devnet" | "localnet";
export type FaucetNetwork = "testnet" | "devnet" | "localnet";

export const supportedSuiTokens: Map<string, TokenMetadata> = new Map([
  [
    "SUI",
    {
      symbol: "SUI",
      decimals: SUI_DECIMALS,
      tokenAddress: "0x2::sui::SUI",
    },
  ],
  [
    "USDC",
    {
      symbol: "USDC",
      decimals: 6,
      tokenAddress:
        "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
    },
  ],
]);

export const getTokenMetadata = (symbol: string) => {
  const metadata = supportedSuiTokens.get(symbol.toUpperCase());
  if (!metadata) throw new Error(`Token ${symbol} not found`);
  return metadata;
};

/**
 * Configuration options for initializing a Sui chain connection
 */
export interface SuiChainConfig {
  /** Private key for signing transactions. Should be managed securely! */
  privateKey: string;
  /** Type of sui network */
  network: SuiNetwork;
}

/**
 * Implementation of the IChain interface for interacting with the Sui L1 blockchain
 *
 * @example
 * ```ts
 * const sui = new SuiChain({
 *   privateKey: process.env.SUI_PRIVATE_KEY,
 *   network: process.env.SUI_NETWORK,
 * });
 * ```
 */
export class SuiChain implements IChain {
  /** Unique identifier for this chain implementation */
  public chainId = "sui";
  /** RPC client instance for connecting to Sui */
  private client: SuiClient;
  /** Type of sui network */
  private network: SuiNetwork;
  /** Account instance for transaction signing */
  private wallet: Signer;

  /**
   * Creates a new SuiChain instance
   * @param config - Configuration options for the Sui connection
   */
  constructor(config: SuiChainConfig) {
    this.client = new SuiClient({
      url: getFullnodeUrl(config.network),
    });
    this.network = config.network;
    this.wallet = parseAccount(config.privateKey);
  }

  /**
   * Performs a read-only call to a Sui contract
   * @param call - The contract call parameters
   * @returns The result of the contract call
   * @throws Error if the call fails
   */
  public async read(call: unknown): Promise<any> {
    const { objectId } = call as {
      objectId: string;
    };

    const object = await this.client.getObject({
      id: objectId,
      options: {
        showContent: true,
        showBcs: true,
        showDisplay: true,
        showOwner: true,
        showPreviousTransaction: true,
        showStorageRebate: true,
        showType: true,
      },
    });

    return object;
  }

  /**
   * Executes a state-changing transaction on Sui
   * @param call - The transaction parameters
   * @returns The transaction receipt after confirmation
   * @throws Error if the transaction fails
   */
  public async write(call: unknown): Promise<SuiTransactionBlockResponse> {
    const { packageId, moduleName, functionName, params, tx } = call as {
      packageId: string;
      moduleName: string;
      functionName: string;
      params: Array<any>;
      tx: Transaction;
    };

    tx.moveCall({
      target: `${packageId}::${moduleName}::${functionName}`,
      arguments: params,
    });

    const result = await this.client.signAndExecuteTransaction({
      signer: this.wallet,
      transaction: tx,
    });

    return result;
  }

  /**
   * Executes a swap transaction on Sui
   * @param call - The swap transaction parameters
   * @returns The transaction digest and message after confirmation
   * @throws Error if the transaction fails
   */
  public async swapToken(call: unknown): Promise<SwapResult> {
    try {
      const { fromToken, amount, out_min_amount, targetToken } = call as {
        fromToken: string;
        amount: string;
        targetToken: string;
        out_min_amount: number | null;
      };

      const aggregatorURL = "https://api-sui.cetus.zone/router_v2/find_routes";
      const fromMeta = getTokenMetadata(fromToken);
      const toMeta = getTokenMetadata(targetToken);

      // Cast the client to any to avoid type incompatibilities
      const client = new AggregatorClient(
        aggregatorURL,
        this.wallet.toSuiAddress(),
        this.client as any,
        Env.Mainnet
      );
      // provider list : https://api-sui.cetus.zone/router_v2/status
      const routerRes = await client.findRouters({
        from: fromMeta.tokenAddress,
        target: toMeta.tokenAddress,
        amount: new BN(amount),
        byAmountIn: true, // `true` means fix input amount, `false` means fix output amount
        depth: 3, // max allow 3, means 3 hops
        providers: [
          "KRIYAV3",
          "CETUS",
          "SCALLOP",
          "KRIYA",
          "BLUEFIN",
          "DEEPBOOKV3",
          "FLOWXV3",
          "BLUEMOVE",
          "AFTERMATH",
          "FLOWX",
          "TURBOS",
        ],
      });
      if (routerRes === null) {
        console.error(
          "No router found " +
            JSON.stringify({
              from: fromMeta.tokenAddress,
              target: toMeta.tokenAddress,
              amount: amount,
            })
        );
        return {
          success: false,
          tx: "",
          message: "No router found",
        };
      }

      if (out_min_amount && routerRes.amountOut.toNumber() < out_min_amount) {
        return {
          success: false,
          tx: "",
          message: "Out amount is less than out_min_amount",
        };
      }

      let coin: TransactionObjectArgument;
      const routerTx = new Transaction();

      if (fromToken.toUpperCase() === "SUI") {
        coin = routerTx.splitCoins(routerTx.gas, [amount]);
      } else {
        const allCoins = await this.client.getCoins({
          owner: this.wallet.toSuiAddress(),
          coinType: fromMeta.tokenAddress,
          limit: 30,
        });

        if (allCoins.data.length === 0) {
          console.error("No coins found");
          return {
            success: false,
            tx: "",
            message: "No coins found",
          };
        }

        const mergeCoins = [];

        for (let i = 1; i < allCoins.data.length; i++) {
          mergeCoins.push(allCoins.data[i].coinObjectId);
        }

        if (mergeCoins.length > 0) {
          routerTx.mergeCoins(allCoins.data[0].coinObjectId, mergeCoins);
        }
        coin = routerTx.splitCoins(allCoins.data[0].coinObjectId, [amount]);
      }

      // Cast the transaction to any to avoid type incompatibilities
      const targetCoin = await client.routerSwap({
        routers: routerRes!.routes,
        byAmountIn: true,
        txb: routerTx as any,
        inputCoin: coin as any,
        slippage: 0.5,
      });

      routerTx.transferObjects([targetCoin], this.wallet.toSuiAddress());
      routerTx.setSender(this.wallet.toSuiAddress());

      // Cast the transaction and wallet to any to avoid type incompatibilities
      const result = await client.signAndExecuteTransaction(
        routerTx as any,
        this.wallet as any
      );

      await this.client.waitForTransaction({
        digest: result.digest,
      });

      return {
        success: true,
        tx: result.digest,
        message: "Swap successful",
      };
    } catch (e) {
      return {
        success: false,
        tx: "n/a",
        message: "Swap unsuccessful " + e?.toString(),
      };
    }
  }

  /**
   * Returns testnet sui tokens
   * @param call - The params for faucet
   * @returns Success/Failure message
   */
  public async requestSui(call: unknown): Promise<any> {
    try {
      const { network, recipient } = call as {
        network: FaucetNetwork;
        recipient: string;
      };

      await requestSuiFromFaucetV0({
        host: getFaucetHost(network),
        recipient,
      });

      return {
        message: `Successfully requested SUI to ${recipient} on ${network}`,
      };
    } catch (e) {
      return {
        message: `Failed to request SUI: ${e}`,
      };
    }
  }

  /**
   * Returns the sui address of the connected account
   */
  public getAddress(): string {
    return this.wallet.toSuiAddress();
  }
}

--- End File: packages/defai/src/sui.ts ---

--- File: packages/discord/package.json ---
{
  "name": "@daydreamsai/discord",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "discord.js": "^14.18.0",
    "zod": "^3.24.2"
  }
}

--- End File: packages/discord/package.json ---

--- File: packages/discord/src/discord.ts ---
import { z } from "zod";
import { extension, input, output } from "@daydreamsai/core";
import { Events, type Message } from "discord.js";
import { DiscordClient } from "./io";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { LogLevel } from "@daydreamsai/core";

/* Implementation of the discord extension */
const discordService = service({
  register(container) {
    container.singleton(
      "discord",
      () =>
        new DiscordClient(
          {
            discord_token: process.env.DISCORD_TOKEN!,
            discord_bot_name: process.env.DISCORD_BOT_NAME!,
          },
          LogLevel.DEBUG
        )
    );
  },
});

export const discordChannelContext = context({
  type: "discord.channel",
  key: ({ channelId }) => channelId,
  schema: z.object({ channelId: z.string() }),
  async setup(args, setttings, { container }) {
    const channel = await container
      .resolve<DiscordClient>("discord")
      .client.channels.fetch(args.channelId);

    if (!channel) throw new Error("Invalid channel");

    return { channel };
  },
})
  .setInputs({
    "discord:message": input({
      schema: {
        user: z.object({ id: z.string(), name: z.string() }),
        text: z.string(),
      },
      handler(data) {
        return {
          data: data.text,
          params: { userId: data.user.id, username: data.user.name },
        };
      },
      subscribe(send, { container }) {
        function listener(message: Message) {
          if (
            message.author.displayName ==
            container.resolve<DiscordClient>("discord").credentials
              .discord_bot_name
          ) {
            console.log(
              `Skipping message from ${
                container.resolve<DiscordClient>("discord").credentials
                  .discord_bot_name
              }`
            );
            return;
          }
          send(
            discord.contexts!.discordChannel,
            { channelId: message.channelId },
            {
              user: {
                id: message.author.id,
                name: message.author.displayName,
              },
              text: message.content,
            }
          );
        }

        const { client } = container.resolve<DiscordClient>("discord");

        client.on(Events.MessageCreate, listener);
        return () => {
          client.off(Events.MessageCreate, listener);
        };
      },
    }),
  })
  .setOutputs({
    "discord:message": output({
      schema: z.string(),
      examples: [`<output type="discord:message">Hi!</output>`],
      handler: async (data, ctx, { container }) => {
        const channel = ctx.options.channel;
        if (channel && (channel.isTextBased() || channel.isDMBased())) {
          await container.resolve<DiscordClient>("discord").sendMessage({
            channelId: ctx.args.channelId,
            content: data,
          });

          return {
            data,
            timestamp: Date.now(),
          };
        }
        throw new Error("Invalid channel id");
      },
    }),
  });

export const discord = extension({
  name: "discord",
  services: [discordService],
  contexts: {
    discordChannel: discordChannelContext,
  },
});

--- End File: packages/discord/src/discord.ts ---

--- File: packages/discord/src/index.ts ---
export * from "./discord";
export * from "./io";

--- End File: packages/discord/src/index.ts ---

--- File: packages/discord/src/io.ts ---
import {
  ChannelType,
  Client,
  Events,
  GatewayIntentBits,
  Partials,
  TextChannel,
  DMChannel,
  Message,
  type Channel,
} from "discord.js";
import { Logger, LogLevel } from "@daydreamsai/core";
import { z } from "zod";

export interface DiscordCredentials {
  discord_token: string;
  discord_bot_name: string;
}

export interface MessageData {
  content: string;
  channelId: string;
  conversationId?: string;
  sendBy?: string;
}

export const messageSchema = z.object({
  content: z.string().describe("The content of the message"),
  channelId: z.string().describe("The channel ID where the message is sent"),
  sendBy: z.string().optional().describe("The user ID of the sender"),
  conversationId: z
    .string()
    .optional()
    .describe("The conversation ID (if applicable)"),
});
export class DiscordClient {
  public client: Client;
  private logger: Logger;
  private messageListener?: (...args: any[]) => void;
  public credentials: DiscordCredentials;

  constructor(
    credentials: DiscordCredentials,
    logLevel: LogLevel = LogLevel.INFO
  ) {
    this.credentials = credentials;
    this.client = new Client({
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.DirectMessages,
        GatewayIntentBits.DirectMessageTyping,
        GatewayIntentBits.DirectMessageReactions,
      ],
      partials: [Partials.Channel], // For DM support
    });

    this.logger = new Logger({
      level: logLevel,
    });

    // Handle "ready" event
    this.client.on(Events.ClientReady, () => {
      this.logger.info("DiscordClient", "Initialized successfully");
    });

    // Log in to Discord
    this.client.login(this.credentials.discord_token).catch((error) => {
      this.logger.error("DiscordClient", "Failed to login", { error });
      console.error("Login error:", error);
    });
  }

  /**
   *  Optionally start listening to Discord messages.
   *  The onData callback typically feeds data into Orchestrator or similar.
   */
  public startMessageStream(onData: (data: any | any[]) => void) {
    this.logger.info("DiscordClient", "Starting message stream...");

    // If you want to capture the listener reference for removal:
    this.messageListener = (message: Message) => {
      // Here, you could decide what "data" looks like
      // E.g., check if the bot was mentioned, etc.

      if (message.author.displayName == this.credentials.discord_bot_name) {
        console.log(
          `Skipping message from ${this.credentials.discord_bot_name}`
        );
        return;
      }

      onData({
        userId: message.author?.displayName,
        platformId: "discord",
        threadId: message.channel.id,
        isDM: message.channel.type === ChannelType.DM,
        contentId: message.id,
        data: {
          content: message.content,
        },
      });
    };

    this.client.on(Events.MessageCreate, this.messageListener);
  }

  /**
   *  Optionally remove the message listener if you want to stop the stream.
   */
  public stopMessageStream() {
    if (this.messageListener) {
      this.client.removeListener(Events.MessageCreate, this.messageListener);
      this.logger.info("DiscordClient", "Message stream stopped");
    }
  }

  /**
   *  Gracefully destroy the Discord connection
   */
  public destroy() {
    this.stopMessageStream();
    this.client.destroy();
    this.logger.info("DiscordClient", "Client destroyed");
  }

  private getIsValidTextChannel(
    channel?: Channel
  ): channel is TextChannel | DMChannel {
    return (
      channel?.type === ChannelType.GuildText ||
      channel?.type === ChannelType.DM
    );
  }

  async sendMessage(data: MessageData): Promise<{
    success: boolean;
    messageId?: string;
    content?: string;
    error?: string;
  }> {
    try {
      this.logger.info("DiscordClient.sendMessage", "Sending message", {
        data,
      });

      if (!data?.channelId || !data?.content) {
        return {
          success: false,
          error: "Channel ID and content are required",
        };
      }

      const channel = this.client.channels.cache.get(data?.channelId);
      if (!this.getIsValidTextChannel(channel)) {
        const error = new Error(
          `Invalid or unsupported channel: ${data.channelId}`
        );
        this.logger.error(
          "DiscordClient.sendMessage",
          "Error sending message",
          {
            error,
          }
        );
        throw error;
      }

      let sentMessage;
      const MAX_LENGTH = 1500; // Setting a conservative limit to avoid Discord API errors

      console.log("Sending message", data.content.length);

      // If message is longer than MAX_LENGTH, split and send multiple messages
      if (data.content.length > MAX_LENGTH) {
        // Split on newlines if possible to maintain formatting
        const chunks = [];
        let currentChunk = "";
        const lines = data.content.split("\n");

        for (const line of lines) {
          // If adding this line would exceed max length, push current chunk and start new one
          if (currentChunk.length + line.length + 1 > MAX_LENGTH) {
            if (currentChunk) {
              chunks.push(currentChunk);
              currentChunk = "";
            }

            // If single line is longer than MAX_LENGTH, split it
            if (line.length > MAX_LENGTH) {
              let remainingLine = line;
              while (remainingLine.length > 0) {
                chunks.push(remainingLine.slice(0, MAX_LENGTH));
                remainingLine = remainingLine.slice(MAX_LENGTH);
              }
            } else {
              currentChunk = line;
            }
          } else {
            // Add line to current chunk
            currentChunk = currentChunk ? currentChunk + "\n" + line : line;
          }
        }

        // Push final chunk if it exists
        if (currentChunk) {
          chunks.push(currentChunk);
        }

        // Send all chunks sequentially
        for (const chunk of chunks) {
          sentMessage = await channel.send(chunk);
        }
      } else {
        // Send normal message
        sentMessage = await channel.send(data.content);
      }

      return {
        success: true,
        messageId: sentMessage?.id,
        content: data.content,
        error: undefined,
      };
    } catch (error) {
      this.logger.error("DiscordClient.sendMessage", "Error sending message", {
        error,
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }
}

--- End File: packages/discord/src/io.ts ---

--- File: packages/hyperliquid/package.json ---
{
  "name": "@daydreamsai/hyperliquid",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "hyperliquid": "^1.6.2",
    "zod": "^3.24.2"
  }
}

--- End File: packages/hyperliquid/package.json ---

--- File: packages/hyperliquid/src/hyperliquid.ts ---
import { Hyperliquid } from "hyperliquid";
import { Logger } from "@daydreamsai/core";
import { LogLevel } from "@daydreamsai/core";
import { z } from "zod";

const envSchema = z.object({
  HYPERLIQUID_MAIN_ADDRESS: z.string(),
  HYPERLIQUID_WALLET_ADDRESS: z.string(),
  HYPERLIQUID_PRIVATE_KEY: z.string(),
  WEBSOCKET_URL: z.string().default("ws://localhost:8080"),
  DRY_RUN: z
    .preprocess((val) => val === "1" || val === "true", z.boolean())
    .default(true),
});

export const env = envSchema.parse(process.env);

export interface HyperliquidCredentials {
  mainAddress: string;
  walletAddress: string;
  privateKey: string;
}

export class HyperliquidClient {
  private client: Hyperliquid;
  private mainAddress: string;
  private logger: Logger;
  private perpMeta: any;

  constructor(
    credentials: HyperliquidCredentials,
    logLevel: LogLevel = LogLevel.INFO,
    testnet: boolean = false
  ) {
    this.mainAddress = credentials.mainAddress;
    this.client = new Hyperliquid({
      enableWs: true,
      privateKey: credentials.privateKey,
      testnet,
      walletAddress: credentials.walletAddress,
    });
    this.logger = new Logger({
      level: logLevel,
    });

    this.client.connect().catch((error) => {
      this.logger.error("HyperliquidClient", "Failed to login", {
        error,
      });
      throw error;
    });
  }

  public async placeLimitOrderInstantOrCancel(
    ticker: string,
    sz: number,
    limit_px: number,
    is_buy: boolean
  ) {
    try {
      return await this.placeOrder(ticker, sz, limit_px, is_buy, {
        limit: { tif: "Ioc" },
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place IOC order", {
        error,
        ticker,
        sz,
        limit_px,
        is_buy,
      });
      throw error;
    }
  }

  public async placeLimitOrderGoodTilCancel(
    ticker: string,
    sz: number,
    limit_px: number,
    is_buy: boolean
  ) {
    try {
      return await this.placeOrder(ticker, sz, limit_px, is_buy, {
        limit: { tif: "Gtc" },
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place GTC order", {
        error,
        ticker,
        sz,
        limit_px,
        is_buy,
      });
      throw error;
    }
  }

  public async cancelOrder(ticker: string, orderId: number) {
    try {
      return await this.client.exchange.cancelOrder({
        coin: ticker,
        o: orderId,
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to cancel order", {
        error,
        ticker,
        orderId,
      });
      throw error;
    }
  }

  public async getAccountBalancesAndPositions() {
    try {
      return await this.client.info.perpetuals.getClearinghouseState(
        this.mainAddress
      );
    } catch (error) {
      this.logger.error(
        "HyperliquidClient",
        "Failed to get account balances and positions",
        { error }
      );
      throw error;
    }
  }

  public async getOpenOrders() {
    try {
      return await this.client.info.getUserOpenOrders(this.mainAddress);
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to get open orders", {
        error,
      });
      throw error;
    }
  }

  public async marketSellPositions(tickers: string[]) {
    try {
      const positions = (await this.getAccountBalancesAndPositions())
        .assetPositions;
      return await Promise.all(
        tickers.map((ticker) => this.marketSellPosition(ticker, positions))
      );
    } catch (error) {
      this.logger.error(
        "HyperliquidClient",
        "Failed to market sell positions",
        { error, tickers }
      );
      throw error;
    }
  }

  public async marketSellPosition(ticker: string, positions: any) {
    try {
      if (!ticker) return;
      if (!positions) {
        const { assetPositions } = await this.getAccountBalancesAndPositions();
        positions = assetPositions;
      }
      const match = positions.find(
        (p: any) => p.position.coin === `${ticker.toUpperCase()}-PERP`
      );
      if (!match) return;
      const size = Number(match.position.szi);
      return await this.placeMarketOrder(ticker.toUpperCase(), size, false);
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to market sell position", {
        error,
        ticker,
      });
      throw error;
    }
  }

  private async loadPerpMeta() {
    try {
      if (this.perpMeta) return;
      this.perpMeta = {};
      const universe = (await this.client.info.perpetuals.getMeta()).universe;
      universe.forEach((token) => {
        this.perpMeta[token.name] = token.szDecimals;
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to load perp meta", {
        error,
      });
      throw error;
    }
  }

  public async placeMarketOrderUSD(
    ticker: string,
    totalprice: number,
    is_buy: boolean
  ) {
    try {
      await this.loadPerpMeta();
      const orderbook = await this.client.info.getL2Book(ticker + "-PERP");
      const triggerPx = is_buy
        ? Number(orderbook.levels[1][3].px)
        : Number(orderbook.levels[0][3].px);
      let szDecimals = this.perpMeta[ticker + "-PERP"];
      if (szDecimals === undefined) {
        throw new Error("Can't find szDecimals for " + ticker);
      }
      const sz = Number((totalprice / triggerPx).toFixed(szDecimals));
      const result = await this.placeOrder(ticker, sz, triggerPx, is_buy, {
        limit: { tif: "Ioc" },
      });
      return result;
    } catch (error) {
      this.logger.error(
        "HyperliquidClient",
        "Failed to place market order USD",
        { error, ticker, totalprice, is_buy }
      );
      throw error;
    }
  }

  public async placeMarketOrder(ticker: string, sz: number, is_buy: boolean) {
    try {
      const orderbook = await this.client.info.getL2Book(ticker + "-PERP");
      const triggerPx = is_buy
        ? Number(orderbook.levels[1][3].px)
        : Number(orderbook.levels[0][3].px);
      const result = await this.placeOrder(ticker, sz, triggerPx, is_buy, {
        limit: { tif: "Ioc" },
      });
      return result;
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place market order", {
        error,
        ticker,
        sz,
        is_buy,
      });
      throw error;
    }
  }

  private async placeOrder(
    ticker: string,
    sz: number,
    limit_px: number,
    is_buy: boolean,
    order_type: object
  ) {
    try {
      return await this.client.exchange.placeOrder({
        coin: ticker + "-PERP",
        is_buy,
        sz,
        limit_px,
        order_type,
        reduce_only: false,
      });
    } catch (error) {
      this.logger.error("HyperliquidClient", "Failed to place order", {
        error,
        ticker,
        sz,
        limit_px,
        is_buy,
        order_type,
      });
      throw error;
    }
  }
}

--- End File: packages/hyperliquid/src/hyperliquid.ts ---

--- File: packages/hyperliquid/src/index.ts ---
export * from "./hyperliquid";

--- End File: packages/hyperliquid/src/index.ts ---

--- File: packages/mcp/README.md ---
# MCP Integration for Daydreams

This module provides integration with the Model Context Protocol (MCP), allowing
Daydreams agents to connect to any MCP server and access its resources, prompts,
and tools.

## Overview

The Model Context Protocol (MCP) allows applications to provide context for LLMs
in a standardized way, separating the concerns of providing context from the
actual LLM interaction. This integration enables Daydreams agents to:

- Connect to multiple MCP servers simultaneously
- Access resources from MCP servers
- Execute tools provided by MCP servers
- Use prompts defined on MCP servers

## Usage

### Basic Setup

To connect your Daydreams agent to one or more MCP servers, add the MCP
extension to your agent configuration:

```typescript
import { createDreams } from "@daydreams/core";
import { createMcpExtension } from "@daydreams/core/mcp";

const agent = createDreams({
  // ... other agent configuration
  extensions: [
    createMcpExtension([
      {
        id: "sqlite-explorer",
        name: "SQLite Explorer",
        transport: {
          type: "stdio",
          command: "node",
          args: ["path/to/sqlite-explorer-server.js"],
        },
      },
      {
        id: "web-search",
        name: "Web Search Service",
        transport: {
          type: "sse",
          serverUrl: "http://localhost:3001",
        },
      },
    ]),
    // ... other extensions
  ],
});

await agent.start();
```

### Available Actions

The MCP extension adds the following actions to your agent:

#### List MCP Servers

```typescript
// List all connected MCP servers
const result = await agent.callTool({
  name: "mcp.listServers",
  arguments: {},
});
```

#### List Prompts

```typescript
// List all prompts available on a specific MCP server
const result = await agent.callTool({
  name: "mcp.listPrompts",
  arguments: {
    serverId: "sqlite-explorer",
  },
});
```

#### Get a Prompt

```typescript
// Get a specific prompt from an MCP server
const result = await agent.callTool({
  name: "mcp.getPrompt",
  arguments: {
    serverId: "sqlite-explorer",
    name: "query-database",
    arguments: {
      table: "users",
    },
  },
});
```

#### List Resources

```typescript
// List all resources available on a specific MCP server
const result = await agent.callTool({
  name: "mcp.listResources",
  arguments: {
    serverId: "sqlite-explorer",
  },
});
```

#### Read a Resource

```typescript
// Read a specific resource from an MCP server
const result = await agent.callTool({
  name: "mcp.readResource",
  arguments: {
    serverId: "sqlite-explorer",
    uri: "schema://main",
  },
});
```

#### Call a Tool

```typescript
// Call a tool on an MCP server
const result = await agent.callTool({
  name: "mcp.callTool",
  arguments: {
    serverId: "sqlite-explorer",
    name: "query",
    arguments: {
      sql: "SELECT * FROM users LIMIT 10",
    },
  },
});
```

## Transport Types

The MCP extension supports two types of transports:

### stdio

Use this for local MCP servers that run as separate processes:

```typescript
{
  id: "local-server",
  name: "Local MCP Server",
  transport: {
    type: "stdio",
    command: "node",
    args: ["server.js"],
  },
}
```

### SSE (Server-Sent Events)

Use this for remote MCP servers that expose an HTTP API with SSE:

```typescript
{
  id: "remote-server",
  name: "Remote MCP Server",
  transport: {
    type: "sse",
    serverUrl: "http://example.com",
    sseEndpoint: "/sse",      // Optional, defaults to "/sse"
    messageEndpoint: "/messages", // Optional, defaults to "/messages"
  },
}
```

## Error Handling

All MCP actions return an `error` field if something goes wrong. You can check
for this field to handle errors:

```typescript
const result = await agent.callTool({
  name: "mcp.callTool",
  arguments: {
    serverId: "sqlite-explorer",
    name: "query",
    arguments: {
      sql: "SELECT * FROM users LIMIT 10",
    },
  },
});

if (result.error) {
  console.error("Error calling MCP tool:", result.error);
} else {
  console.log("Tool result:", result.result);
}
```

--- End File: packages/mcp/README.md ---

--- File: packages/mcp/package.json ---
{
  "name": "@daydreamsai/mcp",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@modelcontextprotocol/sdk": "^1.6.1",
    "zod": "^3.24.2"
  }
}

--- End File: packages/mcp/package.json ---

--- File: packages/mcp/src/client.ts ---
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";

/**
 * Creates and connects an MCP client to a server
 * @param options Configuration options for the MCP client
 * @returns Connected MCP client instance
 */
export async function createMcpClient(options: {
  // Client identification
  clientInfo?: {
    name: string;
    version: string;
  };
  // Transport configuration
  transport: {
    type: "stdio" | "sse";
    // For stdio transport
    command?: string;
    args?: string[];
    // For SSE transport
    serverUrl?: string;
    sseEndpoint?: string;
    messageEndpoint?: string;
  };
  // Capabilities to request from the server
  capabilities?: {
    prompts?: Record<string, unknown>;
    resources?: Record<string, unknown>;
    tools?: Record<string, unknown>;
  };
  env?: Record<string, string>;
}) {
  // Set default client info if not provided
  const clientInfo = options.clientInfo || {
    name: "generic-mcp-client",
    version: "1.0.0",
  };

  // Set default capabilities if not provided
  const capabilities = options.capabilities || {
    prompts: {},
    resources: {},
    tools: {},
  };

  // Create the appropriate transport based on the type
  let transport;
  if (options.transport.type === "stdio") {
    if (!options.transport.command) {
      throw new Error("Command is required for stdio transport");
    }

    transport = new StdioClientTransport({
      command: options.transport.command,
      args: options.transport.args || [],
      env: options.env,
    });
  } else if (options.transport.type === "sse") {
    if (!options.transport.serverUrl) {
      throw new Error("Server URL is required for SSE transport");
    }

    // Create the SSE transport with the correct configuration
    // Convert string URL to URL object
    const serverUrl = new URL(options.transport.serverUrl);
    transport = new SSEClientTransport(serverUrl);
  } else {
    throw new Error(`Unsupported transport type: ${options.transport.type}`);
  }

  // Create the client
  const client = new Client(clientInfo, { capabilities });

  // Connect to the server
  await client.connect(transport);

  return client;
}

// Example usage:
/*
// Connect to a stdio-based server
const stdioClient = await createMcpClient({
  clientInfo: {
    name: "my-agent",
    version: "1.0.0",
  },
  transport: {
    type: "stdio",
    command: "node",
    args: ["server.js"],
  },
  capabilities: {
    prompts: {},
    resources: {},
    tools: {},
  },
});

// Connect to an SSE-based server
const sseClient = await createMcpClient({
  transport: {
    type: "sse",
    serverUrl: "http://localhost:3001",
  },
});

// List prompts
const prompts = await client.listPrompts();

// Get a prompt
const prompt = await client.getPrompt({
  name: "example-prompt",
  arguments: {
    arg1: "value",
  },
});

// List resources
const resources = await client.listResources();

// Read a resource
const resource = await client.readResource({
  uri: "file:///example.txt",
});

// Call a tool
const result = await client.callTool({
  name: "example-tool",
  arguments: {
    arg1: "value",
  },
});
*/

--- End File: packages/mcp/src/client.ts ---

--- File: packages/mcp/src/extension.ts ---
import { z } from "zod";
import { createMcpClient } from "./client";
import {
  Logger,
  action,
  extension,
  type ActionCallContext,
  type Context,
} from "@daydreamsai/core";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

export interface McpServerConfig {
  id: string;
  name: string;
  transport: {
    type: "stdio" | "sse";
    // For stdio transport
    command?: string;
    args?: string[];
    // For SSE transport
    serverUrl?: string;
    sseEndpoint?: string;
    messageEndpoint?: string;
  };
  capabilities?: {
    prompts?: Record<string, unknown>;
    resources?: Record<string, unknown>;
    tools?: Record<string, unknown>;
  };
}

/**
 * Creates an extension that connects to one or more MCP servers
 * and exposes their capabilities as actions within the agent system.
 *
 * @param servers Configuration for one or more MCP servers to connect to
 * @returns An extension that can be added to the agent's extensions list
 */
export function createMcpExtension(servers: McpServerConfig[]) {
  const clients = new Map<string, Client>();

  return extension({
    name: "mcp",

    // Initialize MCP clients when the extension is installed
    async install(agent) {
      const logger = agent.container.resolve<Logger>("logger");

      logger.info("mcp:extension", "Installing MCP extension", {
        serversCount: servers.length,
      });

      // Connect to each configured MCP server
      for (const server of servers) {
        logger.debug("mcp:extension", "Connecting to MCP server", {
          id: server.id,
          name: server.name,
          transportType: server.transport.type,
        });

        try {
          const client = await createMcpClient({
            clientInfo: {
              name: `daydreams-mcp-client`,
              version: "1.0.0",
            },
            transport: server.transport,
            capabilities: server.capabilities,
          });

          clients.set(server.id, client);
          logger.info("mcp:extension", "Connected to MCP server", {
            id: server.id,
            name: server.name,
          });
        } catch (error) {
          logger.error("mcp:extension", "Failed to connect to MCP server", {
            id: server.id,
            name: server.name,
            error,
          });
        }
      }
    },

    // Define actions for interacting with MCP servers
    actions: [
      action({
        name: "mcp.listServers",
        description: "List all MCP servers",
        handler() {
          const serverList = servers.map((server) => ({
            id: server.id,
            name: server.name,
            connected: clients.has(server.id),
            transportType: server.transport.type,
          }));

          return { servers: serverList };
        },
      }),

      // Action to list available tools from a specific MCP server
      action({
        name: "mcp.listTools",
        description: "List available tools from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
        },
        async handler({ serverId }, ctx, agent) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }
          const tools = await client.listTools();
          return { tools };
        },
      }),
      // Action to list available prompts from a specific MCP server
      action({
        name: "mcp.listPrompts",
        description: "List available prompts from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
        },
        async handler({ serverId }, ctx) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const prompts = await client.listPrompts();
          return { prompts };
        },
      }),

      // Action to get a prompt from a specific MCP server
      action({
        name: "mcp.getPrompt",
        description: "Get a prompt from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
          name: z.string().describe("Name of the prompt to get"),
          arguments: z
            .record(z.any())
            .optional()
            .describe("Arguments for the prompt"),
        },
        async handler({ serverId, name, arguments: args }, ctx, agent) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const prompt = await client.getPrompt({
            name,
            arguments: args || {},
          });
          return { prompt };
        },
      }),

      // Action to list available resources from a specific MCP server
      action({
        name: "mcp.listResources",
        description: "List available resources from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
        },
        async handler({ serverId }, ctx) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const resources = await client.listResources();
          return { resources };
        },
      }),

      // Action to read a resource from a specific MCP server
      action({
        name: "mcp.readResource",
        description: "Read a resource from an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
          uri: z.string().describe("URI of the resource to read"),
        },
        async handler({ serverId, uri }, ctx) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const resource = await client.readResource({
            uri,
          });

          return { resource };
        },
      }),

      // Action to call a tool on a specific MCP server
      action({
        name: "mcp.callTool",
        description: "Call a tool on an MCP server",
        schema: {
          serverId: z.string().describe("ID of the MCP server to query"),
          name: z.string().describe("Name of the tool to call"),
          arguments: z
            .record(z.any())
            .optional()
            .describe("Arguments for the tool"),
        },
        async handler({ serverId, name, arguments: args }) {
          const client = clients.get(serverId);
          if (!client) {
            return {
              error: `MCP server with ID '${serverId}' not found`,
            };
          }

          const result = await client.callTool({
            name,
            arguments: args,
          });

          return { result };
        },
      }),
    ],
  });
}

--- End File: packages/mcp/src/extension.ts ---

--- File: packages/mcp/src/index.ts ---
export { createMcpClient } from "./client";
export { createMcpExtension } from "./extension";

--- End File: packages/mcp/src/index.ts ---

--- File: packages/mongo/package.json ---
{
  "name": "@daydreamsai/mongodb",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "crypto": "^1.0.1",
    "mongodb": "^6.14.2",
    "zod": "^3.24.2"
  }
}

--- End File: packages/mongo/package.json ---

--- File: packages/mongo/src/index.ts ---
export * from "./mongo";

--- End File: packages/mongo/src/index.ts ---

--- File: packages/mongo/src/mongo.ts ---
import { Collection, MongoClient } from "mongodb";
import type { MemoryStore } from "@daydreamsai/core";
import crypto from "crypto";

export interface MongoMemoryOptions {
  uri: string;
  dbName?: string;
  collectionName?: string;
}

interface MemoryDocument {
  _id: string;
  value: any;
}

export class MongoMemoryStore implements MemoryStore {
  private client: MongoClient;
  private collection: Collection<MemoryDocument> | null = null;
  private readonly dbName: string;
  private readonly collectionName: string;

  constructor(options: MongoMemoryOptions) {
    this.client = new MongoClient(options.uri);
    this.dbName = options.dbName || "dreams_memory";
    this.collectionName = options.collectionName || "conversations";
  }

  private _hashKey(key: string): string {
    return crypto.createHash("sha256").update(key).digest("hex");
  }

  /**
   * Initialize the MongoDB connection
   */
  async initialize(): Promise<void> {
    await this.client.connect();
    const db = this.client.db(this.dbName);
    this.collection = db.collection<MemoryDocument>(this.collectionName);
  }

  /**
   * Retrieves a value from the store
   * @param key - Key to look up
   * @returns The stored value or null if not found
   */
  async get<T>(key: string): Promise<T | null> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    console.log("getting", key);
    const hashedKey = this._hashKey(key);

    const doc = await this.collection.findOne({ _id: hashedKey });
    if (!doc) return null;

    return doc.value as T;
  }

  /**
   * Stores a value in the store
   * @param key - Key to store under
   * @param value - Value to store
   */
  async set(key: string, value: any): Promise<void> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    console.log("setting", key, value);
    const hashedKey = this._hashKey(key);

    await this.collection.updateOne(
      { _id: hashedKey },
      { $set: { value } },
      { upsert: true }
    );
  }

  /**
   * Removes a specific entry from the store
   * @param key - Key to remove
   */
  async delete(key: string): Promise<void> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    const hashedKey = this._hashKey(key);
    await this.collection.deleteOne({ _id: hashedKey });
  }

  /**
   * Removes all entries from the store
   */
  async clear(): Promise<void> {
    if (!this.collection) throw new Error("MongoDB not initialized");

    await this.collection.deleteMany({});
  }

  /**
   * Close the MongoDB connection
   */
  async close(): Promise<void> {
    await this.client.close();
  }

  async keys() {
    return [];
  }

  // async keys(base?: string) {
  //   if (!this.collection) throw new Error("MongoDB not initialized");

  //   const keys = await this.collection
  //     .find()
  //     .project<{ key: string }>({ key: true })
  //     .map((d) => d.key)
  //     .toArray();

  //   if (base) {
  //     return keys.filter((key) => key.startsWith(base));
  //   }

  //   return keys;
  // }
}

/**
 * Creates a new MongoDB-backed memory store
 * @param options - MongoDB connection options
 * @returns A MemoryStore implementation using MongoDB for storage
 */
export async function createMongoMemoryStore(
  options: MongoMemoryOptions
): Promise<MemoryStore> {
  const store = new MongoMemoryStore(options);
  await store.initialize();
  return store;
}

--- End File: packages/mongo/src/mongo.ts ---

--- File: packages/supabase/README.md ---
# @daydreamsai/supabase

A Supabase integration package for the DaydreamsAI platform, providing vector
storage with pgvector and memory storage capabilities.

## Features

- Store and retrieve vector embeddings in Supabase using pgvector
- Perform similarity searches with customizable thresholds and filters
- Persistent memory storage for conversation data
- Fully typed API with Zod schema validation
- Implements core DaydreamsAI interfaces for seamless integration

## Installation

```bash
npm install @daydreamsai/supabase
# or
yarn add @daydreamsai/supabase
# or
pnpm add @daydreamsai/supabase
```

--- End File: packages/supabase/README.md ---

--- File: packages/supabase/package.json ---
{
  "name": "@daydreamsai/supabase",
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "import": {
        "development": "./src/index.ts",
        "default": "./dist/index.js"
      }
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@supabase/supabase-js": "^2.49.1",
    "zod": "^3.24.2",
    "ai": "^4.1.54"
  }
}

--- End File: packages/supabase/package.json ---

--- File: packages/supabase/sql/setup.sql ---
-- Enable the pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Function to enable pgvector extension (used by the SupabaseVectorStore)
CREATE OR REPLACE FUNCTION enable_pgvector_extension()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  CREATE EXTENSION IF NOT EXISTS vector;
END;
$$;

-- Function to execute arbitrary SQL (used by the SupabaseVectorStore for initialization)
CREATE OR REPLACE FUNCTION execute_sql(query text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  EXECUTE query;
END;
$$;

-- -- Example table creation (this is done programmatically in the SupabaseVectorStore)
-- CREATE TABLE IF NOT EXISTS embeddings (
--   key TEXT PRIMARY KEY,
--   content TEXT,
--   embedding VECTOR(1536),
--   metadata JSONB
-- );

-- -- Example similarity search function (this is created programmatically in the SupabaseVectorStore)
-- CREATE OR REPLACE FUNCTION match_embeddings(
--   query_embedding VECTOR(1536),
--   match_threshold FLOAT,
--   match_count INT,
--   filter_metadata JSONB DEFAULT NULL,
--   filter_keys TEXT[] DEFAULT NULL
-- ) 
-- RETURNS TABLE (
--   key TEXT,
--   content TEXT,
--   metadata JSONB,
--   similarity FLOAT
-- )
-- LANGUAGE plpgsql
-- AS $$
-- BEGIN
--   RETURN QUERY
--   SELECT
--     t.key,
--     t.content,
--     t.metadata,
--     1 - (t.embedding <=> query_embedding) as similarity
--   FROM embeddings t
--   WHERE
--     (filter_metadata IS NULL OR t.metadata @> filter_metadata) AND
--     (filter_keys IS NULL OR t.key = ANY(filter_keys)) AND
--     1 - (t.embedding <=> query_embedding) > match_threshold
--   ORDER BY similarity DESC
--   LIMIT match_count;
-- END;
-- $$; 
--- End File: packages/supabase/sql/setup.sql ---

--- File: packages/supabase/src/index.ts ---
export * from "./schema";
export * from "./types";
export * from "./supabase";
export * from "./vector-store";
export * from "./memory-store";
export * from "./memory";

--- End File: packages/supabase/src/index.ts ---

--- File: packages/supabase/src/memory-store.ts ---
import type { MemoryStore } from "@daydreamsai/core";
import { createClient, SupabaseClient } from "@supabase/supabase-js";
import crypto from "crypto";

export function _hashKey(key: string): string {
  return crypto.createHash("sha256").update(key).digest("hex");
}

/**
 * Configuration for the Supabase memory store
 */
export interface SupabaseMemoryStoreConfig {
  /** Supabase URL */
  url: string;
  /** Supabase API key */
  key: string;
  /** Table name for storing memory data */
  tableName?: string;
}

/**
 * Creates a Supabase-backed implementation of the MemoryStore interface
 *
 * @param config - Configuration for the Supabase memory store
 * @returns A MemoryStore implementation using Supabase
 */
export function createSupabaseMemoryStore(
  config: SupabaseMemoryStoreConfig
): MemoryStore {
  const { url, key, tableName = "memory" } = config;

  // Create Supabase client
  const client = createClient(url, key);

  // Initialize the table if it doesn't exist
  initializeTable(client, tableName).catch(console.error);

  return {
    /**
     * Retrieves data from the Supabase memory store
     * @param key - Key to look up
     * @returns The stored value or null if not found
     */
    async get<T>(key: string): Promise<T | null> {
      const hashedKey = _hashKey(key);
      const { data, error } = await client
        .from(tableName)
        .select("value")
        .eq("key", hashedKey)
        .single();

      if (error || !data) {
        return null;
      }

      try {
        return JSON.parse(data.value) as T;
      } catch (e) {
        console.error(`Error parsing data for key ${key}:`, e);
        return null;
      }
    },

    /**
     * Stores data in the Supabase memory store
     * @param key - Key to store under
     * @param value - Value to store
     */
    async set<T>(key: string, value: T): Promise<void> {
      const hashedKey = _hashKey(key);
      const serializedValue = JSON.stringify(value);

      const { error } = await client
        .from(tableName)
        .upsert({
          key: hashedKey,
          value: serializedValue,
          updated_at: new Date().toISOString(),
        })
        .select();

      if (error) {
        throw new Error(`Failed to set value for key ${key}: ${error.message}`);
      }
    },

    /**
     * Retrieves all keys from the Supabase memory store.
     * Note: Returns hashed keys, not the original keys.
     * @returns An array of all stored (hashed) keys
     */
    async keys(): Promise<string[]> {
      const { data, error } = await client.from(tableName).select("key");

      if (error) {
        throw new Error(`Failed to retrieve keys: ${error.message}`);
      }

      return data ? data.map((row: { key: string }) => row.key) : [];
    },

    /**
     * Removes a specific entry from the Supabase memory store
     * @param key - Key to remove
     */
    async delete(key: string): Promise<void> {
      const hashedKey = _hashKey(key);
      const { error } = await client
        .from(tableName)
        .delete()
        .eq("key", hashedKey);

      if (error) {
        throw new Error(`Failed to delete key ${key}: ${error.message}`);
      }
    },

    /**
     * Removes all entries from the Supabase memory store
     */
    async clear(): Promise<void> {
      const { error } = await client.from(tableName).delete().neq("key", "");

      if (error) {
        throw new Error(`Failed to clear memory store: ${error.message}`);
      }
    },
  };
}

/**
 * Initialize the memory table in Supabase
 *
 * @param client - Supabase client
 * @param tableName - Name of the table to create
 */
async function initializeTable(
  client: SupabaseClient,
  tableName: string
): Promise<void> {
  // Check if the table exists by querying it
  const { error } = await client.from(tableName).select("key").limit(1);

  // If the table doesn't exist, create it
  if (error && error.code === "42P01") {
    // PostgreSQL code for undefined_table
    // We need to use raw SQL to create the table
    // This requires the execute_sql function to be available in the database
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS ${tableName} (
        key TEXT PRIMARY KEY,
        value TEXT NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
      );
    `;

    try {
      const result = await client.rpc("execute_sql", {
        query: createTableQuery,
      });
      console.log(`Created memory table: ${tableName}`);
      console.log("result", result);
    } catch (e) {
      console.error(`Failed to create memory table ${tableName}:`, e);
      throw e;
    }
  } else if (error) {
    console.error(`Error checking memory table ${tableName}:`, error);
  }
}

/**
 * Factory function to create a MemoryStore implementation using Supabase
 *
 * @param url - Supabase URL
 * @param key - Supabase API key
 * @param tableName - Name of the table to store memory data
 * @returns A MemoryStore implementation
 */
export function createSupabaseMemory(
  url: string,
  key: string,
  tableName: string = "memory"
): MemoryStore {
  return createSupabaseMemoryStore({
    url,
    key,
    tableName,
  });
}

--- End File: packages/supabase/src/memory-store.ts ---

--- File: packages/supabase/src/memory.ts ---
import type { BaseMemory } from "@daydreamsai/core";
import type { LanguageModelV1 } from "ai";
import { createSupabaseMemoryStore } from "./memory-store";
import { createSupabaseVectorStore } from "./vector-store";
import type { TextEmbeddingModel } from "./vector-store";

/**
 * Configuration for creating a Supabase-backed memory system
 */
export interface SupabaseMemoryConfig {
  /** Supabase URL */
  url: string;
  /** Supabase API key */
  key: string;
  /** Table name for storing memory data */
  memoryTableName?: string;
  /** Table name for storing vector embeddings */
  vectorTableName?: string;
  /** Optional embedding model for generating vector embeddings */
  vectorModel?: TextEmbeddingModel | LanguageModelV1;
}

/**
 * Adapts a TextEmbeddingModel to the LanguageModelV1 interface expected by BaseMemory
 * This is a compatibility layer to make our TextEmbeddingModel work with the core package
 * @param embeddingModel - The TextEmbeddingModel to adapt
 * @returns A LanguageModelV1 compatible object that delegates to the TextEmbeddingModel
 */
function adaptEmbeddingModel(
  embeddingModel: TextEmbeddingModel
): LanguageModelV1 {
  return {
    specificationVersion: "v1",
    provider: embeddingModel.provider,
    modelId: embeddingModel.modelId,
    defaultObjectGenerationMode: undefined,

    // These methods are required by LanguageModelV1 but not used for embeddings
    doGenerate: async () => {
      throw new Error("Not implemented - this adapter is for embeddings only");
    },

    doStream: async () => {
      throw new Error("Not implemented - this adapter is for embeddings only");
    },
  };
}

/**
 * Creates a complete memory system backed by Supabase
 *
 * This includes both a MemoryStore for conversation data and a VectorStore for embeddings.
 *
 * @param config - Configuration for the Supabase memory system
 * @returns A BaseMemory implementation using Supabase
 */
export function createSupabaseBaseMemory(
  config: SupabaseMemoryConfig
): BaseMemory {
  const {
    url,
    key,
    memoryTableName = "memory",
    vectorTableName = "embeddings",
    vectorModel,
  } = config;

  // Create the memory store
  const store = createSupabaseMemoryStore({
    url,
    key,
    tableName: memoryTableName,
  });

  // Determine if the provided model is a TextEmbeddingModel or LanguageModelV1
  const isTextEmbeddingModel =
    vectorModel &&
    "generateEmbeddings" in vectorModel &&
    typeof vectorModel.generateEmbeddings === "function";

  // Create the vector store with the appropriate embedding model
  const vector = createSupabaseVectorStore(
    {
      url,
      key,
      tableName: vectorTableName,
      embeddingColumnName: "embedding",
      contentColumnName: "content",
      metadataColumnName: "metadata",
    },
    isTextEmbeddingModel ? (vectorModel as TextEmbeddingModel) : undefined
  );

  // Return the complete memory system with the appropriate vectorModel
  return {
    store,
    vector,
    // Adapt TextEmbeddingModel to LanguageModelV1 if needed
    vectorModel: isTextEmbeddingModel
      ? adaptEmbeddingModel(vectorModel as TextEmbeddingModel)
      : (vectorModel as LanguageModelV1 | undefined),
  };
}

--- End File: packages/supabase/src/memory.ts ---

--- File: packages/supabase/src/schema.ts ---
import { z } from "zod";

export const SupabaseVectorStoreSchema = z.object({
  url: z.string().url(),
  key: z.string(),
  tableName: z.string(),
  queryName: z.string().optional(),
  embeddingColumnName: z.string().default("embedding"),
  contentColumnName: z.string().default("content"),
  metadataColumnName: z.string().default("metadata"),
});

export const SupabaseVectorRecordSchema = z.object({
  key: z.string(),
  content: z.string(),
  embedding: z.array(z.number()),
  metadata: z.record(z.any()).optional(),
});

export const SupabaseVectorFilterSchema = z.object({
  metadata: z.record(z.any()).optional(),
  keys: z.array(z.string()).optional(),
});

export const SupabaseSearchResultSchema = z.object({
  key: z.string(),
  content: z.string(),
  metadata: z.record(z.any()).optional(),
  similarity: z.number().optional(),
});

--- End File: packages/supabase/src/schema.ts ---

--- File: packages/supabase/src/supabase.ts ---
import { createClient, SupabaseClient } from "@supabase/supabase-js";

import type {
  SupabaseVectorStoreConfig,
  SupabaseVectorRecord,
  SupabaseVectorFilter,
  SupabaseSearchResult,
  SupabaseVectorStoreOptions,
} from "./types";
import { SupabaseVectorStoreSchema } from "./schema";

/**
 * SupabaseVectorStore - A vector store implementation using Supabase with pgvector
 *
 * This class provides methods to store, retrieve, and search vector embeddings in a Supabase database
 * using the pgvector extension.
 */
export class SupabaseVectorStore {
  private client: SupabaseClient;
  private tableName: string;
  private queryName: string;
  private embeddingColumnName: string;
  private contentColumnName: string;
  private metadataColumnName: string;

  /**
   * Create a new SupabaseVectorStore instance
   *
   * @param options - Configuration options for the vector store
   */
  constructor(options: SupabaseVectorStoreOptions) {
    this.client = options.client;
    this.tableName = options.tableName.toLowerCase();
    this.queryName =
      options.queryName || `match_${this.tableName.toLowerCase()}`;
    this.embeddingColumnName = options.embeddingColumnName || "embedding";
    this.contentColumnName = options.contentColumnName || "content";
    this.metadataColumnName = options.metadataColumnName || "metadata";
  }

  /**
   * Create a new SupabaseVectorStore from configuration
   *
   * @param config - Configuration for the Supabase vector store
   * @returns A new SupabaseVectorStore instance
   */
  static fromConfig(config: SupabaseVectorStoreConfig): SupabaseVectorStore {
    const validatedConfig = SupabaseVectorStoreSchema.parse(config);

    const client = createClient(validatedConfig.url, validatedConfig.key);

    return new SupabaseVectorStore({
      client,
      tableName: validatedConfig.tableName,
      queryName: validatedConfig.queryName,
      embeddingColumnName: validatedConfig.embeddingColumnName,
      contentColumnName: validatedConfig.contentColumnName,
      metadataColumnName: validatedConfig.metadataColumnName,
    });
  }

  /**
   * Initialize the database schema for vector storage
   *
   * This method creates the necessary tables and functions for vector storage and similarity search
   *
   * @param dimensions - The dimensions of the vectors to be stored (default: 1536)
   * @returns A promise that resolves when the initialization is complete
   */
  async initialize(dimensions: number = 1536): Promise<void> {
    try {
      // Enable the pgvector extension
      const result = await this.client.rpc("enable_pgvector_extension");
      console.log("SupabaseVectorStore initialized", result);

      // Create the table if it doesn't exist
      const createTableQuery = `
        CREATE TABLE IF NOT EXISTS ${this.tableName} (
          key TEXT PRIMARY KEY,
          ${this.contentColumnName} TEXT,
          ${this.embeddingColumnName} VECTOR(${dimensions}),
          ${this.metadataColumnName} JSONB
        );
      `;
      const result2 = await this.client.rpc("execute_sql", {
        query: createTableQuery,
      });
      console.log("SupabaseVectorStore table created", result2);

      // Create the similarity search function
      const createFunctionQuery = `
        CREATE OR REPLACE FUNCTION ${this.queryName}(
          query_embedding VECTOR(${dimensions}),
          match_threshold FLOAT,
          match_count INT,
          filter_metadata JSONB DEFAULT NULL,
          filter_keys TEXT[] DEFAULT NULL
        ) 
        RETURNS TABLE (
          key TEXT,
          ${this.contentColumnName} TEXT,
          ${this.metadataColumnName} JSONB,
          similarity FLOAT
        )
        LANGUAGE plpgsql
        AS $$
        BEGIN
          RETURN QUERY
          SELECT
            t.key,
            t.${this.contentColumnName},
            t.${this.metadataColumnName},
            1 - (t.${this.embeddingColumnName} <=> query_embedding) as similarity
          FROM ${this.tableName} t
          WHERE
            (filter_metadata IS NULL OR t.${this.metadataColumnName} @> filter_metadata) AND
            (filter_keys IS NULL OR t.key = ANY(filter_keys)) AND
            1 - (t.${this.embeddingColumnName} <=> query_embedding) > match_threshold
          ORDER BY similarity DESC
          LIMIT match_count;
        END;
        $$;
      `;
      const result3 = await this.client.rpc("execute_sql", {
        query: createFunctionQuery,
      });
      console.log("SupabaseVectorStore function created", result3);
    } catch (error) {
      console.error("Error initializing SupabaseVectorStore:", error);
      throw error instanceof Error
        ? error
        : new Error("Unknown error during vector store initialization");
    }
  }

  /**
   * Add vector records to the store
   *
   * @param records - The vector records to add
   * @returns A promise that resolves when the records are added
   */
  async addVectors(records: SupabaseVectorRecord[]): Promise<void> {
    if (records.length === 0) return;

    const rows = records.map((record) => ({
      key: record.key,
      [this.contentColumnName]: record.content,
      [this.embeddingColumnName]: record.embedding,
      [this.metadataColumnName]: record.metadata || {},
    }));

    const { error } = await this.client.from(this.tableName).upsert(rows);

    if (error) {
      throw new Error(`Failed to add vectors: ${error.message}`);
    }
  }

  /**
   * Delete vector records from the store
   *
   * @param keys - The keys of the records to delete
   * @returns A promise that resolves when the records are deleted
   */
  async deleteVectors(keys: string[]): Promise<void> {
    if (keys.length === 0) return;

    const { error } = await this.client
      .from(this.tableName)
      .delete()
      .in("key", keys);

    if (error) {
      throw new Error(`Failed to delete vectors: ${error.message}`);
    }
  }

  /**
   * Search for similar vectors
   *
   * @param embedding - The query embedding vector
   * @param options - Search options
   * @returns A promise that resolves to the search results
   */
  async similaritySearch(
    embedding: number[],
    {
      filter = {},
      matchThreshold = 0.5,
      maxResults = 10,
    }: {
      filter?: SupabaseVectorFilter;
      matchThreshold?: number;
      maxResults?: number;
    } = {}
  ): Promise<SupabaseSearchResult[]> {
    const { data, error } = await this.client.rpc(this.queryName, {
      query_embedding: embedding,
      match_threshold: matchThreshold,
      match_count: maxResults,
      filter_metadata: filter.metadata || null,
      filter_keys: filter.keys || null,
    });

    if (error) {
      throw new Error(`Failed to search vectors: ${error.message}`);
    }

    return data.map((item: Record<string, any>) => ({
      key: item.key,
      content: item[this.contentColumnName],
      metadata: item[this.metadataColumnName],
      similarity: item.similarity,
    }));
  }

  /**
   * Get vector records by IDs
   *
   * @param ids - The IDs of the records to retrieve
   * @returns A promise that resolves to the retrieved records
   */
  async getVectorsByIds(ids: string[]): Promise<SupabaseVectorRecord[]> {
    if (ids.length === 0) return [];

    const { data, error } = await this.client
      .from(this.tableName)
      .select(
        `key, ${this.contentColumnName}, ${this.embeddingColumnName}, ${this.metadataColumnName}`
      )
      .in("key", ids);

    if (error) {
      throw new Error(`Failed to get vectors: ${error.message}`);
    }

    return data.map((item: Record<string, any>) => ({
      key: item.key,
      content: item[this.contentColumnName],
      embedding: item[this.embeddingColumnName],
      metadata: item[this.metadataColumnName],
    }));
  }
}

--- End File: packages/supabase/src/supabase.ts ---

--- File: packages/supabase/src/types.ts ---
import { type SupabaseClient } from "@supabase/supabase-js";
import { z } from "zod";
import type { SupabaseVectorStoreSchema } from "./schema";

export type SupabaseVectorStoreConfig = z.infer<
  typeof SupabaseVectorStoreSchema
>;

export interface SupabaseVectorRecord {
  key: string;
  content: string;
  embedding: number[];
  metadata?: Record<string, any>;
}

export interface SupabaseVectorFilter {
  metadata?: Record<string, any>;
  keys?: string[];
}

export interface SupabaseVectorStoreOptions {
  client: SupabaseClient;
  tableName: string;
  queryName?: string;
  embeddingColumnName?: string;
  contentColumnName?: string;
  metadataColumnName?: string;
}

export interface SupabaseSearchResult {
  key: string;
  content: string;
  metadata?: Record<string, any>;
  similarity?: number;
}

--- End File: packages/supabase/src/types.ts ---

--- File: packages/supabase/src/vector-store.ts ---
import { type VectorStore } from "@daydreamsai/core";
import { SupabaseVectorStore } from "./supabase";
import type { SupabaseVectorStoreConfig } from "./types";

/**
 * Interface for text embedding models
 */
export interface TextEmbeddingModel {
  /**
   * Provider name for the embedding model
   */
  provider: string;

  /**
   * Model ID for the embedding model
   */
  modelId: string;

  /**
   * Generates embeddings for an array of text strings
   * @param texts - Array of text strings to embed
   * @returns Promise resolving to a 2D array of embeddings
   */
  generateEmbeddings(texts: string[]): Promise<number[][]>;
}

/**
 * Creates a default OpenAI embedding provider
 * @param apiKey - OpenAI API key (defaults to process.env.OPENAI_API_KEY)
 * @param model - OpenAI embedding model to use (defaults to text-embedding-3-small)
 * @returns A TextEmbeddingModel implementation for generating embeddings
 */
export function createOpenAIEmbeddingProvider(
  apiKey: string = process.env.OPENAI_API_KEY || "",
  model: string = "text-embedding-3-small"
): TextEmbeddingModel {
  return {
    provider: "openai",
    modelId: model,

    async generateEmbeddings(texts: string[]): Promise<number[][]> {
      if (!apiKey) {
        throw new Error("OpenAI API key is required for embedding generation");
      }

      try {
        // Use fetch directly to avoid requiring the OpenAI SDK as a dependency
        const response = await fetch("https://api.openai.com/v1/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify({
            model,
            input: texts,
          }),
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(`OpenAI API error: ${JSON.stringify(error)}`);
        }

        const data = await response.json();
        return data.data.map((item: any) => item.embedding);
      } catch (error) {
        console.error("Error generating embeddings:", error);
        throw error;
      }
    },
  };
}

/**
 * Creates a Supabase vector store that implements the core VectorStore interface
 *
 * @param config - Configuration for the Supabase vector store
 * @param embeddingProvider - Optional embedding provider (defaults to OpenAI if API key is available)
 * @returns A VectorStore implementation using Supabase with pgvector
 */
export function createSupabaseVectorStore(
  config: SupabaseVectorStoreConfig,
  embeddingProvider?: TextEmbeddingModel
): VectorStore {
  // Create the underlying SupabaseVectorStore
  const supabaseStore = SupabaseVectorStore.fromConfig(config);

  // Initialize the store with default dimensions
  // This is done asynchronously, but we don't await it here
  // to match the synchronous nature of the factory function
  supabaseStore.initialize().catch(console.error);

  // Use provided embedding provider or create a default one if OpenAI API key is available
  const embedder =
    embeddingProvider ||
    (process.env.OPENAI_API_KEY ? createOpenAIEmbeddingProvider() : undefined);

  return {
    connection: config.url,

    /**
     * Adds or updates data in the vector store
     * @param contextId - Unique identifier for the context
     * @param data - Data to add or update
     */
    async upsert(contextId: string, data: any[]): Promise<void> {
      // Generate embeddings if needed and if we have an embedding provider
      let dataWithEmbeddings = [...data];

      if (embedder) {
        const itemsNeedingEmbeddings = data.filter(
          (item) =>
            !item.embedding ||
            !Array.isArray(item.embedding) ||
            item.embedding.length === 0
        );

        if (itemsNeedingEmbeddings.length > 0) {
          const textsToEmbed = itemsNeedingEmbeddings.map(
            (item) => item.content || item.text || JSON.stringify(item)
          );
          const embeddings = await embedder.generateEmbeddings(textsToEmbed);

          // Update items with their embeddings
          let embeddingIndex = 0;
          dataWithEmbeddings = data.map((item) => {
            if (
              !item.embedding ||
              !Array.isArray(item.embedding) ||
              item.embedding.length === 0
            ) {
              return {
                ...item,
                embedding: embeddings[embeddingIndex++],
              };
            }
            return item;
          });
        }
      }

      // Convert the data to the format expected by SupabaseVectorStore
      const records = dataWithEmbeddings.map((item, index) => {
        // If the item already has an embedding, use it
        const embedding = item.embedding || [];

        return {
          key: item.key || `${contextId}-${index}`,
          content: item.content || item.text || JSON.stringify(item),
          embedding: embedding,
          metadata: {
            contextId,
            ...item.metadata,
          },
        };
      });

      await supabaseStore.addVectors(records);
    },

    /**
     * Searches the vector store for similar data
     * @param contextId - Context to search within
     * @param query - Query text to search for or query object with embedding
     * @returns Array of matching documents
     */
    async query(contextId: string, query: any): Promise<any[]> {
      // This implementation assumes that embeddings are generated elsewhere
      // and passed in the query parameter as an object with an embedding property
      const queryObj = typeof query === "string" ? { text: query } : query;

      // If we have an embedding in the query object, use it for similarity search
      if (queryObj.embedding && Array.isArray(queryObj.embedding)) {
        const results = await supabaseStore.similaritySearch(
          queryObj.embedding,
          {
            filter: {
              metadata: { contextId },
            },
            matchThreshold: queryObj.threshold || 0.5,
            maxResults: queryObj.limit || 10,
          }
        );

        return results.map((result) => ({
          ...result,
          text: result.content,
          score: result.similarity,
        }));
      }

      // If no embedding is provided but we have an embedding provider, generate one
      if (embedder && queryObj.text) {
        try {
          const [embedding] = await embedder.generateEmbeddings([
            queryObj.text,
          ]);

          const results = await supabaseStore.similaritySearch(embedding, {
            filter: {
              metadata: { contextId },
            },
            matchThreshold: queryObj.threshold || 0.5,
            maxResults: queryObj.limit || 10,
          });

          return results.map((result) => ({
            ...result,
            text: result.content,
            score: result.similarity,
          }));
        } catch (error) {
          console.error("Error generating query embedding:", error);
          return [];
        }
      }

      // If no embedding is provided and we can't generate one, return empty results
      console.warn(
        "No embedding provided for query and no embedding provider available. Returning empty results."
      );
      return [];
    },

    /**
     * Creates a new index in the vector store
     * @param indexName - Name of the index to create
     */
    async createIndex(indexName: string): Promise<void> {
      // In Supabase with pgvector, indexes are created at the database level
      // This is a no-op for now, but could be implemented to create specific indexes
      console.log(
        `Creating index ${indexName} (no-op in Supabase implementation)`
      );
    },

    /**
     * Deletes an existing index from the vector store
     * @param indexName - Name of the index to delete
     */
    async deleteIndex(indexName: string): Promise<void> {
      // In Supabase with pgvector, indexes are managed at the database level
      // This is a no-op for now, but could be implemented to drop specific indexes
      console.log(
        `Deleting index ${indexName} (no-op in Supabase implementation)`
      );
    },
  };
}

/**
 * Factory function to create a VectorStore implementation using Supabase
 *
 * @param url - Supabase URL
 * @param key - Supabase API key
 * @param tableName - Name of the table to store vectors
 * @param embeddingProvider - Optional embedding provider (defaults to OpenAI if API key is available)
 * @returns A VectorStore implementation
 */
export function createSupabaseStore(
  url: string,
  key: string,
  tableName: string = "embeddings",
  embeddingProvider?: TextEmbeddingModel
): VectorStore {
  return createSupabaseVectorStore(
    {
      url,
      key,
      tableName,
      embeddingColumnName: "embedding",
      contentColumnName: "content",
      metadataColumnName: "metadata",
    },
    embeddingProvider
  );
}

--- End File: packages/supabase/src/vector-store.ts ---

--- File: packages/supabase/tsconfig.build.json ---
{
  "extends": "./tsconfig.json",
  "include": ["src/**/*"],
  "exclude": ["**/*.test.ts", "**/*.spec.ts"]
}

--- End File: packages/supabase/tsconfig.build.json ---

--- File: packages/telegram/package.json ---
{
  "name": "@daydreamsai/telegram",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "@telegraf/types": "^8.3.1",
    "telegraf": "^4.16.3",
    "zod": "^3.24.2"
  }
}

--- End File: packages/telegram/package.json ---

--- File: packages/telegram/src/index.ts ---
export * from "./telegram";

--- End File: packages/telegram/src/index.ts ---

--- File: packages/telegram/src/io.ts ---
import { z } from "zod";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { Telegraf } from "telegraf";
import type { Chat } from "@telegraf/types";
import {
  extension,
  input,
  output,
  splitTextIntoChunks,
} from "@daydreamsai/core";
import { formatMsg } from "@daydreamsai/core";

const telegramService = service({
  register(container) {
    container.singleton(
      "telegraf",
      () => new Telegraf(process.env.TELEGRAM_TOKEN!)
    );
  },
  async boot(container) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    console.log("starting..");
    telegraf.launch({ dropPendingUpdates: true });
    const telegrafInfo = await telegraf.telegram.getMe();
    console.log(telegrafInfo);
  },
});

const telegramChat = context({
  type: "telegram:chat",
  key: ({ chatId }) => chatId.toString(),
  schema: z.object({ chatId: z.number() }),
  async setup(args, {}, { container }) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    const chat = await telegraf.telegram.getChat(args.chatId);
    return {
      chat: chat as Chat,
    };
  },
  description({ options: { chat } }) {
    if (chat.type === "private") {
      return `You are in private telegram chat with ${chat.username} id: ${chat.id}`;
    }
    return "";
  },
});

export const telegramExtension = extension({
  name: "telegram",
  services: [telegramService],
  contexts: {
    chat: telegramChat,
  },
  inputs: {
    "telegram:message": input({
      schema: z.object({
        user: z.object({ id: z.number(), username: z.string() }),
        text: z.string(),
      }),
      format: ({ data }) =>
        formatMsg({
          role: "user",
          content: data.text,
          user: data.user.username,
        }),
      subscribe(send, agent) {
        const { container } = agent;
        const telegraf = container.resolve("telegraf") as Telegraf;
        telegraf.on("message", (ctx: any) => {
          const chat = ctx.chat;
          const user = ctx.msg.from;

          if ("text" in ctx.message) {
            send(
              telegramChat,
              { chatId: chat.id },
              {
                user: {
                  id: user.id,
                  username: user.username!,
                },
                text: ctx.message.text,
              }
            );
          }
        });

        return () => {};
      },
    }),
  },
  outputs: {
    "telegram:message": output({
      schema: z.object({
        userId: z
          .string()
          .describe("the userId to send the message to, you must include this"),
        content: z.string().describe("the content of the message to send"),
      }),
      description: "use this to send a telegram message to user",
      enabled({ context }) {
        return context.type === telegramChat.type;
      },
      handler: async (data, ctx, { container }) => {
        const tg = container.resolve<Telegraf>("telegraf").telegram;
        const chunks = splitTextIntoChunks(data.content, {
          maxChunkSize: 4096,
        });

        for (const chunck of chunks) {
          await tg.sendMessage(data.userId, chunck);
        }

        return {
          data,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

--- End File: packages/telegram/src/io.ts ---

--- File: packages/telegram/src/telegram.ts ---
import { z } from "zod";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { Telegraf } from "telegraf";
import type { Chat } from "@telegraf/types";
import {
  extension,
  input,
  output,
  splitTextIntoChunks,
} from "@daydreamsai/core";
import { formatMsg } from "@daydreamsai/core";

const telegramService = service({
  register(container) {
    container.singleton(
      "telegraf",
      () => new Telegraf(process.env.TELEGRAM_TOKEN!)
    );
  },
  async boot(container) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    console.log("starting..");
    telegraf.launch({ dropPendingUpdates: true });
    const telegrafInfo = await telegraf.telegram.getMe();
    console.log(telegrafInfo);
  },
});

const telegramChat = context({
  type: "telegram:chat",
  key: ({ chatId }) => chatId.toString(),
  schema: { chatId: z.number() },
  async setup(args, settings, { container }) {
    const telegraf = container.resolve<Telegraf>("telegraf");
    const chat: Chat = await telegraf.telegram.getChat(args.chatId);
    return {
      chat,
    };
  },
  description({ options: { chat } }) {
    if (chat.type === "private") {
      return `You are in private telegram chat with ${chat.username} id: ${chat.id}`;
    }
    return "";
  },
  inputs: {
    "telegram:message": input({
      schema: {
        user: z.object({ id: z.number(), username: z.string() }),
        text: z.string(),
      },
      format({ data: { user, text } }) {
        return {
          tag: "input",
          params: {
            type: "telegram:message",
            userId: user.id.toString(),
            username: user.username,
          },
          children: text,
        };
      },
      subscribe(send, { container }) {
        const tg = container.resolve<Telegraf>("telegraf");
        tg.on("message", (ctx) => {
          const chat = ctx.chat;
          const user = ctx.msg.from;

          if ("text" in ctx.message) {
            send(
              telegramChat,
              { chatId: chat.id },
              {
                user: {
                  id: user.id,
                  username: user.username!,
                },
                text: ctx.message.text,
              }
            );
          }
        });

        return () => {};
      },
    }),
  },
  outputs: {
    "telegram:message": output({
      attributes: {
        userId: z
          .string()
          .describe("the userId to send the message to, you must include this"),
      },
      schema: z
        .string()
        .describe("the content of the message to send using markdown format"),
      description: "use this to send a telegram message to user",
      examples: [
        `<output type="telegram:message" userId="123456789">Hello! How can I assist you today?</output>`,
      ],
      handler: async (data, ctx, { container }) => {
        const tg = container.resolve<Telegraf>("telegraf").telegram;
        const chunks = splitTextIntoChunks(data, {
          maxChunkSize: 4096,
        });

        for (const chunk of chunks) {
          await tg.sendMessage(ctx.outputRef.params!.userId, chunk, {
            parse_mode: "Markdown",
          });
        }

        return {
          data,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

export const telegram = extension({
  name: "telegram",
  services: [telegramService],
  contexts: {
    chat: telegramChat,
  },
});

--- End File: packages/telegram/src/telegram.ts ---

--- File: packages/twitter/package.json ---
{
  "name": "@daydreamsai/twitter",
  "version": "0.3.5",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./dist/index.d.ts",
      "require": "./dist/index.js",
      "import": "./dist/index.js"
    }
  },
  "devDependencies": {
    "@types/bun": "latest",
    "tsup": "^8.3.6",
    "vitest": "^3.0.5"
  },
  "scripts": {
    "test": "vitest",
    "build": "tsup --dts-resolve"
  },
  "peerDependencies": {
    "typescript": "^5.6.3"
  },
  "dependencies": {
    "@daydreamsai/core": "workspace:*",
    "agent-twitter-client": "^0.0.18",
    "zod": "^3.24.2"
  }
}

--- End File: packages/twitter/package.json ---

--- File: packages/twitter/src/index.ts ---
export * from "./twitter";
export * from "./io";

--- End File: packages/twitter/src/index.ts ---

--- File: packages/twitter/src/io.ts ---
import { Scraper, SearchMode, type Tweet } from "agent-twitter-client";
import { Logger } from "@daydreamsai/core";
import { LogLevel } from "@daydreamsai/core";
import { z } from "zod";

const envSchema = z.object({
  TWITTER_USERNAME: z.string(),
  TWITTER_PASSWORD: z.string(),
  TWITTER_EMAIL: z.string(),
  DRY_RUN: z
    .preprocess((val) => val === "1" || val === "true", z.boolean())
    .default(true),
});

export interface TwitterCredentials {
  username: string;
  password: string;
  email: string;
}

export interface TweetData {
  content: string;
  inReplyTo?: string;
  conversationId?: string;
}

export class TwitterClient {
  private scraper: Scraper;
  private isInitialized: boolean = false;
  private lastCheckedTweetId: bigint | null = null;
  private logger: Logger;

  private env: z.infer<typeof envSchema>;
  constructor(
    private credentials: TwitterCredentials,
    logLevel: LogLevel = LogLevel.INFO
  ) {
    this.scraper = new Scraper();
    this.logger = new Logger({
      level: logLevel,
    });

    this.env = envSchema.parse(process.env);
  }

  async initialize() {
    if (!this.isInitialized) {
      try {
        await this.scraper.login(
          this.credentials.username,
          this.credentials.password,
          this.credentials.email
        );
        this.isInitialized = true;
        this.logger.info("TwitterClient", "Initialized successfully");
      } catch (error) {
        this.logger.error("TwitterClient", "Failed to initialize", {
          error,
        });
        throw error;
      }
    }
  }

  async checkMentions() {
    try {
      this.logger.debug("TwitterClient.checkMentions", "Checking mentions", {
        username: this.credentials.username,
      });

      const mentions = await this.scraper.fetchSearchTweets(
        `@${this.credentials.username}`,
        20,
        SearchMode.Latest
      );

      // Convert AsyncGenerator to array and process
      const mentionsArray: Tweet[] = [];
      for await (const tweet of mentions.tweets) {
        mentionsArray.push(tweet);
      }

      // Filter and format mentions
      const newMentions = mentionsArray
        .filter((tweet) => {
          // Skip own tweets and already processed tweets
          if (tweet.userId === this.credentials.username) {
            return false;
          }

          // Check if this is a new tweet we haven't seen
          if (
            this.lastCheckedTweetId &&
            BigInt(tweet.id ?? "") <= this.lastCheckedTweetId
          ) {
            return false;
          }

          // Update last checked ID if newer
          const tweetId = BigInt(tweet.id ?? "");
          if (!this.lastCheckedTweetId || tweetId > this.lastCheckedTweetId) {
            this.lastCheckedTweetId = tweetId;
          }

          return true;
        })
        .map(this.formatTweetData);

      // Only return if we have new mentions
      return newMentions.length > 0 ? newMentions : [];
    } catch (error) {
      this.logger.error(
        "TwitterClient.checkMentions",
        "Error checking mentions",
        { error }
      );
      throw error;
    }
  }

  async fetchUserTweets(username: string): Promise<Tweet[]> {
    const tweets: Tweet[] = [];
    try {
      for await (const tweet of this.scraper.getTweets(username, 10)) {
        tweets.push(tweet);
      }
    } catch (error) {
      this.logger.error(
        "TwitterClient.fetchUserTweets",
        "Error fetching tweets",
        { error }
      );
      throw error;
    }
    return tweets;
  }

  async sendTweet(data: TweetData) {
    try {
      this.logger.info("TwitterClient.sendTweet", "Would send tweet", {
        data,
      });

      if (this.env.DRY_RUN) {
        return {
          success: true,
          tweetId: "DRY RUN TWEET ID",
        };
      }

      const sendTweetResults = await this.scraper.sendTweet(
        data.content,
        data?.inReplyTo
      );

      return {
        success: true,
        tweetId: await sendTweetResults.json(),
      };
    } catch (error) {
      this.logger.error("TwitterClient.sendTweet", "Error sending tweet", {
        error,
      });
      throw error;
    }
  }

  private formatTweetData(tweet: Tweet) {
    return {
      type: "tweet",
      content: tweet.text ?? "",
      metadata: {
        tweetId: tweet.id,
        userId: tweet.userId,
        username: tweet.username,
        timestamp: new Date(tweet.timestamp ?? ""),
        metrics: {
          likes: tweet.likes,
          retweets: tweet.retweets,
          replies: tweet.replies,
        },
        isRetweet: tweet.isRetweet,
        isReply: tweet.isReply,
        hasMedia: tweet.photos.length > 0 || tweet.videos.length > 0,
        url: tweet.permanentUrl,
        conversationId: tweet.conversationId,
        inReplyToId: tweet.inReplyToStatusId,
      },
    };
  }
}

// Example usage:
/*
const twitter = new TwitterClient({
  username: "mybot",
  password: "pass",
  email: "bot@example.com"
});

// Register inputs
core.registerInput(twitter.createMentionsInput());
core.registerInput(twitter.createTimelineInput("elonmusk"));

// Register output
core.registerOutput(twitter.createTweetOutput());
*/

--- End File: packages/twitter/src/io.ts ---

--- File: packages/twitter/src/twitter.ts ---
import { z } from "zod";
import { context } from "@daydreamsai/core";
import { service } from "@daydreamsai/core";
import { TwitterClient } from "./io";
import { extension, input, output } from "@daydreamsai/core";
import { formatXml } from "@daydreamsai/core";

// Define Twitter context
const twitterContext = context({
  type: "twitter:thread",
  key: ({ tweetId }) => tweetId.toString(),
  schema: z.object({
    tweetId: z.string(),
  }),
});

// Twitter service setup
const twitterService = service({
  register(container) {
    container.singleton(
      "twitter",
      () =>
        new TwitterClient({
          username: process.env.TWITTER_USERNAME!,
          password: process.env.TWITTER_PASSWORD!,
          email: process.env.TWITTER_EMAIL!,
        })
    );
  },
  async boot(container) {
    const twitter = container.resolve<TwitterClient>("twitter");
    await twitter.initialize();
    console.log("Twitter client initialized");
  },
});

export const twitter = extension({
  name: "twitter",
  services: [twitterService],
  contexts: {
    twitter: twitterContext,
  },
  inputs: {
    "twitter:mentions": input({
      schema: z.object({
        userId: z.string(),
        tweetId: z.string(),
        text: z.string(),
      }),
      format: ({ data }) =>
        formatXml({
          tag: "tweet",
          params: { tweetId: data.tweetId },
          children: data.text,
        }),
      subscribe(send, agent) {
        const { container } = agent;

        const twitter = container.resolve("twitter") as TwitterClient;

        // Check mentions every minute
        const interval = setInterval(async () => {
          const mentions = await twitter.checkMentions();

          for (const mention of mentions) {
            console.log("Mention", mention);
            send(
              twitterContext,
              { tweetId: mention.metadata.tweetId || "" },
              {
                tweetId: mention.metadata.tweetId || "",
                userId: mention.metadata.userId || "",
                text: mention.content,
              }
            );
          }
        }, 10000);

        return () => clearInterval(interval);
      },
    }),
  },

  outputs: {
    "twitter:reply": output({
      schema: z.object({
        content: z.string().max(280),
        inReplyTo: z.string(),
      }),
      description: "Use this to reply to a tweet",

      handler: async (data, ctx, { container }) => {
        const twitter = container.resolve<TwitterClient>("twitter");
        const { tweetId } = await twitter.sendTweet({
          content: data.content,
          inReplyTo: data.inReplyTo,
        });

        return {
          data: {
            ...data,
            tweetId,
          },
          timestamp: Date.now(),
        };
      },
    }),

    "twitter:tweet": output({
      schema: z.object({
        content: z.string().max(280),
      }),
      description: "Use this to post a new tweet",

      handler: async (data, ctx, { container }) => {
        const twitter = container.resolve<TwitterClient>("twitter");
        await twitter.sendTweet({
          content: data.content,
        });
        return {
          data,
          timestamp: Date.now(),
        };
      },
    }),
  },
});

--- End File: packages/twitter/src/twitter.ts ---

